<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title> TemplateACE_Timer_Heap_T class Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body bgcolor="#ffffff">
<!-- Generated by Doxygen 1.2.13.1 -->
<center>
<a class="qindex" href="index.html">Main Page</a> &nbsp; <a class="qindex" href="hierarchy.html">Class Hierarchy</a> &nbsp; <a class="qindex" href="classes.html">Alphabetical List</a> &nbsp; <a class="qindex" href="annotated.html">Compound List</a> &nbsp; <a class="qindex" href="files.html">File List</a> &nbsp; <a class="qindex" href="functions.html">Compound Members</a> &nbsp; <a class="qindex" href="globals.html">File Members</a> &nbsp; <a class="qindex" href="pages.html">Related Pages</a> &nbsp; </center>
<hr><h1>ACE_Timer_Heap_T  Class Template Reference</h1>Provides a very fast and predictable timer implementation. 
<a href="#_details">More...</a>
<p>
<code>#include &lt;Timer_Heap_T.h&gt;</code>
<p>
Inheritance diagram for ACE_Timer_Heap_T:<p><center><img src="classACE__Timer__Heap__T__inherit__graph.gif" border="0" usemap="#ACE__Timer__Heap__T_3_01TYPE_00_01FUNCTOR_00_01ACE__LOCK_01_4__inherit__map" alt="Inheritance graph"></center>
<map name="ACE__Timer__Heap__T_3_01TYPE_00_01FUNCTOR_00_01ACE__LOCK_01_4__inherit__map">
<area href="classACE__Timer__Queue__T.html" shape="rect" coords="14,15,366,34" alt="">
</map>
<center><font size="2">[<a href="graph_legend.html">legend</a>]</font></center>Collaboration diagram for ACE_Timer_Heap_T:<p><center><img src="classACE__Timer__Heap__T__coll__graph.gif" border="0" usemap="#ACE__Timer__Heap__T_3_01TYPE_00_01FUNCTOR_00_01ACE__LOCK_01_4__coll__map" alt="Collaboration graph"></center>
<map name="ACE__Timer__Heap__T_3_01TYPE_00_01FUNCTOR_00_01ACE__LOCK_01_4__coll__map">
<area href="classACE__Timer__Heap__Iterator__T.html" shape="rect" coords="1078,101,1467,119" alt="">
<area href="classACE__Timer__Queue__T.html" shape="rect" coords="25,7,377,26" alt="">
<area href="classACE__Timer__Node__T.html" shape="rect" coords="105,109,297,127" alt="">
<area href="classACE__Unbounded__Set.html" shape="rect" coords="29,169,373,187" alt="">
</map>
<center><font size="2">[<a href="graph_legend.html">legend</a>]</font></center><a href="classACE__Timer__Heap__T-members.html">List of all members.</a><table border=0 cellpadding=0 cellspacing=0>
<tr><td colspan=2><br><h2>Public Types</h2></td></tr>
<tr><td nowrap align=right valign=top>typedef <a class="el" href="classACE__Timer__Heap__Iterator__T.html">ACE_Timer_Heap_Iterator_T</a>&lt;<br>
 TYPE, FUNCTOR, ACE_LOCK &gt;&nbsp;</td><td valign=bottom><a class="el" href="classACE__Timer__Heap__T.html#s0">HEAP_ITERATOR</a></td></tr>
<tr><td nowrap align=right valign=top>typedef <a class="el" href="classACE__Timer__Queue__T.html">ACE_Timer_Queue_T</a>&lt;<br>
 TYPE, FUNCTOR, ACE_LOCK &gt;&nbsp;</td><td valign=bottom><a class="el" href="classACE__Timer__Heap__T.html#s1">INHERITED</a></td></tr>
<tr><td colspan=2><br><h2>Public Methods</h2></td></tr>
<tr><td nowrap align=right valign=top>&nbsp;</td><td valign=bottom><a class="el" href="classACE__Timer__Heap__T.html#a0">ACE_Timer_Heap_T</a> (size_t size, int preallocated=0, FUNCTOR *upcall_functor=0, <a class="el" href="classACE__Free__List.html">ACE_Free_List</a>&lt; <a class="el" href="classACE__Timer__Node__T.html">ACE_Timer_Node_T</a>&lt; TYPE &gt; &gt; *freelist=0)</td></tr>
<tr><td nowrap align=right valign=top>&nbsp;</td><td valign=bottom><a class="el" href="classACE__Timer__Heap__T.html#a1">ACE_Timer_Heap_T</a> (FUNCTOR *upcall_functor=0, <a class="el" href="classACE__Free__List.html">ACE_Free_List</a>&lt; <a class="el" href="classACE__Timer__Node__T.html">ACE_Timer_Node_T</a>&lt; TYPE &gt; &gt; *freelist=0)</td></tr>
<tr><td nowrap align=right valign=top>virtual&nbsp;</td><td valign=bottom><a class="el" href="classACE__Timer__Heap__T.html#a2">~ACE_Timer_Heap_T</a> (void)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Destructor.</em> <a href="#a2">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>virtual int&nbsp;</td><td valign=bottom><a class="el" href="classACE__Timer__Heap__T.html#a3">is_empty</a> (void) const</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>True if heap is empty, else false.</em> <a href="#a3">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>virtual const <a class="el" href="classACE__Time__Value.html">ACE_Time_Value</a> &amp;&nbsp;</td><td valign=bottom><a class="el" href="classACE__Timer__Heap__T.html#a4">earliest_time</a> (void) const</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Returns the time of the earliest node in the Timer_Queue. Must be called on a non-empty queue.</em> <a href="#a4">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>virtual long&nbsp;</td><td valign=bottom><a class="el" href="classACE__Timer__Heap__T.html#a5">schedule</a> (const TYPE &amp;type, const void *act, const <a class="el" href="classACE__Time__Value.html">ACE_Time_Value</a> &amp;future_time, const <a class="el" href="classACE__Time__Value.html">ACE_Time_Value</a> &amp;interval=<a class="el" href="classACE__Time__Value.html#p0">ACE_Time_Value::zero</a>)</td></tr>
<tr><td nowrap align=right valign=top>virtual int&nbsp;</td><td valign=bottom><a class="el" href="classACE__Timer__Heap__T.html#a6">reset_interval</a> (long timer_id, const <a class="el" href="classACE__Time__Value.html">ACE_Time_Value</a> &amp;interval)</td></tr>
<tr><td nowrap align=right valign=top>virtual int&nbsp;</td><td valign=bottom><a class="el" href="classACE__Timer__Heap__T.html#a7">cancel</a> (const TYPE &amp;type, int dont_call_handle_close=1)</td></tr>
<tr><td nowrap align=right valign=top>virtual int&nbsp;</td><td valign=bottom><a class="el" href="classACE__Timer__Heap__T.html#a8">cancel</a> (long timer_id, const void **act=0, int dont_call_handle_close=1)</td></tr>
<tr><td nowrap align=right valign=top>virtual <a class="el" href="classACE__Timer__Queue__Iterator__T.html">ACE_Timer_Queue_Iterator_T</a>&lt;<br>
 TYPE, FUNCTOR, ACE_LOCK &gt; &amp;&nbsp;</td><td valign=bottom><a class="el" href="classACE__Timer__Heap__T.html#a9">iter</a> (void)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Returns a pointer to this &lt;ACE_Timer_Queue&gt;'s iterator.</em> <a href="#a9">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top><a class="el" href="classACE__Timer__Node__T.html">ACE_Timer_Node_T</a>&lt; TYPE &gt; *&nbsp;</td><td valign=bottom><a class="el" href="classACE__Timer__Heap__T.html#a10">remove_first</a> (void)</td></tr>
<tr><td nowrap align=right valign=top>virtual void&nbsp;</td><td valign=bottom><a class="el" href="classACE__Timer__Heap__T.html#a11">dump</a> (void) const</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Dump the state of an object.</em> <a href="#a11">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>virtual <a class="el" href="classACE__Timer__Node__T.html">ACE_Timer_Node_T</a>&lt;<br>
 TYPE &gt; *&nbsp;</td><td valign=bottom><a class="el" href="classACE__Timer__Heap__T.html#a12">get_first</a> (void)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Reads the earliest node from the queue and returns it.</em> <a href="#a12">More...</a><em></em></font><br><br></td></tr>
<tr><td colspan=2><br><h2>Protected Methods</h2></td></tr>
<tr><td nowrap align=right valign=top>virtual void&nbsp;</td><td valign=bottom><a class="el" href="classACE__Timer__Heap__T.html#b0">reschedule</a> (<a class="el" href="classACE__Timer__Node__T.html">ACE_Timer_Node_T</a>&lt; TYPE &gt; *)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Reschedule an "interval" &lt;ACE_Timer_Node&gt;.</em> <a href="#b0">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>virtual <a class="el" href="classACE__Timer__Node__T.html">ACE_Timer_Node_T</a>&lt;<br>
 TYPE &gt; *&nbsp;</td><td valign=bottom><a class="el" href="classACE__Timer__Heap__T.html#b1">alloc_node</a> (void)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Factory method that allocates a new node (uses operator new if we're *not* preallocating, otherwise uses an internal freelist).</em> <a href="#b1">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>virtual void&nbsp;</td><td valign=bottom><a class="el" href="classACE__Timer__Heap__T.html#b2">free_node</a> (<a class="el" href="classACE__Timer__Node__T.html">ACE_Timer_Node_T</a>&lt; TYPE &gt; *)</td></tr>
<tr><td colspan=2><br><h2>Private Methods</h2></td></tr>
<tr><td nowrap align=right valign=top><a class="el" href="classACE__Timer__Node__T.html">ACE_Timer_Node_T</a>&lt; TYPE &gt; *&nbsp;</td><td valign=bottom><a class="el" href="classACE__Timer__Heap__T.html#c0">remove</a> (size_t slot)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Remove and return the &lt;slot&gt;th &lt;ACE_Timer_Node&gt; and restore the heap property.</em> <a href="#c0">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classACE__Timer__Heap__T.html#c1">insert</a> (<a class="el" href="classACE__Timer__Node__T.html">ACE_Timer_Node_T</a>&lt; TYPE &gt; *new_node)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Insert <em>new_node</em> into the heap and restore the heap property.</em> <a href="#c1">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classACE__Timer__Heap__T.html#c2">grow_heap</a> (void)</td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classACE__Timer__Heap__T.html#c3">reheap_up</a> (<a class="el" href="classACE__Timer__Node__T.html">ACE_Timer_Node_T</a>&lt; TYPE &gt; *new_node, size_t slot, size_t parent)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Restore the heap property, starting at &lt;slot&gt;.</em> <a href="#c3">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classACE__Timer__Heap__T.html#c4">reheap_down</a> (<a class="el" href="classACE__Timer__Node__T.html">ACE_Timer_Node_T</a>&lt; TYPE &gt; *moved_node, size_t slot, size_t child)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Restore the heap property, starting at &lt;slot&gt;.</em> <a href="#c4">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classACE__Timer__Heap__T.html#c5">copy</a> (size_t slot, <a class="el" href="classACE__Timer__Node__T.html">ACE_Timer_Node_T</a>&lt; TYPE &gt; *moved_node)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Copy &lt;moved_node&gt; into the &lt;slot&gt; slot of &lt;heap_&gt; and move &lt;slot&gt; into the corresponding slot in the &lt;timer_id_&gt; array.</em> <a href="#c5">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>int&nbsp;</td><td valign=bottom><a class="el" href="classACE__Timer__Heap__T.html#c6">timer_id</a> (void)</td></tr>
<tr><td nowrap align=right valign=top>int&nbsp;</td><td valign=bottom><a class="el" href="classACE__Timer__Heap__T.html#c7">pop_freelist</a> (void)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Pops and returns a new timer id from the freelist.</em> <a href="#c7">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classACE__Timer__Heap__T.html#c8">push_freelist</a> (int old_id)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Pushes &lt;old_id&gt; onto the freelist.</em> <a href="#c8">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>&nbsp;</td><td valign=bottom><a class="el" href="classACE__Timer__Heap__T.html#c9">ACE_Timer_Heap_T</a> (const ACE_Timer_Heap_T&lt; TYPE, FUNCTOR, ACE_LOCK &gt; &amp;)</td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classACE__Timer__Heap__T.html#c10">operator=</a> (const ACE_Timer_Heap_T&lt; TYPE, FUNCTOR, ACE_LOCK &gt; &amp;)</td></tr>
<tr><td colspan=2><br><h2>Private Attributes</h2></td></tr>
<tr><td nowrap align=right valign=top>size_t&nbsp;</td><td valign=bottom><a class="el" href="classACE__Timer__Heap__T.html#o0">max_size_</a></td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Maximum size of the heap.</em> <a href="#o0">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>size_t&nbsp;</td><td valign=bottom><a class="el" href="classACE__Timer__Heap__T.html#o1">cur_size_</a></td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Current size of the heap.</em> <a href="#o1">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>size_t&nbsp;</td><td valign=bottom><a class="el" href="classACE__Timer__Heap__T.html#o2">cur_limbo_</a></td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Number of heap entries in transition (removed from the queue, but not freed) and may be rescheduled or freed.</em> <a href="#o2">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top><a class="el" href="classACE__Timer__Heap__T.html#s0">HEAP_ITERATOR</a> *&nbsp;</td><td valign=bottom><a class="el" href="classACE__Timer__Heap__T.html#o3">iterator_</a></td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Iterator used to expire timers.</em> <a href="#o3">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top><a class="el" href="classACE__Timer__Node__T.html">ACE_Timer_Node_T</a>&lt; TYPE &gt; **&nbsp;</td><td valign=bottom><a class="el" href="classACE__Timer__Heap__T.html#o4">heap_</a></td></tr>
<tr><td nowrap align=right valign=top><a class="el" href="Basic__Types_8h.html#a38">ssize_t</a> *&nbsp;</td><td valign=bottom><a class="el" href="classACE__Timer__Heap__T.html#o5">timer_ids_</a></td></tr>
<tr><td nowrap align=right valign=top>size_t&nbsp;</td><td valign=bottom><a class="el" href="classACE__Timer__Heap__T.html#o6">timer_ids_curr_</a></td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>"Pointer" to the element in the &lt;timer_ids_&gt; array that was last given out as a timer ID.</em> <a href="#o6">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>size_t&nbsp;</td><td valign=bottom><a class="el" href="classACE__Timer__Heap__T.html#o7">timer_ids_min_free_</a></td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Index representing the lowest timer ID that has been freed. When the timer_ids_next_ value wraps around, it starts back at this point.</em> <a href="#o7">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top><a class="el" href="classACE__Timer__Node__T.html">ACE_Timer_Node_T</a>&lt; TYPE &gt; *&nbsp;</td><td valign=bottom><a class="el" href="classACE__Timer__Heap__T.html#o8">preallocated_nodes_</a></td></tr>
<tr><td nowrap align=right valign=top><a class="el" href="classACE__Timer__Node__T.html">ACE_Timer_Node_T</a>&lt; TYPE &gt; *&nbsp;</td><td valign=bottom><a class="el" href="classACE__Timer__Heap__T.html#o9">preallocated_nodes_freelist_</a></td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>This points to the head of the &lt;preallocated_nodes_&gt; freelist, which is organized as a stack.</em> <a href="#o9">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top><a class="el" href="classACE__Unbounded__Set.html">ACE_Unbounded_Set</a>&lt; <a class="el" href="classACE__Timer__Node__T.html">ACE_Timer_Node_T</a>&lt;<br>
 TYPE &gt; *&gt;&nbsp;</td><td valign=bottom><a class="el" href="classACE__Timer__Heap__T.html#o10">preallocated_node_set_</a></td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Set of pointers to the arrays of preallocated timer nodes. Used to delete the allocated memory when required.</em> <a href="#o10">More...</a><em></em></font><br><br></td></tr>
<tr><td colspan=2><br><h2>Friends</h2></td></tr>
<tr><td nowrap align=right valign=top>class&nbsp;</td><td valign=bottom><a class="el" href="classACE__Timer__Heap__T.html#l0">ACE_Timer_Heap_Iterator_T&lt; TYPE, FUNCTOR, ACE_LOCK &gt;</a></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
<h3>template&lt;class TYPE, class FUNCTOR, class ACE_LOCK&gt;<br>
 class ACE_Timer_Heap_T&lt; TYPE, FUNCTOR, ACE_LOCK &gt;</h3>

Provides a very fast and predictable timer implementation.
<p>

<p>
 This implementation uses a heap-based callout queue of absolute times. Therefore, in the average and worst case, scheduling, canceling, and expiring timers is O(log N) (where N is the total number of timers). In addition, we can also preallocate as many <code><a class="el" href="Timer__Queue_8h.html#a1">ACE_Timer_Node</a></code> objects as there are slots in the heap. This allows us to completely remove the need for dynamic memory allocation, which is important for real-time systems. 
<p>
<hr><h2>Member Typedef Documentation</h2>
<a name="s0" doxytag="ACE_Timer_Heap_T::HEAP_ITERATOR"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class TYPE, class FUNCTOR, class ACE_LOCK&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> typedef <a class="el" href="classACE__Timer__Heap__Iterator__T.html">ACE_Timer_Heap_Iterator_T</a>&lt;TYPE, FUNCTOR, ACE_LOCK&gt; ACE_Timer_Heap_T::HEAP_ITERATOR
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a name="s1" doxytag="ACE_Timer_Heap_T::INHERITED"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class TYPE, class FUNCTOR, class ACE_LOCK&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> typedef <a class="el" href="classACE__Timer__Queue__T.html">ACE_Timer_Queue_T</a>&lt;TYPE, FUNCTOR, ACE_LOCK&gt; ACE_Timer_Heap_T::INHERITED
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a name="a0" doxytag="ACE_Timer_Heap_T::ACE_Timer_Heap_T"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class TYPE, class FUNCTOR, class ACE_LOCK&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> ACE_Timer_Heap_T&lt; TYPE, FUNCTOR, ACE_LOCK &gt;::ACE_Timer_Heap_T </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">size_t&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>size</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>preallocate</em> = 0, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>FUNCTOR *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>upcall_functor</em> = 0, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="classACE__Free__List.html">ACE_Free_List</a>&lt; <a class="el" href="classACE__Timer__Node__T.html">ACE_Timer_Node_T</a>&lt; TYPE &gt; &gt; *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>freelist</em> = 0</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
The Constructor creates a heap with specified number of elements. This can also take in a upcall functor and freelist (if 0, then defaults will be created).<dl compact><dt><b>
Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>size</em>&nbsp;</td><td>
The maximum number of timers that can be inserted into the new object. </td></tr>
<tr><td valign=top><em>preallocated</em>&nbsp;</td><td>
Default 0, if non-0 then all the memory for the <code><a class="el" href="Timer__Queue_8h.html#a1">ACE_Timer_Node</a></code> objects will be pre-allocated. This saves time and is more predictable (though it requires more space). Otherwise, timer nodes are allocated as needed. </td></tr>
<tr><td valign=top><em>freelist</em>&nbsp;</td><td>
is the freelist of timer nodes. </td></tr>
<tr><td valign=top><em>upcall_functor</em>&nbsp;</td><td>
If 0 Timer Heap will create a default FUNCTOR. </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<a name="a1" doxytag="ACE_Timer_Heap_T::ACE_Timer_Heap_T"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class TYPE, class FUNCTOR, class ACE_LOCK&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> ACE_Timer_Heap_T&lt; TYPE, FUNCTOR, ACE_LOCK &gt;::ACE_Timer_Heap_T </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">FUNCTOR *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>upcall_functor</em> = 0, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="classACE__Free__List.html">ACE_Free_List</a>&lt; <a class="el" href="classACE__Timer__Node__T.html">ACE_Timer_Node_T</a>&lt; TYPE &gt; &gt; *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>freelist</em> = 0</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Default constructor. <code>upcall_functor</code> is the instance of the FUNCTOR to be used by the queue. If <code>upcall_functor</code> is 0, Timer Heap will create a default FUNCTOR. <code>freelist</code> is the freelist of timer nodes. If 0, then a default freelist will be created. The default size will be ACE_DEFAULT_TIMERS and there will be no preallocation.     </td>
  </tr>
</table>
<a name="a2" doxytag="ACE_Timer_Heap_T::~ACE_Timer_Heap_T"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class TYPE, class FUNCTOR, class ACE_LOCK&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> ACE_Timer_Heap_T&lt; TYPE, FUNCTOR, ACE_LOCK &gt;::~ACE_Timer_Heap_T </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Destructor.
<p>
    </td>
  </tr>
</table>
<a name="c9" doxytag="ACE_Timer_Heap_T::ACE_Timer_Heap_T"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class TYPE, class FUNCTOR, class ACE_LOCK&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> ACE_Timer_Heap_T&lt; TYPE, FUNCTOR, ACE_LOCK &gt;::ACE_Timer_Heap_T </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const ACE_Timer_Heap_T&lt; TYPE, FUNCTOR, ACE_LOCK &gt; &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [private]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<hr><h2>Member Function Documentation</h2>
<a name="b1" doxytag="ACE_Timer_Heap_T::alloc_node"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class TYPE, class FUNCTOR, class ACE_LOCK&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="classACE__Timer__Node__T.html">ACE_Timer_Node_T</a>&lt; TYPE &gt; * ACE_Timer_Heap_T&lt; TYPE, FUNCTOR, ACE_LOCK &gt;::alloc_node </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [protected, virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Factory method that allocates a new node (uses operator new if we're *not* preallocating, otherwise uses an internal freelist).
<p>

<p>
Reimplemented from <a class="el" href="classACE__Timer__Queue__T.html#b1">ACE_Timer_Queue_T</a>.    </td>
  </tr>
</table>
<a name="a8" doxytag="ACE_Timer_Heap_T::cancel"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class TYPE, class FUNCTOR, class ACE_LOCK&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> int ACE_Timer_Heap_T&lt; TYPE, FUNCTOR, ACE_LOCK &gt;::cancel </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">long&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>timer_id</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const void **&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>act</em> = 0, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>dont_call</em> = 1</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Cancel the single timer that matches the &lt;timer_id&gt; value (which was returned from the &lt;schedule&gt; method). If act is non-NULL then it will be set to point to the ``magic cookie'' argument passed in when the timer was registered. This makes it possible to free up the memory and avoid memory leaks. If &lt;dont_call&gt; is 0 then the &lt;functor&gt; will be invoked. Returns 1 if cancellation succeeded and 0 if the &lt;timer_id&gt; wasn't found. 
<p>
Reimplemented from <a class="el" href="classACE__Timer__Queue__T.html#a7">ACE_Timer_Queue_T</a>.    </td>
  </tr>
</table>
<a name="a7" doxytag="ACE_Timer_Heap_T::cancel"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class TYPE, class FUNCTOR, class ACE_LOCK&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> int ACE_Timer_Heap_T&lt; TYPE, FUNCTOR, ACE_LOCK &gt;::cancel </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const TYPE &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>type</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>dont_call</em> = 1</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Cancel all timers associated with &lt;type&gt;. If &lt;dont_call&gt; is 0 then the &lt;functor&gt; will be invoked. Returns number of timers cancelled. 
<p>
Reimplemented from <a class="el" href="classACE__Timer__Queue__T.html#a6">ACE_Timer_Queue_T</a>.    </td>
  </tr>
</table>
<a name="c5" doxytag="ACE_Timer_Heap_T::copy"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class TYPE, class FUNCTOR, class ACE_LOCK&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> void ACE_Timer_Heap_T&lt; TYPE, FUNCTOR, ACE_LOCK &gt;::copy </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">size_t&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>slot</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="classACE__Timer__Node__T.html">ACE_Timer_Node_T</a>&lt; TYPE &gt; *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>moved_node</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [private]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Copy &lt;moved_node&gt; into the &lt;slot&gt; slot of &lt;heap_&gt; and move &lt;slot&gt; into the corresponding slot in the &lt;timer_id_&gt; array.
<p>
    </td>
  </tr>
</table>
<a name="a11" doxytag="ACE_Timer_Heap_T::dump"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class TYPE, class FUNCTOR, class ACE_LOCK&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> void ACE_Timer_Heap_T&lt; TYPE, FUNCTOR, ACE_LOCK &gt;::dump </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap> const<code> [virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Dump the state of an object.
<p>

<p>
Reimplemented from <a class="el" href="classACE__Timer__Queue__T.html#a21">ACE_Timer_Queue_T</a>.    </td>
  </tr>
</table>
<a name="a4" doxytag="ACE_Timer_Heap_T::earliest_time"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class TYPE, class FUNCTOR, class ACE_LOCK&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> const <a class="el" href="classACE__Time__Value.html">ACE_Time_Value</a> &amp; ACE_Timer_Heap_T&lt; TYPE, FUNCTOR, ACE_LOCK &gt;::earliest_time </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap> const<code> [virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns the time of the earliest node in the Timer_Queue. Must be called on a non-empty queue.
<p>

<p>
Reimplemented from <a class="el" href="classACE__Timer__Queue__T.html#a3">ACE_Timer_Queue_T</a>.    </td>
  </tr>
</table>
<a name="b2" doxytag="ACE_Timer_Heap_T::free_node"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class TYPE, class FUNCTOR, class ACE_LOCK&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> void ACE_Timer_Heap_T&lt; TYPE, FUNCTOR, ACE_LOCK &gt;::free_node </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classACE__Timer__Node__T.html">ACE_Timer_Node_T</a>&lt; TYPE &gt; *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>node</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [protected, virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Factory method that frees a previously allocated node (uses operator delete if we're *not* preallocating, otherwise uses an internal freelist). 
<p>
Reimplemented from <a class="el" href="classACE__Timer__Queue__T.html#b2">ACE_Timer_Queue_T</a>.    </td>
  </tr>
</table>
<a name="a12" doxytag="ACE_Timer_Heap_T::get_first"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class TYPE, class FUNCTOR, class ACE_LOCK&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="classACE__Timer__Node__T.html">ACE_Timer_Node_T</a>&lt; TYPE &gt; * ACE_Timer_Heap_T&lt; TYPE, FUNCTOR, ACE_LOCK &gt;::get_first </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Reads the earliest node from the queue and returns it.
<p>

<p>
Reimplemented from <a class="el" href="classACE__Timer__Queue__T.html#a22">ACE_Timer_Queue_T</a>.    </td>
  </tr>
</table>
<a name="c2" doxytag="ACE_Timer_Heap_T::grow_heap"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class TYPE, class FUNCTOR, class ACE_LOCK&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> void ACE_Timer_Heap_T&lt; TYPE, FUNCTOR, ACE_LOCK &gt;::grow_heap </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [private]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Doubles the size of the heap and the corresponding timer_ids array. If preallocation is used, will also double the size of the preallocated array of ACE_Timer_Nodes.     </td>
  </tr>
</table>
<a name="c1" doxytag="ACE_Timer_Heap_T::insert"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class TYPE, class FUNCTOR, class ACE_LOCK&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> void ACE_Timer_Heap_T&lt; TYPE, FUNCTOR, ACE_LOCK &gt;::insert </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classACE__Timer__Node__T.html">ACE_Timer_Node_T</a>&lt; TYPE &gt; *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>new_node</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [private]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Insert <em>new_node</em> into the heap and restore the heap property.
<p>
    </td>
  </tr>
</table>
<a name="a3" doxytag="ACE_Timer_Heap_T::is_empty"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class TYPE, class FUNCTOR, class ACE_LOCK&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> int ACE_Timer_Heap_T&lt; TYPE, FUNCTOR, ACE_LOCK &gt;::is_empty </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap> const<code> [virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
True if heap is empty, else false.
<p>

<p>
Reimplemented from <a class="el" href="classACE__Timer__Queue__T.html#a2">ACE_Timer_Queue_T</a>.    </td>
  </tr>
</table>
<a name="a9" doxytag="ACE_Timer_Heap_T::iter"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class TYPE, class FUNCTOR, class ACE_LOCK&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="classACE__Timer__Queue__Iterator__T.html">ACE_Timer_Queue_Iterator_T</a>&lt; TYPE, FUNCTOR, ACE_LOCK &gt; &amp; ACE_Timer_Heap_T&lt; TYPE, FUNCTOR, ACE_LOCK &gt;::iter </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns a pointer to this &lt;ACE_Timer_Queue&gt;'s iterator.
<p>

<p>
Reimplemented from <a class="el" href="classACE__Timer__Queue__T.html#a19">ACE_Timer_Queue_T</a>.    </td>
  </tr>
</table>
<a name="c10" doxytag="ACE_Timer_Heap_T::operator="></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class TYPE, class FUNCTOR, class ACE_LOCK&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> void ACE_Timer_Heap_T&lt; TYPE, FUNCTOR, ACE_LOCK &gt;::operator= </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const ACE_Timer_Heap_T&lt; TYPE, FUNCTOR, ACE_LOCK &gt; &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [private]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a name="c7" doxytag="ACE_Timer_Heap_T::pop_freelist"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class TYPE, class FUNCTOR, class ACE_LOCK&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> int ACE_Timer_Heap_T&lt; TYPE, FUNCTOR, ACE_LOCK &gt;::pop_freelist </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [private]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Pops and returns a new timer id from the freelist.
<p>
    </td>
  </tr>
</table>
<a name="c8" doxytag="ACE_Timer_Heap_T::push_freelist"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class TYPE, class FUNCTOR, class ACE_LOCK&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> void ACE_Timer_Heap_T&lt; TYPE, FUNCTOR, ACE_LOCK &gt;::push_freelist </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>old_id</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [private]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Pushes &lt;old_id&gt; onto the freelist.
<p>
    </td>
  </tr>
</table>
<a name="c4" doxytag="ACE_Timer_Heap_T::reheap_down"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class TYPE, class FUNCTOR, class ACE_LOCK&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> void ACE_Timer_Heap_T&lt; TYPE, FUNCTOR, ACE_LOCK &gt;::reheap_down </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classACE__Timer__Node__T.html">ACE_Timer_Node_T</a>&lt; TYPE &gt; *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>moved_node</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>size_t&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>slot</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>size_t&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>child</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [private]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Restore the heap property, starting at &lt;slot&gt;.
<p>
    </td>
  </tr>
</table>
<a name="c3" doxytag="ACE_Timer_Heap_T::reheap_up"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class TYPE, class FUNCTOR, class ACE_LOCK&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> void ACE_Timer_Heap_T&lt; TYPE, FUNCTOR, ACE_LOCK &gt;::reheap_up </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classACE__Timer__Node__T.html">ACE_Timer_Node_T</a>&lt; TYPE &gt; *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>moved_node</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>size_t&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>slot</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>size_t&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>parent</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [private]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Restore the heap property, starting at &lt;slot&gt;.
<p>
    </td>
  </tr>
</table>
<a name="c0" doxytag="ACE_Timer_Heap_T::remove"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class TYPE, class FUNCTOR, class ACE_LOCK&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="classACE__Timer__Node__T.html">ACE_Timer_Node_T</a>&lt; TYPE &gt; * ACE_Timer_Heap_T&lt; TYPE, FUNCTOR, ACE_LOCK &gt;::remove </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">size_t&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>slot</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [private]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Remove and return the &lt;slot&gt;th &lt;ACE_Timer_Node&gt; and restore the heap property.
<p>
    </td>
  </tr>
</table>
<a name="a10" doxytag="ACE_Timer_Heap_T::remove_first"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class TYPE, class FUNCTOR, class ACE_LOCK&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="classACE__Timer__Node__T.html">ACE_Timer_Node_T</a>&lt; TYPE &gt; * ACE_Timer_Heap_T&lt; TYPE, FUNCTOR, ACE_LOCK &gt;::remove_first </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Removes the earliest node from the queue and returns it. Note that the timer is removed from the heap, but is not freed, and its ID is not reclaimed. The caller is responsible for calling either <code><a class="el" href="classACE__Timer__Heap__T.html#b0">reschedule</a>()</code> or <code><a class="el" href="classACE__Timer__Heap__T.html#b2">free_node</a>()</code> after this function returns. Thus, this function is for support of <code>ACE_Timer_Queue::expire</code> and should not be used unadvisedly in other conditions. 
<p>
Reimplemented from <a class="el" href="classACE__Timer__Queue__T.html#a20">ACE_Timer_Queue_T</a>.    </td>
  </tr>
</table>
<a name="b0" doxytag="ACE_Timer_Heap_T::reschedule"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class TYPE, class FUNCTOR, class ACE_LOCK&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> void ACE_Timer_Heap_T&lt; TYPE, FUNCTOR, ACE_LOCK &gt;::reschedule </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classACE__Timer__Node__T.html">ACE_Timer_Node_T</a>&lt; TYPE &gt; *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>expired</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [protected, virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Reschedule an "interval" &lt;ACE_Timer_Node&gt;.
<p>

<p>
Reimplemented from <a class="el" href="classACE__Timer__Queue__T.html#b0">ACE_Timer_Queue_T</a>.    </td>
  </tr>
</table>
<a name="a6" doxytag="ACE_Timer_Heap_T::reset_interval"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class TYPE, class FUNCTOR, class ACE_LOCK&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> int ACE_Timer_Heap_T&lt; TYPE, FUNCTOR, ACE_LOCK &gt;::reset_interval </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">long&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>timer_id</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const <a class="el" href="classACE__Time__Value.html">ACE_Time_Value</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>interval</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Resets the interval of the timer represented by &lt;timer_id&gt; to &lt;interval&gt;, which is specified in relative time to the current &lt;gettimeofday&gt;. If &lt;interval&gt; is equal to &lt;<a class="el" href="classACE__Time__Value.html#p0">ACE_Time_Value::zero</a>&gt;, the timer will become a non-rescheduling timer. Returns 0 if successful, -1 if not. 
<p>
Reimplemented from <a class="el" href="classACE__Timer__Queue__T.html#a5">ACE_Timer_Queue_T</a>.    </td>
  </tr>
</table>
<a name="a5" doxytag="ACE_Timer_Heap_T::schedule"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class TYPE, class FUNCTOR, class ACE_LOCK&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> long ACE_Timer_Heap_T&lt; TYPE, FUNCTOR, ACE_LOCK &gt;::schedule </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const TYPE &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>type</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const void *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>act</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const <a class="el" href="classACE__Time__Value.html">ACE_Time_Value</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>future_time</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const <a class="el" href="classACE__Time__Value.html">ACE_Time_Value</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>interval</em> = <a class="el" href="classACE__Time__Value.html#p0">ACE_Time_Value::zero</a></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Schedule a timer that may optionally auto-reset. Schedule &lt;type&gt; that will expire at &lt;future_time&gt;, which is specified in absolute time. If it expires then &lt;act&gt; is passed in as the value to the &lt;functor&gt;. If &lt;interval&gt; is != to &lt;<a class="el" href="classACE__Time__Value.html#p0">ACE_Time_Value::zero</a>&gt; then it is used to reschedule the &lt;type&gt; automatically, using relative time to the current &lt;gettimeofday&gt;. This method returns a &lt;timer_id&gt; that uniquely identifies the the &lt;type&gt; entry in an internal list. This &lt;timer_id&gt; can be used to cancel the timer before it expires. The cancellation ensures that &lt;timer_ids&gt; are unique up to values of greater than 2 billion timers. As long as timers don't stay around longer than this there should be no problems with accidentally deleting the wrong timer. Returns -1 on failure (which is guaranteed never to be a valid &lt;timer_id&gt;). 
<p>
Reimplemented from <a class="el" href="classACE__Timer__Queue__T.html#a4">ACE_Timer_Queue_T</a>.    </td>
  </tr>
</table>
<a name="c6" doxytag="ACE_Timer_Heap_T::timer_id"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class TYPE, class FUNCTOR, class ACE_LOCK&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> int ACE_Timer_Heap_T&lt; TYPE, FUNCTOR, ACE_LOCK &gt;::timer_id </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [private]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns a timer id that uniquely identifies this timer. This id can be used to cancel a timer via the &lt;cancel (int)&gt; method. The timer id returned from this method will never == -1 to avoid conflicts with other failure return values.     </td>
  </tr>
</table>
<hr><h2>Friends And Related Function Documentation</h2>
<a name="l0" doxytag="ACE_Timer_Heap_T::ACE_Timer_Heap_Iterator_T< TYPE, FUNCTOR, ACE_LOCK >"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class TYPE, class FUNCTOR, class ACE_LOCK&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> friend class <a class="el" href="classACE__Timer__Heap__Iterator__T.html">ACE_Timer_Heap_Iterator_T</a>&lt; TYPE, FUNCTOR, ACE_LOCK &gt;<code> [friend]</code>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<hr><h2>Member Data Documentation</h2>
<a name="o2" doxytag="ACE_Timer_Heap_T::cur_limbo_"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class TYPE, class FUNCTOR, class ACE_LOCK&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> size_t ACE_Timer_Heap_T::cur_limbo_<code> [private]</code>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Number of heap entries in transition (removed from the queue, but not freed) and may be rescheduled or freed.
<p>
    </td>
  </tr>
</table>
<a name="o1" doxytag="ACE_Timer_Heap_T::cur_size_"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class TYPE, class FUNCTOR, class ACE_LOCK&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> size_t ACE_Timer_Heap_T::cur_size_<code> [private]</code>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Current size of the heap.
<p>
    </td>
  </tr>
</table>
<a name="o4" doxytag="ACE_Timer_Heap_T::heap_"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class TYPE, class FUNCTOR, class ACE_LOCK&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="classACE__Timer__Node__T.html">ACE_Timer_Node_T</a>&lt;TYPE&gt;** ACE_Timer_Heap_T::heap_<code> [private]</code>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Current contents of the Heap, which is organized as a "heap" of &lt;ACE_Timer_Node&gt; *'s. In this context, a heap is a "partially ordered, almost complete" binary tree, which is stored in an array.     </td>
  </tr>
</table>
<a name="o3" doxytag="ACE_Timer_Heap_T::iterator_"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class TYPE, class FUNCTOR, class ACE_LOCK&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="classACE__Timer__Heap__T.html#s0">HEAP_ITERATOR</a>* ACE_Timer_Heap_T::iterator_<code> [private]</code>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Iterator used to expire timers.
<p>
    </td>
  </tr>
</table>
<a name="o0" doxytag="ACE_Timer_Heap_T::max_size_"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class TYPE, class FUNCTOR, class ACE_LOCK&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> size_t ACE_Timer_Heap_T::max_size_<code> [private]</code>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Maximum size of the heap.
<p>
    </td>
  </tr>
</table>
<a name="o10" doxytag="ACE_Timer_Heap_T::preallocated_node_set_"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class TYPE, class FUNCTOR, class ACE_LOCK&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="classACE__Unbounded__Set.html">ACE_Unbounded_Set</a>&lt;<a class="el" href="classACE__Timer__Node__T.html">ACE_Timer_Node_T</a>&lt;TYPE&gt; *&gt; ACE_Timer_Heap_T::preallocated_node_set_<code> [private]</code>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Set of pointers to the arrays of preallocated timer nodes. Used to delete the allocated memory when required.
<p>
    </td>
  </tr>
</table>
<a name="o8" doxytag="ACE_Timer_Heap_T::preallocated_nodes_"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class TYPE, class FUNCTOR, class ACE_LOCK&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="classACE__Timer__Node__T.html">ACE_Timer_Node_T</a>&lt;TYPE&gt;* ACE_Timer_Heap_T::preallocated_nodes_<code> [private]</code>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
If this is non-0, then we preallocate &lt;max_size_&gt; number of &lt;ACE_Timer_Node&gt; objects in order to reduce dynamic allocation costs. In auto-growing implementation, this points to the last array of nodes allocated.     </td>
  </tr>
</table>
<a name="o9" doxytag="ACE_Timer_Heap_T::preallocated_nodes_freelist_"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class TYPE, class FUNCTOR, class ACE_LOCK&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="classACE__Timer__Node__T.html">ACE_Timer_Node_T</a>&lt;TYPE&gt;* ACE_Timer_Heap_T::preallocated_nodes_freelist_<code> [private]</code>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This points to the head of the &lt;preallocated_nodes_&gt; freelist, which is organized as a stack.
<p>
    </td>
  </tr>
</table>
<a name="o5" doxytag="ACE_Timer_Heap_T::timer_ids_"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class TYPE, class FUNCTOR, class ACE_LOCK&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="Basic__Types_8h.html#a38">ssize_t</a>* ACE_Timer_Heap_T::timer_ids_<code> [private]</code>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
An array of "pointers" that allows each &lt;ACE_Timer_Node&gt; in the &lt;heap_&gt; to be located in O(1) time. Basically, &lt;timer_id_[i]&gt; contains the slot in the &lt;heap_&gt; array where an &lt;ACE_Timer_Node&gt; * with timer id &lt;i&gt; resides. Thus, the timer id passed back from &lt;schedule&gt; is really a slot into the &lt;timer_ids&gt; array. The &lt;timer_ids_&gt; array serves two purposes: negative values are indications of free timer IDs, whereas positive values are "pointers" into the &lt;heap_&gt; array for assigned timer IDs.     </td>
  </tr>
</table>
<a name="o6" doxytag="ACE_Timer_Heap_T::timer_ids_curr_"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class TYPE, class FUNCTOR, class ACE_LOCK&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> size_t ACE_Timer_Heap_T::timer_ids_curr_<code> [private]</code>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
"Pointer" to the element in the &lt;timer_ids_&gt; array that was last given out as a timer ID.
<p>
    </td>
  </tr>
</table>
<a name="o7" doxytag="ACE_Timer_Heap_T::timer_ids_min_free_"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class TYPE, class FUNCTOR, class ACE_LOCK&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> size_t ACE_Timer_Heap_T::timer_ids_min_free_<code> [private]</code>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Index representing the lowest timer ID that has been freed. When the timer_ids_next_ value wraps around, it starts back at this point.
<p>
    </td>
  </tr>
</table>
<hr>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="Timer__Heap__T_8h.html">Timer_Heap_T.h</a><li><a class="el" href="Timer__Heap__T_8cpp.html">Timer_Heap_T.cpp</a></ul>
<hr><address><small>Generated on Wed Jan 15 19:15:12 2003 for ACE by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.gif" alt="doxygen" align="middle" border=0 
width=110 height=53></a>1.2.13.1 written by <a href="mailto:dimitri@stack.nl">Dimitri van Heesch</a>,
 &copy;&nbsp;1997-2001</small></address>
</body>
</html>
