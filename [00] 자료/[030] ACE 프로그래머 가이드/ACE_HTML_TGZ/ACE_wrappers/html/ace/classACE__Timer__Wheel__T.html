<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title> TemplateACE_Timer_Wheel_T class Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body bgcolor="#ffffff">
<!-- Generated by Doxygen 1.2.13.1 -->
<center>
<a class="qindex" href="index.html">Main Page</a> &nbsp; <a class="qindex" href="hierarchy.html">Class Hierarchy</a> &nbsp; <a class="qindex" href="classes.html">Alphabetical List</a> &nbsp; <a class="qindex" href="annotated.html">Compound List</a> &nbsp; <a class="qindex" href="files.html">File List</a> &nbsp; <a class="qindex" href="functions.html">Compound Members</a> &nbsp; <a class="qindex" href="globals.html">File Members</a> &nbsp; <a class="qindex" href="pages.html">Related Pages</a> &nbsp; </center>
<hr><h1>ACE_Timer_Wheel_T  Class Template Reference</h1>Provides a Timing Wheel version of ACE_Timer_Queue. 
<a href="#_details">More...</a>
<p>
<code>#include &lt;Timer_Wheel_T.h&gt;</code>
<p>
Inheritance diagram for ACE_Timer_Wheel_T:<p><center><img src="classACE__Timer__Wheel__T__inherit__graph.gif" border="0" usemap="#ACE__Timer__Wheel__T_3_01TYPE_00_01FUNCTOR_00_01ACE__LOCK_01_4__inherit__map" alt="Inheritance graph"></center>
<map name="ACE__Timer__Wheel__T_3_01TYPE_00_01FUNCTOR_00_01ACE__LOCK_01_4__inherit__map">
<area href="classACE__Timer__Queue__T.html" shape="rect" coords="14,15,366,34" alt="">
</map>
<center><font size="2">[<a href="graph_legend.html">legend</a>]</font></center>Collaboration diagram for ACE_Timer_Wheel_T:<p><center><img src="classACE__Timer__Wheel__T__coll__graph.gif" border="0" usemap="#ACE__Timer__Wheel__T_3_01TYPE_00_01FUNCTOR_00_01ACE__LOCK_01_4__coll__map" alt="Collaboration graph"></center>
<map name="ACE__Timer__Wheel__T_3_01TYPE_00_01FUNCTOR_00_01ACE__LOCK_01_4__coll__map">
<area href="classACE__Timer__Wheel__Iterator__T.html" shape="rect" coords="1233,124,1627,143" alt="">
<area href="classACE__Timer__Queue__T.html" shape="rect" coords="283,76,635,95" alt="">
<area href="classACE__Time__Value.html" shape="rect" coords="26,100,141,119" alt="">
<area href="classACE__Timer__Node__T.html" shape="rect" coords="363,183,555,202" alt="">
</map>
<center><font size="2">[<a href="graph_legend.html">legend</a>]</font></center><a href="classACE__Timer__Wheel__T-members.html">List of all members.</a><table border=0 cellpadding=0 cellspacing=0>
<tr><td colspan=2><br><h2>Public Types</h2></td></tr>
<tr><td nowrap align=right valign=top>typedef <a class="el" href="classACE__Timer__Wheel__Iterator__T.html">ACE_Timer_Wheel_Iterator_T</a>&lt;<br>
 TYPE, FUNCTOR, ACE_LOCK &gt;&nbsp;</td><td valign=bottom><a class="el" href="classACE__Timer__Wheel__T.html#s0">Iterator</a></td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Type of iterator.</em> <a href="#s0">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>typedef <a class="el" href="classACE__Timer__Node__T.html">ACE_Timer_Node_T</a>&lt;<br>
 TYPE &gt;&nbsp;</td><td valign=bottom><a class="el" href="classACE__Timer__Wheel__T.html#s1">Node</a></td></tr>
<tr><td nowrap align=right valign=top>typedef <a class="el" href="classACE__Timer__Queue__T.html">ACE_Timer_Queue_T</a>&lt;<br>
 TYPE, FUNCTOR, ACE_LOCK &gt;&nbsp;</td><td valign=bottom><a class="el" href="classACE__Timer__Wheel__T.html#s2">Base</a></td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Type inherited from.</em> <a href="#s2">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>typedef <a class="el" href="classACE__Free__List.html">ACE_Free_List</a>&lt; <a class="el" href="classACE__Timer__Wheel__T.html#s1">Node</a> &gt;&nbsp;</td><td valign=bottom><a class="el" href="classACE__Timer__Wheel__T.html#s3">FreeList</a></td></tr>
<tr><td colspan=2><br><h2>Public Methods</h2></td></tr>
<tr><td nowrap align=right valign=top>&nbsp;</td><td valign=bottom><a class="el" href="classACE__Timer__Wheel__T.html#a0">ACE_Timer_Wheel_T</a> (FUNCTOR *upcall_functor=0, <a class="el" href="classACE__Timer__Wheel__T.html#s3">FreeList</a> *freelist=0)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Default constructor.</em> <a href="#a0">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>&nbsp;</td><td valign=bottom><a class="el" href="classACE__Timer__Wheel__T.html#a1">ACE_Timer_Wheel_T</a> (u_int spoke_count, u_int resolution, size_t prealloc=0, FUNCTOR *upcall_functor=0, <a class="el" href="classACE__Timer__Wheel__T.html#s3">FreeList</a> *freelist=0)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Constructor with opportunities to set the wheelsize and resolution.</em> <a href="#a1">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>virtual&nbsp;</td><td valign=bottom><a class="el" href="classACE__Timer__Wheel__T.html#a2">~ACE_Timer_Wheel_T</a> (void)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Destructor.</em> <a href="#a2">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>virtual int&nbsp;</td><td valign=bottom><a class="el" href="classACE__Timer__Wheel__T.html#a3">is_empty</a> (void) const</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>True if queue is empty, else false.</em> <a href="#a3">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>virtual const <a class="el" href="classACE__Time__Value.html">ACE_Time_Value</a> &amp;&nbsp;</td><td valign=bottom><a class="el" href="classACE__Timer__Wheel__T.html#a4">earliest_time</a> (void) const</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Returns the time of the earlier node in the &lt;ACE_Timer_Wheel&gt;. Must be called on a non-empty queue.</em> <a href="#a4">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>virtual long&nbsp;</td><td valign=bottom><a class="el" href="classACE__Timer__Wheel__T.html#a5">schedule</a> (const TYPE &amp;type, const void *act, const <a class="el" href="classACE__Time__Value.html">ACE_Time_Value</a> &amp;future_time, const <a class="el" href="classACE__Time__Value.html">ACE_Time_Value</a> &amp;interval=<a class="el" href="classACE__Time__Value.html#p0">ACE_Time_Value::zero</a>)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Schedules a timer.</em> <a href="#a5">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>virtual int&nbsp;</td><td valign=bottom><a class="el" href="classACE__Timer__Wheel__T.html#a6">reset_interval</a> (long timer_id, const <a class="el" href="classACE__Time__Value.html">ACE_Time_Value</a> &amp;interval)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Changes the interval of a timer (and can make it periodic or non periodic by setting it to <a class="el" href="classACE__Time__Value.html#p0">ACE_Time_Value::zero</a> or not).</em> <a href="#a6">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>virtual int&nbsp;</td><td valign=bottom><a class="el" href="classACE__Timer__Wheel__T.html#a7">cancel</a> (const TYPE &amp;type, int dont_call_handle_close=1)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Cancel all timer associated with &lt;type&gt;. If &lt;dont_call&gt; is 0 then the &lt;functor&gt; will be invoked. Returns number of timers cancelled.</em> <a href="#a7">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>virtual int&nbsp;</td><td valign=bottom><a class="el" href="classACE__Timer__Wheel__T.html#a8">cancel</a> (long timer_id, const void **act=0, int dont_call_handle_close=1)</td></tr>
<tr><td nowrap align=right valign=top>virtual int&nbsp;</td><td valign=bottom><a class="el" href="classACE__Timer__Wheel__T.html#a9">expire</a> (void)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Run the &lt;functor&gt; for all timers whose values are &lt;= &lt;<a class="el" href="classACE__OS.html#z32_5">ACE_OS::gettimeofday</a>&gt;. Also accounts for &lt;timer_skew&gt;. Returns the number of timers canceled.</em> <a href="#a9">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>int&nbsp;</td><td valign=bottom><a class="el" href="classACE__Timer__Wheel__T.html#a10">expire</a> (const <a class="el" href="classACE__Time__Value.html">ACE_Time_Value</a> &amp;)</td></tr>
<tr><td nowrap align=right valign=top>virtual <a class="el" href="classACE__Timer__Queue__Iterator__T.html">ACE_Timer_Queue_Iterator_T</a>&lt;<br>
 TYPE, FUNCTOR, ACE_LOCK &gt; &amp;&nbsp;</td><td valign=bottom><a class="el" href="classACE__Timer__Wheel__T.html#a11">iter</a> (void)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Returns a pointer to this &lt;<a class="el" href="classACE__Timer__Queue__T.html">ACE_Timer_Queue_T</a>&gt;'s iterator.</em> <a href="#a11">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>virtual <a class="el" href="classACE__Timer__Node__T.html">ACE_Timer_Node_T</a>&lt;<br>
 TYPE &gt; *&nbsp;</td><td valign=bottom><a class="el" href="classACE__Timer__Wheel__T.html#a12">remove_first</a> (void)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Removes the earliest node from the queue and returns it.</em> <a href="#a12">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>virtual void&nbsp;</td><td valign=bottom><a class="el" href="classACE__Timer__Wheel__T.html#a13">dump</a> (void) const</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Dump the state of an object.</em> <a href="#a13">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>virtual <a class="el" href="classACE__Timer__Node__T.html">ACE_Timer_Node_T</a>&lt;<br>
 TYPE &gt; *&nbsp;</td><td valign=bottom><a class="el" href="classACE__Timer__Wheel__T.html#a14">get_first</a> (void)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Reads the earliest node from the queue and returns it.</em> <a href="#a14">More...</a><em></em></font><br><br></td></tr>
<tr><td colspan=2><br><h2>Private Methods</h2></td></tr>
<tr><td nowrap align=right valign=top><a class="el" href="classACE__Timer__Node__T.html">ACE_Timer_Node_T</a>&lt; TYPE &gt; *&nbsp;</td><td valign=bottom><a class="el" href="classACE__Timer__Wheel__T.html#c0">get_first_i</a> (void) const</td></tr>
<tr><td nowrap align=right valign=top><a class="el" href="classACE__Timer__Node__T.html">ACE_Timer_Node_T</a>&lt; TYPE &gt; *&nbsp;</td><td valign=bottom><a class="el" href="classACE__Timer__Wheel__T.html#c1">remove_first_expired</a> (const <a class="el" href="classACE__Time__Value.html">ACE_Time_Value</a> &amp;now)</td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classACE__Timer__Wheel__T.html#c2">open_i</a> (size_t prealloc, u_int spokes, u_int res)</td></tr>
<tr><td nowrap align=right valign=top>virtual void&nbsp;</td><td valign=bottom><a class="el" href="classACE__Timer__Wheel__T.html#c3">reschedule</a> (<a class="el" href="classACE__Timer__Node__T.html">ACE_Timer_Node_T</a>&lt; TYPE &gt; *)</td></tr>
<tr><td nowrap align=right valign=top><a class="el" href="classACE__Timer__Node__T.html">ACE_Timer_Node_T</a>&lt; TYPE &gt; *&nbsp;</td><td valign=bottom><a class="el" href="classACE__Timer__Wheel__T.html#c4">find_spoke_node</a> (u_int spoke, long timer_id) const</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Searches for a node by timer_id within one spoke.</em> <a href="#c4">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top><a class="el" href="classACE__Timer__Node__T.html">ACE_Timer_Node_T</a>&lt; TYPE &gt; *&nbsp;</td><td valign=bottom><a class="el" href="classACE__Timer__Wheel__T.html#c5">find_node</a> (long timer_id) const</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Searches all spokes for a node matching the specified timer_id Uses the spoke encoded in the timer_id as a starting place.</em> <a href="#c5">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>u_int&nbsp;</td><td valign=bottom><a class="el" href="classACE__Timer__Wheel__T.html#c6">calculate_spoke</a> (const <a class="el" href="classACE__Time__Value.html">ACE_Time_Value</a> &amp;expire) const</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Uses a simple hash to find which spoke to use based on when the timer is due to expire. Hopefully the 64bit int operations avoid any overflow problems.</em> <a href="#c6">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>long&nbsp;</td><td valign=bottom><a class="el" href="classACE__Timer__Wheel__T.html#c7">generate_timer_id</a> (u_int spoke)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Generates a unique timer_id for the given spoke. It should be pretty fast until the point where the counter overflows. At that time you have to do exhaustive searches within the spoke to ensure that a particular timer id is not already in use. Some optimizations are in place so that this hopefully doesn't have to happen often.</em> <a href="#c7">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classACE__Timer__Wheel__T.html#c8">schedule_i</a> (<a class="el" href="classACE__Timer__Node__T.html">ACE_Timer_Node_T</a>&lt; TYPE &gt; *n, u_int spoke, const <a class="el" href="classACE__Time__Value.html">ACE_Time_Value</a> &amp;expire)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>The shared scheduling functionality between <a class="el" href="classACE__Timer__Wheel__T.html#a5">schedule</a>() and <a class="el" href="classACE__Timer__Wheel__T.html#c3">reschedule</a>().</em> <a href="#c8">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classACE__Timer__Wheel__T.html#c9">cancel_i</a> (<a class="el" href="classACE__Timer__Node__T.html">ACE_Timer_Node_T</a>&lt; TYPE &gt; *n, int skip_close)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Shared subset of the two <a class="el" href="classACE__Timer__Wheel__T.html#a7">cancel</a>() methods.</em> <a href="#c9">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classACE__Timer__Wheel__T.html#c10">unlink</a> (<a class="el" href="classACE__Timer__Node__T.html">ACE_Timer_Node_T</a>&lt; TYPE &gt; *n)</td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classACE__Timer__Wheel__T.html#c11">recalc_earliest</a> (const <a class="el" href="classACE__Time__Value.html">ACE_Time_Value</a> &amp;last)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>There are a few places where we have to figure out which timer will expire next. This method makes the assumption that spokes are always sorted, and that timers are always in the correct spoke determined from their expiration time. The last time is always passed in, even though you can often calculate it as <a class="el" href="classACE__Timer__Wheel__T.html#a14">get_first</a>()-&gt;get_timer_value().</em> <a href="#c11">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>&nbsp;</td><td valign=bottom><a class="el" href="classACE__Timer__Wheel__T.html#c12">ACE_Timer_Wheel_T</a> (const ACE_Timer_Wheel_T&lt; TYPE, FUNCTOR, ACE_LOCK &gt; &amp;)</td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classACE__Timer__Wheel__T.html#c13">operator=</a> (const ACE_Timer_Wheel_T&lt; TYPE, FUNCTOR, ACE_LOCK &gt; &amp;)</td></tr>
<tr><td colspan=2><br><h2>Private Attributes</h2></td></tr>
<tr><td nowrap align=right valign=top><a class="el" href="classACE__Timer__Node__T.html">ACE_Timer_Node_T</a>&lt; TYPE &gt; **&nbsp;</td><td valign=bottom><a class="el" href="classACE__Timer__Wheel__T.html#o0">spokes_</a></td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Timing Wheel.</em> <a href="#o0">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>u_int&nbsp;</td><td valign=bottom><a class="el" href="classACE__Timer__Wheel__T.html#o1">spoke_count_</a></td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Size of the timing wheel.</em> <a href="#o1">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>int&nbsp;</td><td valign=bottom><a class="el" href="classACE__Timer__Wheel__T.html#o2">spoke_bits_</a></td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Number of timer_id bits used for the spoke.</em> <a href="#o2">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>u_int&nbsp;</td><td valign=bottom><a class="el" href="classACE__Timer__Wheel__T.html#o3">max_per_spoke_</a></td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Maximum number of timers per spoke.</em> <a href="#o3">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>int&nbsp;</td><td valign=bottom><a class="el" href="classACE__Timer__Wheel__T.html#o4">res_bits_</a></td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Resolution (in microsoconds) of the timing wheel.</em> <a href="#o4">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>u_int&nbsp;</td><td valign=bottom><a class="el" href="classACE__Timer__Wheel__T.html#o5">earliest_spoke_</a></td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Index of the list with the earliest time.</em> <a href="#o5">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top><a class="el" href="classACE__Timer__Wheel__T.html#s0">Iterator</a> *&nbsp;</td><td valign=bottom><a class="el" href="classACE__Timer__Wheel__T.html#o6">iterator_</a></td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Iterator used to expire timers.</em> <a href="#o6">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top><a class="el" href="classACE__Time__Value.html">ACE_Time_Value</a>&nbsp;</td><td valign=bottom><a class="el" href="classACE__Timer__Wheel__T.html#o7">wheel_time_</a></td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>The total amount of time in one iteration of the wheel. (resolution * spoke_count).</em> <a href="#o7">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>u_int&nbsp;</td><td valign=bottom><a class="el" href="classACE__Timer__Wheel__T.html#o8">timer_count_</a></td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>The total number of timers currently scheduled.</em> <a href="#o8">More...</a><em></em></font><br><br></td></tr>
<tr><td colspan=2><br><h2>Friends</h2></td></tr>
<tr><td nowrap align=right valign=top>class&nbsp;</td><td valign=bottom><a class="el" href="classACE__Timer__Wheel__T.html#l0">ACE_Timer_Wheel_Iterator_T&lt; TYPE, FUNCTOR, ACE_LOCK &gt;</a></td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Iterator is a friend.</em> <a href="#l0">More...</a><em></em></font><br><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
<h3>template&lt;class TYPE, class FUNCTOR, class ACE_LOCK&gt;<br>
 class ACE_Timer_Wheel_T&lt; TYPE, FUNCTOR, ACE_LOCK &gt;</h3>

Provides a Timing Wheel version of ACE_Timer_Queue.
<p>

<p>
 This implementation uses a hash table of ordered doubly- linked lists of absolute times. The enhancements over the <code><a class="el" href="Timer__List_8h.html#a0">ACE_Timer_List</a></code> include adding a free list and the ability to preallocate nodes. Timer Wheel is based on the timing wheel implementation used in Adam M. Costello and George Varghese's paper "Redesigning the BSD Callout and Timer Facilities" (<a href="http://dworkin.wustl.edu/~varghese/PAPERS/newbsd.ps.Z">http://dworkin.wustl.edu/~varghese/PAPERS/newbsd.ps.Z</a>) 
<p>
<hr><h2>Member Typedef Documentation</h2>
<a name="s2" doxytag="ACE_Timer_Wheel_T::Base"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class TYPE, class FUNCTOR, class ACE_LOCK&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> typedef <a class="el" href="classACE__Timer__Queue__T.html">ACE_Timer_Queue_T</a>&lt;TYPE, FUNCTOR, ACE_LOCK&gt; ACE_Timer_Wheel_T::Base
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Type inherited from.
<p>
    </td>
  </tr>
</table>
<a name="s3" doxytag="ACE_Timer_Wheel_T::FreeList"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class TYPE, class FUNCTOR, class ACE_LOCK&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> typedef <a class="el" href="classACE__Free__List.html">ACE_Free_List</a>&lt;<a class="el" href="classACE__Timer__Wheel__T.html#s1">Node</a>&gt; ACE_Timer_Wheel_T::FreeList
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a name="s0" doxytag="ACE_Timer_Wheel_T::Iterator"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class TYPE, class FUNCTOR, class ACE_LOCK&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> typedef <a class="el" href="classACE__Timer__Wheel__Iterator__T.html">ACE_Timer_Wheel_Iterator_T</a>&lt;TYPE, FUNCTOR, ACE_LOCK&gt; ACE_Timer_Wheel_T::Iterator
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Type of iterator.
<p>
    </td>
  </tr>
</table>
<a name="s1" doxytag="ACE_Timer_Wheel_T::Node"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class TYPE, class FUNCTOR, class ACE_LOCK&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> typedef <a class="el" href="classACE__Timer__Node__T.html">ACE_Timer_Node_T</a>&lt;TYPE&gt; ACE_Timer_Wheel_T::Node
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a name="a0" doxytag="ACE_Timer_Wheel_T::ACE_Timer_Wheel_T"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class TYPE, class FUNCTOR, class ACE_LOCK&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> ACE_Timer_Wheel_T&lt; TYPE, FUNCTOR, ACE_LOCK &gt;::ACE_Timer_Wheel_T </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">FUNCTOR *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>upcall_functor</em> = 0, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="classACE__Timer__Wheel__T.html#s3">FreeList</a> *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>freelist</em> = 0</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Default constructor.
<p>
Default Constructor that sets defaults for spoke_count_ and resolution_ and doesn't do any preallocation.<dl compact><dt><b>
Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>upcall_functor</em>&nbsp;</td><td>
A pointer to a functor to use instead of the default </td></tr>
<tr><td valign=top><em>freelist</em>&nbsp;</td><td>
A pointer to a freelist to use instead of the default </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<a name="a1" doxytag="ACE_Timer_Wheel_T::ACE_Timer_Wheel_T"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class TYPE, class FUNCTOR, class ACE_LOCK&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> ACE_Timer_Wheel_T&lt; TYPE, FUNCTOR, ACE_LOCK &gt;::ACE_Timer_Wheel_T </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">u_int&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>spoke_count</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>u_int&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>resolution</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>size_t&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>prealloc</em> = 0, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>FUNCTOR *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>upcall_functor</em> = 0, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="classACE__Timer__Wheel__T.html#s3">FreeList</a> *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>freelist</em> = 0</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Constructor with opportunities to set the wheelsize and resolution.
<p>
Constructor that sets up the timing wheel and also may preallocate some nodes on the free list<dl compact><dt><b>
Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>spoke_count</em>&nbsp;</td><td>
The number of lists in the timer wheel </td></tr>
<tr><td valign=top><em>resolution</em>&nbsp;</td><td>
The time resolution in milliseconds used by the hashing function </td></tr>
<tr><td valign=top><em>prealloc</em>&nbsp;</td><td>
The number of entries to prealloc in the free_list </td></tr>
<tr><td valign=top><em>upcall_functor</em>&nbsp;</td><td>
A pointer to a functor to use instead of the default </td></tr>
<tr><td valign=top><em>freelist</em>&nbsp;</td><td>
A pointer to a freelist to use instead of the default </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<a name="a2" doxytag="ACE_Timer_Wheel_T::~ACE_Timer_Wheel_T"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class TYPE, class FUNCTOR, class ACE_LOCK&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> ACE_Timer_Wheel_T&lt; TYPE, FUNCTOR, ACE_LOCK &gt;::~ACE_Timer_Wheel_T </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Destructor.
<p>
    </td>
  </tr>
</table>
<a name="c12" doxytag="ACE_Timer_Wheel_T::ACE_Timer_Wheel_T"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class TYPE, class FUNCTOR, class ACE_LOCK&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> ACE_Timer_Wheel_T&lt; TYPE, FUNCTOR, ACE_LOCK &gt;::ACE_Timer_Wheel_T </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const ACE_Timer_Wheel_T&lt; TYPE, FUNCTOR, ACE_LOCK &gt; &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [private]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<hr><h2>Member Function Documentation</h2>
<a name="c6" doxytag="ACE_Timer_Wheel_T::calculate_spoke"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class TYPE, class FUNCTOR, class ACE_LOCK&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> u_int ACE_Timer_Wheel_T&lt; TYPE, FUNCTOR, ACE_LOCK &gt;::calculate_spoke </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classACE__Time__Value.html">ACE_Time_Value</a> &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>t</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap> const<code> [private]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Uses a simple hash to find which spoke to use based on when the timer is due to expire. Hopefully the 64bit int operations avoid any overflow problems.
<p>
    </td>
  </tr>
</table>
<a name="a8" doxytag="ACE_Timer_Wheel_T::cancel"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class TYPE, class FUNCTOR, class ACE_LOCK&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> int ACE_Timer_Wheel_T&lt; TYPE, FUNCTOR, ACE_LOCK &gt;::cancel </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">long&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>timer_id</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const void **&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>act</em> = 0, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>skip_close</em> = 1</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Cancels the single timer that is specified by the timer_id. In this case the timer_id is actually a pointer to the node, so we cast it to the node. This can be dangerous if the timer_id is made up (or deleted twice) so we do a little sanity check. Finally we update the earliest time in case the earliest timer was removed.<dl compact><dt><b>
Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>timer_id</em>&nbsp;</td><td>
Timer Identifier </td></tr>
<tr><td valign=top><em>act</em>&nbsp;</td><td>
Asychronous Completion Token (AKA magic cookie): If this is non-zero, stores the magic cookie of the cancelled timer here. </td></tr>
<tr><td valign=top><em>skip_close</em>&nbsp;</td><td>
If this non-zero, the cancellation method of the functor will not be called.</td></tr>
</table>
</dl><dl compact><dt><b>
Returns: </b><dd>
1 for sucess and 0 if the timer_id wasn't found (or was found to be invalid) </dl>
<p>
Reimplemented from <a class="el" href="classACE__Timer__Queue__T.html#a7">ACE_Timer_Queue_T</a>.    </td>
  </tr>
</table>
<a name="a7" doxytag="ACE_Timer_Wheel_T::cancel"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class TYPE, class FUNCTOR, class ACE_LOCK&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> int ACE_Timer_Wheel_T&lt; TYPE, FUNCTOR, ACE_LOCK &gt;::cancel </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const TYPE &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>type</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>skip_close</em> = 1</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Cancel all timer associated with &lt;type&gt;. If &lt;dont_call&gt; is 0 then the &lt;functor&gt; will be invoked. Returns number of timers cancelled.
<p>
Goes through every list in the wheel and whenever we find one with the correct type value, we remove it and continue. At the end make sure we reset the earliest time value in case the earliest timers were removed.<dl compact><dt><b>
Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>type</em>&nbsp;</td><td>
The value to search for. </td></tr>
<tr><td valign=top><em>skip_close</em>&nbsp;</td><td>
If this non-zero, the cancellation method of the functor will not be called for each cancelled timer.</td></tr>
</table>
</dl><dl compact><dt><b>
Returns: </b><dd>
Number of timers cancelled </dl>
<p>
Reimplemented from <a class="el" href="classACE__Timer__Queue__T.html#a6">ACE_Timer_Queue_T</a>.    </td>
  </tr>
</table>
<a name="c9" doxytag="ACE_Timer_Wheel_T::cancel_i"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class TYPE, class FUNCTOR, class ACE_LOCK&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> void ACE_Timer_Wheel_T&lt; TYPE, FUNCTOR, ACE_LOCK &gt;::cancel_i </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classACE__Timer__Node__T.html">ACE_Timer_Node_T</a>&lt; TYPE &gt; *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>n</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>skip_close</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [private]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Shared subset of the two <a class="el" href="classACE__Timer__Wheel__T.html#a7">cancel</a>() methods.
<p>
    </td>
  </tr>
</table>
<a name="a13" doxytag="ACE_Timer_Wheel_T::dump"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class TYPE, class FUNCTOR, class ACE_LOCK&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> void ACE_Timer_Wheel_T&lt; TYPE, FUNCTOR, ACE_LOCK &gt;::dump </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap> const<code> [virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Dump the state of an object.
<p>
Dumps out the size of the wheel, the resolution, and the contents of the wheel. 
<p>
Reimplemented from <a class="el" href="classACE__Timer__Queue__T.html#a21">ACE_Timer_Queue_T</a>.    </td>
  </tr>
</table>
<a name="a4" doxytag="ACE_Timer_Wheel_T::earliest_time"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class TYPE, class FUNCTOR, class ACE_LOCK&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> const <a class="el" href="classACE__Time__Value.html">ACE_Time_Value</a> &amp; ACE_Timer_Wheel_T&lt; TYPE, FUNCTOR, ACE_LOCK &gt;::earliest_time </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap> const<code> [virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns the time of the earlier node in the &lt;ACE_Timer_Wheel&gt;. Must be called on a non-empty queue.
<p>
<dl compact><dt><b>
Returns: </b><dd>
First (earliest) node in the wheel_'s earliest_spoke_ list </dl>
<p>
Reimplemented from <a class="el" href="classACE__Timer__Queue__T.html#a3">ACE_Timer_Queue_T</a>.    </td>
  </tr>
</table>
<a name="a10" doxytag="ACE_Timer_Wheel_T::expire"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class TYPE, class FUNCTOR, class ACE_LOCK&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> int ACE_Timer_Wheel_T&lt; TYPE, FUNCTOR, ACE_LOCK &gt;::expire </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classACE__Time__Value.html">ACE_Time_Value</a> &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>cur_time</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This is a specialized version of expire that is more suited for the internal data representation.<dl compact><dt><b>
Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>cur_time</em>&nbsp;</td><td>
The time to expire timers up to.</td></tr>
</table>
</dl><dl compact><dt><b>
Returns: </b><dd>
Number of timers expired </dl>
<p>
Reimplemented from <a class="el" href="classACE__Timer__Queue__T.html#a8">ACE_Timer_Queue_T</a>.    </td>
  </tr>
</table>
<a name="a9" doxytag="ACE_Timer_Wheel_T::expire"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class TYPE, class FUNCTOR, class ACE_LOCK&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> int ACE_Timer_Wheel_T&lt; TYPE, FUNCTOR, ACE_LOCK &gt;::expire </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Run the &lt;functor&gt; for all timers whose values are &lt;= &lt;<a class="el" href="classACE__OS.html#z32_5">ACE_OS::gettimeofday</a>&gt;. Also accounts for &lt;timer_skew&gt;. Returns the number of timers canceled.
<p>
Dummy version of expire to get rid of warnings in Sun CC 4.2 Just call the expire of the base class. 
<p>
Reimplemented from <a class="el" href="classACE__Timer__Queue__T.html#a10">ACE_Timer_Queue_T</a>.    </td>
  </tr>
</table>
<a name="c5" doxytag="ACE_Timer_Wheel_T::find_node"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class TYPE, class FUNCTOR, class ACE_LOCK&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="classACE__Timer__Node__T.html">ACE_Timer_Node_T</a>&lt; TYPE &gt; * ACE_Timer_Wheel_T&lt; TYPE, FUNCTOR, ACE_LOCK &gt;::find_node </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">long&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>timer_id</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap> const<code> [private]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Searches all spokes for a node matching the specified timer_id Uses the spoke encoded in the timer_id as a starting place.
<p>
    </td>
  </tr>
</table>
<a name="c4" doxytag="ACE_Timer_Wheel_T::find_spoke_node"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class TYPE, class FUNCTOR, class ACE_LOCK&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="classACE__Timer__Node__T.html">ACE_Timer_Node_T</a>&lt; TYPE &gt; * ACE_Timer_Wheel_T&lt; TYPE, FUNCTOR, ACE_LOCK &gt;::find_spoke_node </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">u_int&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>spoke</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>long&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>timer_id</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"> const<code> [private]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Searches for a node by timer_id within one spoke.
<p>
    </td>
  </tr>
</table>
<a name="c7" doxytag="ACE_Timer_Wheel_T::generate_timer_id"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class TYPE, class FUNCTOR, class ACE_LOCK&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> long ACE_Timer_Wheel_T&lt; TYPE, FUNCTOR, ACE_LOCK &gt;::generate_timer_id </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">u_int&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>spoke</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [private]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Generates a unique timer_id for the given spoke. It should be pretty fast until the point where the counter overflows. At that time you have to do exhaustive searches within the spoke to ensure that a particular timer id is not already in use. Some optimizations are in place so that this hopefully doesn't have to happen often.
<p>
    </td>
  </tr>
</table>
<a name="a14" doxytag="ACE_Timer_Wheel_T::get_first"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class TYPE, class FUNCTOR, class ACE_LOCK&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="classACE__Timer__Node__T.html">ACE_Timer_Node_T</a>&lt; TYPE &gt; * ACE_Timer_Wheel_T&lt; TYPE, FUNCTOR, ACE_LOCK &gt;::get_first </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Reads the earliest node from the queue and returns it.
<p>
Returns the earliest node without removing it
<p>
<dl compact><dt><b>
Returns: </b><dd>
The earliest timer node. </dl>
<p>
Reimplemented from <a class="el" href="classACE__Timer__Queue__T.html#a22">ACE_Timer_Queue_T</a>.    </td>
  </tr>
</table>
<a name="c0" doxytag="ACE_Timer_Wheel_T::get_first_i"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class TYPE, class FUNCTOR, class ACE_LOCK&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="classACE__Timer__Node__T.html">ACE_Timer_Node_T</a>&lt; TYPE &gt; * ACE_Timer_Wheel_T&lt; TYPE, FUNCTOR, ACE_LOCK &gt;::get_first_i </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap> const<code> [private]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a name="a3" doxytag="ACE_Timer_Wheel_T::is_empty"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class TYPE, class FUNCTOR, class ACE_LOCK&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> int ACE_Timer_Wheel_T&lt; TYPE, FUNCTOR, ACE_LOCK &gt;::is_empty </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap> const<code> [virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
True if queue is empty, else false.
<p>
Check to see if the wheel is empty
<p>
<dl compact><dt><b>
Returns: </b><dd>
True if empty </dl>
<p>
Reimplemented from <a class="el" href="classACE__Timer__Queue__T.html#a2">ACE_Timer_Queue_T</a>.    </td>
  </tr>
</table>
<a name="a11" doxytag="ACE_Timer_Wheel_T::iter"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class TYPE, class FUNCTOR, class ACE_LOCK&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="classACE__Timer__Queue__Iterator__T.html">ACE_Timer_Queue_Iterator_T</a>&lt; TYPE, FUNCTOR, ACE_LOCK &gt; &amp; ACE_Timer_Wheel_T&lt; TYPE, FUNCTOR, ACE_LOCK &gt;::iter </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns a pointer to this &lt;<a class="el" href="classACE__Timer__Queue__T.html">ACE_Timer_Queue_T</a>&gt;'s iterator.
<p>
<dl compact><dt><b>
Returns: </b><dd>
The iterator </dl>
<p>
Reimplemented from <a class="el" href="classACE__Timer__Queue__T.html#a19">ACE_Timer_Queue_T</a>.    </td>
  </tr>
</table>
<a name="c2" doxytag="ACE_Timer_Wheel_T::open_i"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class TYPE, class FUNCTOR, class ACE_LOCK&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> void ACE_Timer_Wheel_T&lt; TYPE, FUNCTOR, ACE_LOCK &gt;::open_i </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">size_t&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>prealloc</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>u_int&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>spokes</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>u_int&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>res</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [private]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Initialize the queue. Uses the established members for all needed information.     </td>
  </tr>
</table>
<a name="c13" doxytag="ACE_Timer_Wheel_T::operator="></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class TYPE, class FUNCTOR, class ACE_LOCK&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> void ACE_Timer_Wheel_T&lt; TYPE, FUNCTOR, ACE_LOCK &gt;::operator= </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const ACE_Timer_Wheel_T&lt; TYPE, FUNCTOR, ACE_LOCK &gt; &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [private]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a name="c11" doxytag="ACE_Timer_Wheel_T::recalc_earliest"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class TYPE, class FUNCTOR, class ACE_LOCK&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> void ACE_Timer_Wheel_T&lt; TYPE, FUNCTOR, ACE_LOCK &gt;::recalc_earliest </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classACE__Time__Value.html">ACE_Time_Value</a> &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>last</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [private]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
There are a few places where we have to figure out which timer will expire next. This method makes the assumption that spokes are always sorted, and that timers are always in the correct spoke determined from their expiration time. The last time is always passed in, even though you can often calculate it as <a class="el" href="classACE__Timer__Wheel__T.html#a14">get_first</a>()-&gt;get_timer_value().
<p>
    </td>
  </tr>
</table>
<a name="a12" doxytag="ACE_Timer_Wheel_T::remove_first"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class TYPE, class FUNCTOR, class ACE_LOCK&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="classACE__Timer__Node__T.html">ACE_Timer_Node_T</a>&lt; TYPE &gt; * ACE_Timer_Wheel_T&lt; TYPE, FUNCTOR, ACE_LOCK &gt;::remove_first </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Removes the earliest node from the queue and returns it.
<p>
Removes the earliest node and then find the new &lt;earliest_spoke_&gt;
<p>
<dl compact><dt><b>
Returns: </b><dd>
The earliest timer node. </dl>
<p>
Reimplemented from <a class="el" href="classACE__Timer__Queue__T.html#a20">ACE_Timer_Queue_T</a>.    </td>
  </tr>
</table>
<a name="c1" doxytag="ACE_Timer_Wheel_T::remove_first_expired"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class TYPE, class FUNCTOR, class ACE_LOCK&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="classACE__Timer__Node__T.html">ACE_Timer_Node_T</a>&lt; TYPE &gt; * ACE_Timer_Wheel_T&lt; TYPE, FUNCTOR, ACE_LOCK &gt;::remove_first_expired </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classACE__Time__Value.html">ACE_Time_Value</a> &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>now</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [private]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a name="c3" doxytag="ACE_Timer_Wheel_T::reschedule"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class TYPE, class FUNCTOR, class ACE_LOCK&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> void ACE_Timer_Wheel_T&lt; TYPE, FUNCTOR, ACE_LOCK &gt;::reschedule </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classACE__Timer__Node__T.html">ACE_Timer_Node_T</a>&lt; TYPE &gt; *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>n</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [private, virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Takes an ACE_Timer_Node and inserts it into the correct position in the correct list. Also makes sure to update the earliest time.<dl compact><dt><b>
Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>n</em>&nbsp;</td><td>
The timer node to reschedule </td></tr>
</table>
</dl>
<p>
Reimplemented from <a class="el" href="classACE__Timer__Queue__T.html#b0">ACE_Timer_Queue_T</a>.    </td>
  </tr>
</table>
<a name="a6" doxytag="ACE_Timer_Wheel_T::reset_interval"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class TYPE, class FUNCTOR, class ACE_LOCK&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> int ACE_Timer_Wheel_T&lt; TYPE, FUNCTOR, ACE_LOCK &gt;::reset_interval </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">long&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>timer_id</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const <a class="el" href="classACE__Time__Value.html">ACE_Time_Value</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>interval</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Changes the interval of a timer (and can make it periodic or non periodic by setting it to <a class="el" href="classACE__Time__Value.html#p0">ACE_Time_Value::zero</a> or not).
<p>
Find the timer node by using the id as a pointer. Then use set_interval() on the node to update the interval.<dl compact><dt><b>
Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>timer_id</em>&nbsp;</td><td>
The timer identifier </td></tr>
<tr><td valign=top><em>interval</em>&nbsp;</td><td>
The new interval</td></tr>
</table>
</dl><dl compact><dt><b>
Returns: </b><dd>
0 if successful, -1 if no. </dl>
<p>
Reimplemented from <a class="el" href="classACE__Timer__Queue__T.html#a5">ACE_Timer_Queue_T</a>.    </td>
  </tr>
</table>
<a name="a5" doxytag="ACE_Timer_Wheel_T::schedule"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class TYPE, class FUNCTOR, class ACE_LOCK&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> long ACE_Timer_Wheel_T&lt; TYPE, FUNCTOR, ACE_LOCK &gt;::schedule </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const TYPE &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>type</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const void *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>act</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const <a class="el" href="classACE__Time__Value.html">ACE_Time_Value</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>future_time</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const <a class="el" href="classACE__Time__Value.html">ACE_Time_Value</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>interval</em> = <a class="el" href="classACE__Time__Value.html#p0">ACE_Time_Value::zero</a></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Schedules a timer.
<p>
Creates a <a class="el" href="classACE__Timer__Node__T.html">ACE_Timer_Node_T</a> based on the input parameters. Then inserts the node into the wheel using reschedule (). Then returns a timer_id.<dl compact><dt><b>
Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>type</em>&nbsp;</td><td>
The data of the timer node </td></tr>
<tr><td valign=top><em>act</em>&nbsp;</td><td>
Asynchronous Completion Token (AKA magic cookie) </td></tr>
<tr><td valign=top><em>future_time</em>&nbsp;</td><td>
The time the timer is scheduled for (absolute time) </td></tr>
<tr><td valign=top><em>interval</em>&nbsp;</td><td>
If not <a class="el" href="classACE__Time__Value.html#p0">ACE_Time_Value::zero</a>, then this is a periodic timer and interval is the time period</td></tr>
</table>
</dl><dl compact><dt><b>
Returns: </b><dd>
Unique identifier (can be used to cancel the timer). -1 on failure. </dl>
<p>
Reimplemented from <a class="el" href="classACE__Timer__Queue__T.html#a4">ACE_Timer_Queue_T</a>.    </td>
  </tr>
</table>
<a name="c8" doxytag="ACE_Timer_Wheel_T::schedule_i"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class TYPE, class FUNCTOR, class ACE_LOCK&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> void ACE_Timer_Wheel_T&lt; TYPE, FUNCTOR, ACE_LOCK &gt;::schedule_i </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classACE__Timer__Node__T.html">ACE_Timer_Node_T</a>&lt; TYPE &gt; *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>n</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>u_int&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>spoke</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const <a class="el" href="classACE__Time__Value.html">ACE_Time_Value</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>expire</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [private]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
The shared scheduling functionality between <a class="el" href="classACE__Timer__Wheel__T.html#a5">schedule</a>() and <a class="el" href="classACE__Timer__Wheel__T.html#c3">reschedule</a>().
<p>
    </td>
  </tr>
</table>
<a name="c10" doxytag="ACE_Timer_Wheel_T::unlink"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class TYPE, class FUNCTOR, class ACE_LOCK&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> void ACE_Timer_Wheel_T&lt; TYPE, FUNCTOR, ACE_LOCK &gt;::unlink </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classACE__Timer__Node__T.html">ACE_Timer_Node_T</a>&lt; TYPE &gt; *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>n</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [private]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<hr><h2>Friends And Related Function Documentation</h2>
<a name="l0" doxytag="ACE_Timer_Wheel_T::ACE_Timer_Wheel_Iterator_T< TYPE, FUNCTOR, ACE_LOCK >"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class TYPE, class FUNCTOR, class ACE_LOCK&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> friend class <a class="el" href="classACE__Timer__Wheel__Iterator__T.html">ACE_Timer_Wheel_Iterator_T</a>&lt; TYPE, FUNCTOR, ACE_LOCK &gt;<code> [friend]</code>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Iterator is a friend.
<p>
    </td>
  </tr>
</table>
<hr><h2>Member Data Documentation</h2>
<a name="o5" doxytag="ACE_Timer_Wheel_T::earliest_spoke_"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class TYPE, class FUNCTOR, class ACE_LOCK&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> u_int ACE_Timer_Wheel_T::earliest_spoke_<code> [private]</code>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Index of the list with the earliest time.
<p>
    </td>
  </tr>
</table>
<a name="o6" doxytag="ACE_Timer_Wheel_T::iterator_"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class TYPE, class FUNCTOR, class ACE_LOCK&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="classACE__Timer__Wheel__T.html#s0">Iterator</a>* ACE_Timer_Wheel_T::iterator_<code> [private]</code>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Iterator used to expire timers.
<p>
    </td>
  </tr>
</table>
<a name="o3" doxytag="ACE_Timer_Wheel_T::max_per_spoke_"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class TYPE, class FUNCTOR, class ACE_LOCK&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> u_int ACE_Timer_Wheel_T::max_per_spoke_<code> [private]</code>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Maximum number of timers per spoke.
<p>
    </td>
  </tr>
</table>
<a name="o4" doxytag="ACE_Timer_Wheel_T::res_bits_"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class TYPE, class FUNCTOR, class ACE_LOCK&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> int ACE_Timer_Wheel_T::res_bits_<code> [private]</code>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Resolution (in microsoconds) of the timing wheel.
<p>
    </td>
  </tr>
</table>
<a name="o2" doxytag="ACE_Timer_Wheel_T::spoke_bits_"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class TYPE, class FUNCTOR, class ACE_LOCK&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> int ACE_Timer_Wheel_T::spoke_bits_<code> [private]</code>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Number of timer_id bits used for the spoke.
<p>
    </td>
  </tr>
</table>
<a name="o1" doxytag="ACE_Timer_Wheel_T::spoke_count_"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class TYPE, class FUNCTOR, class ACE_LOCK&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> u_int ACE_Timer_Wheel_T::spoke_count_<code> [private]</code>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Size of the timing wheel.
<p>
    </td>
  </tr>
</table>
<a name="o0" doxytag="ACE_Timer_Wheel_T::spokes_"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class TYPE, class FUNCTOR, class ACE_LOCK&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="classACE__Timer__Node__T.html">ACE_Timer_Node_T</a>&lt;TYPE&gt;** ACE_Timer_Wheel_T::spokes_<code> [private]</code>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Timing Wheel.
<p>
    </td>
  </tr>
</table>
<a name="o8" doxytag="ACE_Timer_Wheel_T::timer_count_"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class TYPE, class FUNCTOR, class ACE_LOCK&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> u_int ACE_Timer_Wheel_T::timer_count_<code> [private]</code>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
The total number of timers currently scheduled.
<p>
    </td>
  </tr>
</table>
<a name="o7" doxytag="ACE_Timer_Wheel_T::wheel_time_"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class TYPE, class FUNCTOR, class ACE_LOCK&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="classACE__Time__Value.html">ACE_Time_Value</a> ACE_Timer_Wheel_T::wheel_time_<code> [private]</code>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
The total amount of time in one iteration of the wheel. (resolution * spoke_count).
<p>
    </td>
  </tr>
</table>
<hr>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="Timer__Wheel__T_8h.html">Timer_Wheel_T.h</a><li><a class="el" href="Timer__Wheel__T_8cpp.html">Timer_Wheel_T.cpp</a></ul>
<hr><address><small>Generated on Wed Jan 15 19:15:20 2003 for ACE by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.gif" alt="doxygen" align="middle" border=0 
width=110 height=53></a>1.2.13.1 written by <a href="mailto:dimitri@stack.nl">Dimitri van Heesch</a>,
 &copy;&nbsp;1997-2001</small></address>
</body>
</html>
