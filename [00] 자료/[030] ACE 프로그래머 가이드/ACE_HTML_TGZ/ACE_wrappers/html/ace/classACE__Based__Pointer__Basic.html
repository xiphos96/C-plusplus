<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title> TemplateACE_Based_Pointer_Basic class Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body bgcolor="#ffffff">
<!-- Generated by Doxygen 1.2.13.1 -->
<center>
<a class="qindex" href="index.html">Main Page</a> &nbsp; <a class="qindex" href="hierarchy.html">Class Hierarchy</a> &nbsp; <a class="qindex" href="classes.html">Alphabetical List</a> &nbsp; <a class="qindex" href="annotated.html">Compound List</a> &nbsp; <a class="qindex" href="files.html">File List</a> &nbsp; <a class="qindex" href="functions.html">Compound Members</a> &nbsp; <a class="qindex" href="globals.html">File Members</a> &nbsp; <a class="qindex" href="pages.html">Related Pages</a> &nbsp; </center>
<hr><h1>ACE_Based_Pointer_Basic  Class Template Reference</h1>A proxy that keeps track of the relative offset of a "pointer" from its base address. This class makes it possible to transparently use "pointers" in shared memory as easily as programming with pointers to local memory. In particular, we don't need to ensure that the base addresses of all the pointers are mapped into separate processes at the same absolute memory base address. 
<a href="#_details">More...</a>
<p>
<code>#include &lt;Based_Pointer_T.h&gt;</code>
<p>
Inheritance diagram for ACE_Based_Pointer_Basic:<p><center><img src="classACE__Based__Pointer__Basic__inherit__graph.gif" border="0" usemap="#ACE__Based__Pointer__Basic_3_01CONCRETE_01_4__inherit__map" alt="Inheritance graph"></center>
<map name="ACE__Based__Pointer__Basic_3_01CONCRETE_01_4__inherit__map">
<area href="classACE__Based__Pointer.html" shape="rect" coords="566,7,795,26" alt="">
<area href="classACE__Based__Pointer__Basic.html" shape="rect" coords="531,65,830,83" alt="">
<area href="classACE__Based__Pointer__Basic.html" shape="rect" coords="517,133,845,151" alt="">
<area href="classACE__Based__Pointer__Basic.html" shape="rect" coords="571,201,790,219" alt="">
<area href="classACE__Based__Pointer__Basic.html" shape="rect" coords="523,269,838,287" alt="">
</map>
<center><font size="2">[<a href="graph_legend.html">legend</a>]</font></center><a href="classACE__Based__Pointer__Basic-members.html">List of all members.</a><table border=0 cellpadding=0 cellspacing=0>
<tr><td colspan=2><br><h2>Public Methods</h2></td></tr>
<tr><td nowrap align=right valign=top>&nbsp;</td><td valign=bottom><a class="el" href="classACE__Based__Pointer__Basic.html#a0">ACE_Based_Pointer_Basic</a> (void)</td></tr>
<tr><td nowrap align=right valign=top>&nbsp;</td><td valign=bottom><a class="el" href="classACE__Based__Pointer__Basic.html#a1">ACE_Based_Pointer_Basic</a> (CONCRETE *initial)</td></tr>
<tr><td nowrap align=right valign=top>&nbsp;</td><td valign=bottom><a class="el" href="classACE__Based__Pointer__Basic.html#a2">ACE_Based_Pointer_Basic</a> (const ACE_Based_Pointer_Basic&lt; CONCRETE &gt; &amp;)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Copy constructor.</em> <a href="#a2">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>&nbsp;</td><td valign=bottom><a class="el" href="classACE__Based__Pointer__Basic.html#a3">ACE_Based_Pointer_Basic</a> (const void *base_addr, int o)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Constructor for know base address. &lt;o&gt; is only used to resolve overload ambiguity.</em> <a href="#a3">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classACE__Based__Pointer__Basic.html#a4">operator=</a> (CONCRETE *from)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Pseudo-assignment operator.</em> <a href="#a4">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classACE__Based__Pointer__Basic.html#a5">operator=</a> (const ACE_Based_Pointer_Basic&lt; CONCRETE &gt; &amp;)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Pseudo-assignment operator.</em> <a href="#a5">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>CONCRETE&nbsp;</td><td valign=bottom><a class="el" href="classACE__Based__Pointer__Basic.html#a6">operator *</a> (void) const</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Dereference operator.</em> <a href="#a6">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>int&nbsp;</td><td valign=bottom><a class="el" href="classACE__Based__Pointer__Basic.html#a7">operator&lt;</a> (const ACE_Based_Pointer_Basic&lt; CONCRETE &gt; &amp;) const</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Less than operator.</em> <a href="#a7">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>int&nbsp;</td><td valign=bottom><a class="el" href="classACE__Based__Pointer__Basic.html#a8">operator&lt;=</a> (const ACE_Based_Pointer_Basic&lt; CONCRETE &gt; &amp;) const</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Less than or equal operator.</em> <a href="#a8">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>int&nbsp;</td><td valign=bottom><a class="el" href="classACE__Based__Pointer__Basic.html#a9">operator&gt;</a> (const ACE_Based_Pointer_Basic&lt; CONCRETE &gt; &amp;) const</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Greater than operator.</em> <a href="#a9">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>int&nbsp;</td><td valign=bottom><a class="el" href="classACE__Based__Pointer__Basic.html#a10">operator&gt;=</a> (const ACE_Based_Pointer_Basic&lt; CONCRETE &gt; &amp;) const</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Greater than or equal operator.</em> <a href="#a10">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>int&nbsp;</td><td valign=bottom><a class="el" href="classACE__Based__Pointer__Basic.html#a11">operator==</a> (const ACE_Based_Pointer_Basic&lt; CONCRETE &gt; &amp;) const</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Equality operator.</em> <a href="#a11">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>int&nbsp;</td><td valign=bottom><a class="el" href="classACE__Based__Pointer__Basic.html#a12">operator!=</a> (const ACE_Based_Pointer_Basic&lt; CONCRETE &gt; &amp;) const</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Inequality operator.</em> <a href="#a12">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>CONCRETE&nbsp;</td><td valign=bottom><a class="el" href="classACE__Based__Pointer__Basic.html#a13">operator[]</a> (int index) const</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Subscript operator.</em> <a href="#a13">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classACE__Based__Pointer__Basic.html#a14">operator+=</a> (int index)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Increment operator.</em> <a href="#a14">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>&nbsp;</td><td valign=bottom><a class="el" href="classACE__Based__Pointer__Basic.html#a15">operator CONCRETE *</a> () const</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Returns the underlying memory address of the smart pointer.</em> <a href="#a15">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>CONCRETE *&nbsp;</td><td valign=bottom><a class="el" href="classACE__Based__Pointer__Basic.html#a16">addr</a> (void) const</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Returns the underlying memory address of the smart pointer.</em> <a href="#a16">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classACE__Based__Pointer__Basic.html#a17">dump</a> (void) const</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Dump the state of the object.</em> <a href="#a17">More...</a><em></em></font><br><br></td></tr>
<tr><td colspan=2><br><h2>Public Attributes</h2></td></tr>
<tr><td nowrap align=right valign=top>&nbsp;</td><td valign=bottom><a class="el" href="classACE__Based__Pointer__Basic.html#m0">ACE_ALLOC_HOOK_DECLARE</a></td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Declare the dynamic allocation hooks.</em> <a href="#m0">More...</a><em></em></font><br><br></td></tr>
<tr><td colspan=2><br><h2>Protected Attributes</h2></td></tr>
<tr><td nowrap align=right valign=top>long&nbsp;</td><td valign=bottom><a class="el" href="classACE__Based__Pointer__Basic.html#n0">target_</a></td></tr>
<tr><td nowrap align=right valign=top>long&nbsp;</td><td valign=bottom><a class="el" href="classACE__Based__Pointer__Basic.html#n1">base_offset_</a></td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Keep track of our offset from the base pointer.</em> <a href="#n1">More...</a><em></em></font><br><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
<h3>template&lt;class CONCRETE&gt;<br>
 class ACE_Based_Pointer_Basic&lt; CONCRETE &gt;</h3>

A proxy that keeps track of the relative offset of a "pointer" from its base address. This class makes it possible to transparently use "pointers" in shared memory as easily as programming with pointers to local memory. In particular, we don't need to ensure that the base addresses of all the pointers are mapped into separate processes at the same absolute memory base address.
<p>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a name="a0" doxytag="ACE_Based_Pointer_Basic::ACE_Based_Pointer_Basic"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class CONCRETE&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> ACE_Based_Pointer_Basic&lt; CONCRETE &gt;::ACE_Based_Pointer_Basic </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This constructor initializes the &lt;base_offset_&gt; by asking the &lt;ACE_BASED_POINTER_REPOSITORY&gt; Singleton for the base address of the memory region within which it is instantiated. Two results are possible:
<p>
1. An &lt;ACE_*_Memory_Pool&gt; has stored a base address/size pair and the new based-pointer instance is located between the base address and the base address + size - 1. In this case, the repository returns the base address.
<p>
2. No suitable address/size pair was found. The repository assumes an address in the regular (not mapped) virtual address space of the process and returns 0. In this case, the based-pointer uses its address as an offset to it's base address 0.     </td>
  </tr>
</table>
<a name="a1" doxytag="ACE_Based_Pointer_Basic::ACE_Based_Pointer_Basic"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class CONCRETE&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> ACE_Based_Pointer_Basic&lt; CONCRETE &gt;::ACE_Based_Pointer_Basic </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">CONCRETE *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>rhs</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Initialize this object using the &lt;initial&gt; pointer. This constructor initializes the &lt;base_offset_&gt; by asking the &lt;ACE_BASED_POINTER_REPOSITORY&gt; Singleton for the base address of the memory region within which it is instantiated. Three results are possible:
<p>
1. An &lt;ACE_*_Memory_Pool&gt; has stored a base address/size pair and the new based-pointer instance is located between the base address and the base address + size - 1. In this case, the repository returns the base address.
<p>
2. No suitable address/size pair was found. The repository assumes an address in the regular (not mapped) virtual address space of the process and returns 0. In this case, the based-pointer uses its address as an offset to its base address 0.
<p>
3. If &lt;initial&gt; is 0 then set the value of &lt;target_&gt; to -1, which indicates a "NULL" pointer.     </td>
  </tr>
</table>
<a name="a2" doxytag="ACE_Based_Pointer_Basic::ACE_Based_Pointer_Basic"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class CONCRETE&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> ACE_Based_Pointer_Basic&lt; CONCRETE &gt;::ACE_Based_Pointer_Basic </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const ACE_Based_Pointer_Basic&lt; CONCRETE &gt; &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Copy constructor.
<p>
    </td>
  </tr>
</table>
<a name="a3" doxytag="ACE_Based_Pointer_Basic::ACE_Based_Pointer_Basic"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class CONCRETE&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> ACE_Based_Pointer_Basic&lt; CONCRETE &gt;::ACE_Based_Pointer_Basic </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const void *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>base_addr</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>o</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Constructor for know base address. &lt;o&gt; is only used to resolve overload ambiguity.
<p>
    </td>
  </tr>
</table>
<hr><h2>Member Function Documentation</h2>
<a name="a16" doxytag="ACE_Based_Pointer_Basic::addr"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class CONCRETE&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> ACE_INLINE CONCRETE * ACE_Based_Pointer_Basic&lt; CONCRETE &gt;::addr </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap> const</td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns the underlying memory address of the smart pointer.
<p>
    </td>
  </tr>
</table>
<a name="a17" doxytag="ACE_Based_Pointer_Basic::dump"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class CONCRETE&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> void ACE_Based_Pointer_Basic&lt; CONCRETE &gt;::dump </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap> const</td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Dump the state of the object.
<p>
    </td>
  </tr>
</table>
<a name="a6" doxytag="ACE_Based_Pointer_Basic::operator *"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class CONCRETE&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> ACE_INLINE CONCRETE ACE_Based_Pointer_Basic&lt; CONCRETE &gt;::operator * </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap> const</td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Dereference operator.
<p>
    </td>
  </tr>
</table>
<a name="a15" doxytag="ACE_Based_Pointer_Basic::operator CONCRETE *"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class CONCRETE&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> ACE_INLINE ACE_Based_Pointer_Basic&lt; CONCRETE &gt;::operator CONCRETE * </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap> const</td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns the underlying memory address of the smart pointer.
<p>
    </td>
  </tr>
</table>
<a name="a12" doxytag="ACE_Based_Pointer_Basic::operator!="></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class CONCRETE&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> ACE_INLINE int ACE_Based_Pointer_Basic&lt; CONCRETE &gt;::operator!= </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const ACE_Based_Pointer_Basic&lt; CONCRETE &gt; &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>rhs</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap> const</td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Inequality operator.
<p>
    </td>
  </tr>
</table>
<a name="a14" doxytag="ACE_Based_Pointer_Basic::operator+="></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class CONCRETE&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> ACE_INLINE void ACE_Based_Pointer_Basic&lt; CONCRETE &gt;::operator+= </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>index</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Increment operator.
<p>
    </td>
  </tr>
</table>
<a name="a7" doxytag="ACE_Based_Pointer_Basic::operator<"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class CONCRETE&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> ACE_INLINE int ACE_Based_Pointer_Basic&lt; CONCRETE &gt;::operator&lt; </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const ACE_Based_Pointer_Basic&lt; CONCRETE &gt; &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>rhs</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap> const</td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Less than operator.
<p>
    </td>
  </tr>
</table>
<a name="a8" doxytag="ACE_Based_Pointer_Basic::operator<="></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class CONCRETE&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> ACE_INLINE int ACE_Based_Pointer_Basic&lt; CONCRETE &gt;::operator&lt;= </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const ACE_Based_Pointer_Basic&lt; CONCRETE &gt; &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>rhs</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap> const</td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Less than or equal operator.
<p>
    </td>
  </tr>
</table>
<a name="a5" doxytag="ACE_Based_Pointer_Basic::operator="></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class CONCRETE&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> ACE_INLINE void ACE_Based_Pointer_Basic&lt; CONCRETE &gt;::operator= </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const ACE_Based_Pointer_Basic&lt; CONCRETE &gt; &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>rhs</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Pseudo-assignment operator.
<p>
    </td>
  </tr>
</table>
<a name="a4" doxytag="ACE_Based_Pointer_Basic::operator="></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class CONCRETE&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> ACE_INLINE void ACE_Based_Pointer_Basic&lt; CONCRETE &gt;::operator= </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">CONCRETE *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>rhs</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Pseudo-assignment operator.
<p>

<p>
Reimplemented in <a class="el" href="classACE__Based__Pointer.html#a5">ACE_Based_Pointer</a>.    </td>
  </tr>
</table>
<a name="a11" doxytag="ACE_Based_Pointer_Basic::operator=="></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class CONCRETE&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> ACE_INLINE int ACE_Based_Pointer_Basic&lt; CONCRETE &gt;::operator== </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const ACE_Based_Pointer_Basic&lt; CONCRETE &gt; &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>rhs</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap> const</td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Equality operator.
<p>
    </td>
  </tr>
</table>
<a name="a9" doxytag="ACE_Based_Pointer_Basic::operator>"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class CONCRETE&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> ACE_INLINE int ACE_Based_Pointer_Basic&lt; CONCRETE &gt;::operator&gt; </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const ACE_Based_Pointer_Basic&lt; CONCRETE &gt; &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>rhs</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap> const</td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Greater than operator.
<p>
    </td>
  </tr>
</table>
<a name="a10" doxytag="ACE_Based_Pointer_Basic::operator>="></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class CONCRETE&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> ACE_INLINE int ACE_Based_Pointer_Basic&lt; CONCRETE &gt;::operator&gt;= </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const ACE_Based_Pointer_Basic&lt; CONCRETE &gt; &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>rhs</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap> const</td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Greater than or equal operator.
<p>
    </td>
  </tr>
</table>
<a name="a13" doxytag="ACE_Based_Pointer_Basic::operator[]"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class CONCRETE&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> ACE_INLINE CONCRETE ACE_Based_Pointer_Basic&lt; CONCRETE &gt;::operator[] </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>index</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap> const</td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Subscript operator.
<p>
    </td>
  </tr>
</table>
<hr><h2>Member Data Documentation</h2>
<a name="m0" doxytag="ACE_Based_Pointer_Basic::ACE_ALLOC_HOOK_DECLARE"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class CONCRETE&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> ACE_Based_Pointer_Basic::ACE_ALLOC_HOOK_DECLARE
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Declare the dynamic allocation hooks.
<p>
    </td>
  </tr>
</table>
<a name="n1" doxytag="ACE_Based_Pointer_Basic::base_offset_"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class CONCRETE&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> long ACE_Based_Pointer_Basic::base_offset_<code> [protected]</code>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Keep track of our offset from the base pointer.
<p>
    </td>
  </tr>
</table>
<a name="n0" doxytag="ACE_Based_Pointer_Basic::target_"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class CONCRETE&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> long ACE_Based_Pointer_Basic::target_<code> [protected]</code>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<hr>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="Based__Pointer__T_8h.html">Based_Pointer_T.h</a><li><a class="el" href="Based__Pointer__T_8cpp.html">Based_Pointer_T.cpp</a><li><a class="el" href="Based__Pointer__T_8i.html">Based_Pointer_T.i</a></ul>
<hr><address><small>Generated on Wed Jan 15 19:07:37 2003 for ACE by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.gif" alt="doxygen" align="middle" border=0 
width=110 height=53></a>1.2.13.1 written by <a href="mailto:dimitri@stack.nl">Dimitri van Heesch</a>,
 &copy;&nbsp;1997-2001</small></address>
</body>
</html>
