<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>How to write a run_test.pl</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body bgcolor="#ffffff">
<!-- Generated by Doxygen 1.2.13.1 -->
<center>
<a class="qindex" href="index.html">Main Page</a> &nbsp; <a class="qindex" href="hierarchy.html">Class Hierarchy</a> &nbsp; <a class="qindex" href="classes.html">Alphabetical List</a> &nbsp; <a class="qindex" href="annotated.html">Compound List</a> &nbsp; <a class="qindex" href="files.html">File List</a> &nbsp; <a class="qindex" href="functions.html">Compound Members</a> &nbsp; <a class="qindex" href="globals.html">File Members</a> &nbsp; <a class="qindex" href="pages.html">Related Pages</a> &nbsp; </center>
<hr><a name="run_test_howto"><h2>How to write a run_test.pl</h2></a>

<p>
<a class="el" href="classACE.html">ACE</a>/TAO's auto_builds expect run_test.pl's to follow some guidelines that are needed to keep the auto_builds from hanging and to make sure the run_test.pl works on all platforms
<p>
<ul>
<li>The run_test must not hang or block.<li>The run_test must clean up any temporary files when it is done. <li>The run_test must not require any user input<li>The run_test should return a non-zero value if the test failed</ul>
Following is an example
<p>
<a name="example"><h3>Example</h3></a>

<p>
<div class="fragment"><pre>
eval '(exit $?0)' &amp;&amp; eval 'exec perl -S $0 ${1+"$@"}'
    &amp; eval 'exec perl -S $0 $argv:q'
    if 0;

# run_test.txt,v 1.3 2001/03/05 03:40:39 brunsch Exp
# -*- perl -*-

use lib '../../../bin';
use PerlACE::Run_Test;

$status = 0;

$server_ior = PerlACE::LocalFile ("server.ior");
unlink $server_ior;

$SV = new PerlACE::Process ("server", "-o $server_ior");
$CL = new PerlACE::Process ("client", "-k file://$server_ior");

$SV-&gt;Spawn ();

if (PerlACE::waitforfile_timed ($server_ior, 5) == -1) {
    print STDERR "ERROR: cannot find file &lt;$server_ior&gt;\n";
    $SV-&gt;Kill ();
    exit 1;
} 

$client = $CL-&gt;SpawnWaitKill (60);

if ($client != 0) {
    print STDERR "ERROR: client returned $client\n";
    $status = 1;
}

$server = $SV-&gt;TerminateWaitKill (5);

if ($server != 0) {
    print STDERR "ERROR: server returned $server\n";
    $status = 1;
}

unlink $server_ior;
 
exit $status;
</pre></div>
<p>
<a name="details"><h3>Example Details</h3></a>

<p>
<div class="fragment"><pre>
eval '(exit $?0)' &amp;&amp; eval 'exec perl -S $0 ${1+"$@"}'
    &amp; eval 'exec perl -S $0 $argv:q'
    if 0;

# run_test.txt,v 1.3 2001/03/05 03:40:39 brunsch Exp
</pre></div>
<p>
This is the standard header stuff. The eval is a trick used to get the perl script to run if it a unix shell treats it as a shell script.
<p>
The CVS ID string is the usual one we put in.
<p>
<div class="fragment"><pre>
use lib '../../../bin';
use PerlACE::Run_Test;
</pre></div>
<p>
The use lib line is used to tell Perl where the PerlACE modules are. It should be a relative path to the bin directory.
<p>
And PerlACE::Run_Test is a module to be used by all run_test.pl's. It does a couple of things, including parsing some common command line arguments (like -Config and -ExeSubDir) and also brings in the PerlACE::Process module.
<p>
<div class="fragment"><pre>
$status = 0;

$server_ior = PerlACE::LocalFile ("server.ior");

unlink $server_ior;
</pre></div>
<p>
Because of the way tests work on chorus, we need to have a fully  qualified path to all *.ior and *.conf files. We unlink the file immediately because we use PerlACE::waitforfile_timed later.
<p>
<div class="fragment"><pre>
$SV = new PerlACE::Process ("server", "-o $server_ior");
$CL = new PerlACE::Process ("client", " -k file://$server_ior ");

$SV-&gt;Spawn ();
</pre></div>
<p>
The PerlACE::Process is constructed with an executable and  arguments. <dl compact><dt><b>
Note: </b><dd>
Unlike the old Process module, the process isn't started until one of the Spawn methods is used.</dl><div class="fragment"><pre>
if (PerlACE::waitforfile_timed ($server_ior, 5) == -1) {
    print STDERR "ERROR: cannot find file &lt;$server_ior&gt;\n";
    $SV-&gt;Kill (); 
    exit 1;
} 
</pre></div>
<p>
The PerlACE::waitforfile_timed method waits until the file is created. In this way, we know when to start the client. If no IOR file is used, then you'd need to use Perl's sleep  method.
<p>
<div class="fragment"><pre>
$client = $CL-&gt;SpawnWaitKill (60);

if ($client != 0) {
    print STDERR "ERROR: client returned $client\n";
    $status = 1;
}
</pre></div>
<p>
Here is an example of starting the client. SpawnWaitKill will start  the process and wait for the specified number of seconds for the  process to end. If the time limit is reached, it will kill the  process and return -1.
<p>
The return value of SpawnWaitKill is the return value of the  process, unless it timed out. You don't need to check for the  timeout, since SpawnWaitKill will print out a timeout error.  Instead, just check for != 0.
<p>
<div class="fragment"><pre>
$server = $SV-&gt;TerminateWaitKill (5);

if ($server != 0) {
    print STDERR "ERROR: server returned $server\n";
    $status = 1;
}
</pre></div>
<p>
Here is the termination of the server. Servers are usually terminated either by TerminateWaitKill or just WaitKill. TerminateWaitKill is  used when the server doesn't shut down itself. WaitKill is used when it does (such as when the client calls a shutdown method). Once again, we check the return status.
<p>
<div class="fragment"><pre>
unlink $server_ior;
 
exit $status;
</pre></div>
<p>
And finally, we unlink any files that were created and then just exit with $status.
<p>
<hr><address><small>Generated on Wed Jan 15 19:17:21 2003 for ACE by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.gif" alt="doxygen" align="middle" border=0 
width=110 height=53></a>1.2.13.1 written by <a href="mailto:dimitri@stack.nl">Dimitri van Heesch</a>,
 &copy;&nbsp;1997-2001</small></address>
</body>
</html>
