<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Annotated Index</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body bgcolor="#ffffff">
<!-- Generated by Doxygen 1.2.13.1 -->
<center>
<a class="qindex" href="index.html">Main Page</a> &nbsp; <a class="qindex" href="hierarchy.html">Class Hierarchy</a> &nbsp; <a class="qindex" href="classes.html">Alphabetical List</a> &nbsp; <a class="qindex" href="annotated.html">Compound List</a> &nbsp; <a class="qindex" href="files.html">File List</a> &nbsp; <a class="qindex" href="functions.html">Compound Members</a> &nbsp; <a class="qindex" href="globals.html">File Members</a> &nbsp; <a class="qindex" href="pages.html">Related Pages</a> &nbsp; </center>
<hr><h1>ACE Compound List</h1>Here are the classes, structs, unions and interfaces with brief descriptions:<table>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="struct__WSANETWORKEVENTS.html">_WSANETWORKEVENTS</a></td><td></td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE.html">ACE</a></td><td>Contains value added ACE methods that extend the behavior of the UNIX and Win32 OS calls</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Accept__QoS__Params.html">ACE_Accept_QoS_Params</a></td><td>Wrapper class that simplifies the information passed to the QoS enabled &lt;<a class="el" href="classACE__OS.html#z50_0">ACE_OS::accept</a>&gt; method</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Accept__Strategy.html">ACE_Accept_Strategy&lt; SVC_HANDLER, &gt;</a></td><td>Defines the interface for specifying a passive connection acceptance strategy for a SVC_HANDLER</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Acceptor.html">ACE_Acceptor&lt; SVC_HANDLER, &gt;</a></td><td>Abstract factory for creating a service handler (SVC_HANDLER), accepting into the SVC_HANDLER, and activating the SVC_HANDLER</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Acquire__Method.html">ACE_Acquire_Method</a></td><td>An enum class</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Activation__Queue.html">ACE_Activation_Queue</a></td><td>Reifies a method into a request. Subclasses typically represent necessary state and behavior</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Active__Map__Manager.html">ACE_Active_Map_Manager&lt; T &gt;</a></td><td>Define a map abstraction that associates system generated keys with user specified values</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Active__Map__Manager__Adapter.html">ACE_Active_Map_Manager_Adapter&lt; KEY, VALUE, KEY_ADAPTER &gt;</a></td><td>Defines a map implementation</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Active__Map__Manager__Iterator__Adapter.html">ACE_Active_Map_Manager_Iterator_Adapter&lt; T, VALUE &gt;</a></td><td>Defines a iterator implementation for the Active_Map_Manager_Adapter</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Active__Map__Manager__Key.html">ACE_Active_Map_Manager_Key</a></td><td>Key used in the Active Object Map</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="structACE__Active__Map__Manager__Key_1_1key__data.html">ACE_Active_Map_Manager_Key::key_data</a></td><td>Data for the Active Object Map Key</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Active__Map__Manager__Reverse__Iterator__Adapter.html">ACE_Active_Map_Manager_Reverse_Iterator_Adapter&lt; T, VALUE &gt;</a></td><td>Defines a reverse iterator implementation for the Active_Map_Manager_Adapter</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Adaptive__Lock.html">ACE_Adaptive_Lock</a></td><td>An adaptive general locking class that defers the decision of lock type to run time</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Addr.html">ACE_Addr</a></td><td>Defines the base class for the "address family independent" address format</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__AIOCB__Notify__Pipe__Manager.html">ACE_AIOCB_Notify_Pipe_Manager</a></td><td>This class manages the notify pipe of the AIOCB Proactor</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Allocator.html">ACE_Allocator</a></td><td>Interface for a dynamic memory allocator that uses inheritance and dynamic binding to provide extensible mechanisms for allocating and deallocating memory</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Allocator__Adapter.html">ACE_Allocator_Adapter&lt; MALLOC &gt;</a></td><td>This class is an Adapter that allows the <a class="el" href="classACE__Allocator.html">ACE_Allocator</a> to use the <a class="el" href="classACE__Malloc.html">ACE_Malloc</a> class below</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Arg__Shifter.html">ACE_Arg_Shifter</a></td><td>This ADT operates on a specified set of arguments (<em>argv)</em>. As known arguments are scanned, they are shifted to the back of the <em>argv</em> vector, so deeper levels of argument parsing can locate the yet unprocessed arguments at the beginning of the vector</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__ARGV.html">ACE_ARGV</a></td><td>Transforms a string &lt;buf&gt; into an &lt;argv&gt; style vector of strings or an &lt;argv&gt; style vector of string &lt;buf&gt;, performing environment variable substitutions if necessary</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Argv__Type__Converter.html">ACE_Argv_Type_Converter</a></td><td>To convert 'char' input/command line parameter to 'wchar_t'</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Array.html">ACE_Array&lt; T &gt;</a></td><td>A dynamic array class</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Array__Base.html">ACE_Array_Base&lt; T &gt;</a></td><td>Implement a simple dynamic array</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Array__Iterator.html">ACE_Array_Iterator&lt; T &gt;</a></td><td>Implement an iterator over an <a class="el" href="classACE__Array.html">ACE_Array</a></td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Async__Timer__Queue__Adapter.html">ACE_Async_Timer_Queue_Adapter&lt; TQ &gt;</a></td><td>Adapts a &lt;TQ&gt; to be run asynchronously</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Asynch__Accept.html">ACE_Asynch_Accept</a></td><td>This class is a factory for starting off asynchronous accepts on a listen handle. This class forwards all methods to its implementation class</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Asynch__Accept_1_1Result.html">ACE_Asynch_Accept::Result</a></td><td>This is that class which will be passed back to the &lt;handler&gt; when the asynchronous accept completes</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Asynch__Accept__Impl.html">ACE_Asynch_Accept_Impl</a></td><td>Abstract base class for all the concrete implementation classes that provide different implementations for the <a class="el" href="classACE__Asynch__Accept.html">ACE_Asynch_Accept</a></td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Asynch__Accept__Result__Impl.html">ACE_Asynch_Accept_Result_Impl</a></td><td>Abstract base class for all the concrete implementation classes that provide different implementations for the <a class="el" href="classACE__Asynch__Accept.html">ACE_Asynch_Accept</a></td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Asynch__Acceptor.html">ACE_Asynch_Acceptor&lt; HANDLER &gt;</a></td><td>This class is an example of the Acceptor Pattern. This class will accept new connections and create new HANDLER to handle the new connections</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Asynch__Connect.html">ACE_Asynch_Connect</a></td><td>This class is a factory for starting off asynchronous connects This class forwards all methods to its implementation class</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Asynch__Connect_1_1Result.html">ACE_Asynch_Connect::Result</a></td><td>This is that class which will be passed back to the handler when the asynchronous connect completes</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Asynch__Connect__Impl.html">ACE_Asynch_Connect_Impl</a></td><td>Abstract base class for all the concrete implementation classes that provide different implementations for the <a class="el" href="classACE__Asynch__Connect.html">ACE_Asynch_Connect</a></td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Asynch__Connect__Result__Impl.html">ACE_Asynch_Connect_Result_Impl</a></td><td>Abstract base class for all the concrete implementation classes that provide different implementations for the <a class="el" href="classACE__Asynch__Connect.html">ACE_Asynch_Connect</a></td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Asynch__Connector.html">ACE_Asynch_Connector&lt; HANDLER &gt;</a></td><td>This class is an example of the Connector pattern. This class will establish new connections and create new HANDLER objects to handle the new connections</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Asynch__Operation.html">ACE_Asynch_Operation</a></td><td>This is an interface base class for all asynch operations. The resposiblility of this class is to forward all methods to its delegation/implementation class, e.g., &lt;<a class="el" href="classACE__WIN32__Asynch__Operation.html">ACE_WIN32_Asynch_Operation</a>&gt; or &lt;<a class="el" href="classACE__POSIX__Asynch__Operation.html">ACE_POSIX_Asynch_Operation</a>&gt;</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Asynch__Operation__Impl.html">ACE_Asynch_Operation_Impl</a></td><td>Abstract base class for all the concrete implementation classes that provide different implementations for the <a class="el" href="classACE__Asynch__Operation.html">ACE_Asynch_Operation</a></td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Asynch__Pseudo__Task.html">ACE_Asynch_Pseudo_Task</a></td><td></td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Asynch__Read__Dgram.html">ACE_Asynch_Read_Dgram</a></td><td>This class is a factory for starting off asynchronous reads on a UDP socket. This class forwards all methods to its implementation class</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Asynch__Read__Dgram_1_1Result.html">ACE_Asynch_Read_Dgram::Result</a></td><td>This is the class which will be passed back to the &lt;handler&gt; when the asynchronous read completes. This class forwards all the methods to the implementation classes</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Asynch__Read__Dgram__Impl.html">ACE_Asynch_Read_Dgram_Impl</a></td><td>Abstract base class for all the concrete implementation classes that provide different implementations for the <a class="el" href="classACE__Asynch__Read__Dgram.html">ACE_Asynch_Read_Dgram</a></td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Asynch__Read__Dgram__Result__Impl.html">ACE_Asynch_Read_Dgram_Result_Impl</a></td><td>Abstract base class for all the concrete implementation classes that provide different implementations for the <a class="el" href="classACE__Asynch__Read__Dgram_1_1Result.html">ACE_Asynch_Read_Dgram::Result</a> class</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Asynch__Read__File.html">ACE_Asynch_Read_File</a></td><td>This class is a factory for starting off asynchronous reads on a file. This class forwards all methods to its implementation class</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Asynch__Read__File_1_1Result.html">ACE_Asynch_Read_File::Result</a></td><td>This is that class which will be passed back to the &lt;handler&gt; when the asynchronous read completes. This class forwards all the methods to the implementation class</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Asynch__Read__File__Impl.html">ACE_Asynch_Read_File_Impl</a></td><td>Abstract base class for all the concrete implementation classes that provide different implementations for the <a class="el" href="classACE__Asynch__Read__File_1_1Result.html">ACE_Asynch_Read_File::Result</a></td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Asynch__Read__File__Result__Impl.html">ACE_Asynch_Read_File_Result_Impl</a></td><td>This is the abstract base class for all the concrete implementation classes for <a class="el" href="classACE__Asynch__Read__File_1_1Result.html">ACE_Asynch_Read_File::Result</a></td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Asynch__Read__Stream.html">ACE_Asynch_Read_Stream</a></td><td>This class is a factory for starting off asynchronous reads on a stream. This class forwards all methods to its implementation class</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Asynch__Read__Stream_1_1Result.html">ACE_Asynch_Read_Stream::Result</a></td><td>This is the class which will be passed back to the &lt;handler&gt; when the asynchronous read completes. This class forwards all the methods to the implementation classes</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Asynch__Read__Stream__Impl.html">ACE_Asynch_Read_Stream_Impl</a></td><td>Abstract base class for all the concrete implementation classes that provide different implementations for the <a class="el" href="classACE__Asynch__Read__Stream.html">ACE_Asynch_Read_Stream</a></td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Asynch__Read__Stream__Result__Impl.html">ACE_Asynch_Read_Stream_Result_Impl</a></td><td>Abstract base class for all the concrete implementation classes that provide different implementations for the <a class="el" href="classACE__Asynch__Read__Stream_1_1Result.html">ACE_Asynch_Read_Stream::Result</a> class</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Asynch__Result.html">ACE_Asynch_Result</a></td><td>An interface base class which allows users access to common information related to an asynchronous operation</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Asynch__Result__Impl.html">ACE_Asynch_Result_Impl</a></td><td>Abstract base class for the all the classes that provide concrete implementations for <a class="el" href="classACE__Asynch__Result.html">ACE_Asynch_Result</a></td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Asynch__Transmit__File.html">ACE_Asynch_Transmit_File</a></td><td>This class is a factory for starting off asynchronous transmit files on a stream</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Asynch__Transmit__File_1_1Header__And__Trailer.html">ACE_Asynch_Transmit_File::Header_And_Trailer</a></td><td>The class defines a data structure that contains pointers to data to send before and after the file data is sent</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Asynch__Transmit__File_1_1Result.html">ACE_Asynch_Transmit_File::Result</a></td><td>This is that class which will be passed back to the &lt;handler&gt; when the asynchronous transmit file completes</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Asynch__Transmit__File__Impl.html">ACE_Asynch_Transmit_File_Impl</a></td><td>Abstract base class for all the concrete implementation classes that provide different implementations for the <a class="el" href="classACE__Asynch__Transmit__File.html">ACE_Asynch_Transmit_File</a></td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Asynch__Transmit__File__Result__Impl.html">ACE_Asynch_Transmit_File_Result_Impl</a></td><td>Abstract base class for all the concrete implementation classes that provide different implementations for the <a class="el" href="classACE__Asynch__Transmit__File_1_1Result.html">ACE_Asynch_Transmit_File::Result</a></td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Asynch__Write__Dgram.html">ACE_Asynch_Write_Dgram</a></td><td>This class is a factory for starting off asynchronous writes on a UDP socket. This class forwards all methods to its implementation class</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Asynch__Write__Dgram_1_1Result.html">ACE_Asynch_Write_Dgram::Result</a></td><td>This is that class which will be passed back to the &lt;handler&gt; when the asynchronous write completes. This class forwards all the methods to the implementation class</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Asynch__Write__Dgram__Impl.html">ACE_Asynch_Write_Dgram_Impl</a></td><td>Abstract base class for all the concrete implementation classes that provide different implementations for the <a class="el" href="classACE__Asynch__Write__Dgram.html">ACE_Asynch_Write_Dgram</a> class</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Asynch__Write__Dgram__Result__Impl.html">ACE_Asynch_Write_Dgram_Result_Impl</a></td><td>Abstract base class for all the concrete implementation classes that provide different implementations for the <a class="el" href="classACE__Asynch__Write__Dgram_1_1Result.html">ACE_Asynch_Write_Dgram::Result</a> class</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Asynch__Write__File.html">ACE_Asynch_Write_File</a></td><td>This class is a factory for starting off asynchronous writes on a file. This class forwards all methods to its implementation class</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Asynch__Write__File_1_1Result.html">ACE_Asynch_Write_File::Result</a></td><td>This is that class which will be passed back to the &lt;handler&gt; when the asynchronous write completes. This class forwards all the methods to the implementation class</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Asynch__Write__File__Impl.html">ACE_Asynch_Write_File_Impl</a></td><td>Abstract base class for all the concrete implementation classes that provide different implementations for the <a class="el" href="classACE__Asynch__Write__File.html">ACE_Asynch_Write_File</a></td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Asynch__Write__File__Result__Impl.html">ACE_Asynch_Write_File_Result_Impl</a></td><td>This is the abstract base class for all the concrete implementation classes that provide different implementations for the <a class="el" href="classACE__Asynch__Write__File_1_1Result.html">ACE_Asynch_Write_File::Result</a></td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Asynch__Write__Stream.html">ACE_Asynch_Write_Stream</a></td><td>This class is a factory for starting off asynchronous writes on a stream. This class forwards all methods to its implementation class</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Asynch__Write__Stream_1_1Result.html">ACE_Asynch_Write_Stream::Result</a></td><td>This is that class which will be passed back to the &lt;handler&gt; when the asynchronous write completes. This class forwards all the methods to the implementation class</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Asynch__Write__Stream__Impl.html">ACE_Asynch_Write_Stream_Impl</a></td><td>Abstract base class for all the concrete implementation classes that provide different implementations for the <a class="el" href="classACE__Asynch__Write__Stream.html">ACE_Asynch_Write_Stream</a> class</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Asynch__Write__Stream__Result__Impl.html">ACE_Asynch_Write_Stream_Result_Impl</a></td><td>Abstract base class for all the concrete implementation classes that provide different implementations for the <a class="el" href="classACE__Asynch__Write__Stream_1_1Result.html">ACE_Asynch_Write_Stream::Result</a></td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__At__Thread__Exit.html">ACE_At_Thread_Exit</a></td><td>Contains a method to be applied when a thread is terminated</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__At__Thread__Exit__Func.html">ACE_At_Thread_Exit_Func</a></td><td></td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__ATM__Acceptor.html">ACE_ATM_Acceptor</a></td><td>Defines the member functions for ACE_ATM_Acceptor abstraction</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__ATM__Addr.html">ACE_ATM_Addr</a></td><td>Defines the ATM domain address family address format</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__ATM__Connector.html">ACE_ATM_Connector</a></td><td>Defines an active connection factory for the ACE_ATM C++ wrappers</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__ATM__Params.html">ACE_ATM_Params</a></td><td>Wrapper class that simplifies the information passed to the ATM enabled <a class="el" href="classACE__ATM__Connector.html">ACE_ATM_Connector</a> class</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__ATM__QoS.html">ACE_ATM_QoS</a></td><td>Define the QoS parameters for ATM</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__ATM__Stream.html">ACE_ATM_Stream</a></td><td>Defines the member functions for ACE_ATM_Stream abstraction</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Atomic__Op.html">ACE_Atomic_Op&lt; ACE_LOCK, TYPE &gt;</a></td><td>Transparently parameterizes synchronization into basic arithmetic operations</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Atomic__Op__Ex.html">ACE_Atomic_Op_Ex&lt; ACE_LOCK, TYPE &gt;</a></td><td>Transparently parameterizes synchronization into basic arithmetic operations</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Auto__Array__Ptr.html">ACE_Auto_Array_Ptr&lt; X &gt;</a></td><td>Implements an extension to the draft C++ standard <a class="el" href="classauto__ptr.html">auto_ptr</a> abstraction</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Auto__Basic__Array__Ptr.html">ACE_Auto_Basic_Array_Ptr&lt; X &gt;</a></td><td>Implements an extension to the draft C++ standard <a class="el" href="classauto__ptr.html">auto_ptr</a> abstraction. This class allows one to work on non-object (basic) types that must be treated as an array, e.g., deallocated via "delete [] foo"</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Auto__Basic__Ptr.html">ACE_Auto_Basic_Ptr&lt; X &gt;</a></td><td>Implements the draft C++ standard <a class="el" href="classauto__ptr.html">auto_ptr</a> abstraction. This class allows one to work on non-object (basic) types</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Auto__Event.html">ACE_Auto_Event</a></td><td>Auto Events</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Auto__IncDec.html">ACE_Auto_IncDec&lt; ACE_SAFELY_INCREMENTABLE_DECREMENTABLE &gt;</a></td><td>This class automatically increments and decrements a parameterized counter</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Auto__String__Free.html">ACE_Auto_String_Free</a></td><td>Simple class to automatically de-allocate strings</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Barrier.html">ACE_Barrier</a></td><td>Implements "barrier synchronization"</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Base64.html">ACE_Base64</a></td><td>Encode/Decode a stream of bytes according to Base64 encoding</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Base__Thread__Adapter.html">ACE_Base_Thread_Adapter</a></td><td>Base class for all the Thread_Adapters</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Based__Pointer.html">ACE_Based_Pointer&lt; CONCRETE &gt;</a></td><td>A smart proxy that keeps track of the relative offset of a "pointer" from its base address</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Based__Pointer__Basic.html">ACE_Based_Pointer_Basic&lt; CONCRETE &gt;</a></td><td>A proxy that keeps track of the relative offset of a "pointer" from its base address. This class makes it possible to transparently use "pointers" in shared memory as easily as programming with pointers to local memory. In particular, we don't need to ensure that the base addresses of all the pointers are mapped into separate processes at the same absolute memory base address</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Based__Pointer__Repository.html">ACE_Based_Pointer_Repository</a></td><td>Maps pointers to the base address of the region to which each pointer belongs</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Based__Pointer__Repository__Rep.html">ACE_Based_Pointer_Repository_Rep</a></td><td>Implementation for the &lt;<a class="el" href="classACE__Based__Pointer__Repository.html">ACE_Based_Pointer_Repository</a>&gt;</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Basic__Stats.html">ACE_Basic_Stats</a></td><td>Collect basic stats about a series of samples</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Bcast__Node.html">ACE_Bcast_Node</a></td><td>Linked list of broadcast interfaces</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__BoolCapEntry.html">ACE_BoolCapEntry</a></td><td>This class implement the <a class="el" href="classACE.html">ACE</a> Bool Capability subclass</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Bound__Ptr__Counter.html">ACE_Bound_Ptr_Counter&lt; ACE_LOCK &gt;</a></td><td>An ACE_Bound_Ptr_Counter&lt;ACE_LOCK&gt; object encapsulates an object reference count</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Bounded__Cached__Connect__Strategy.html">ACE_Bounded_Cached_Connect_Strategy&lt; SVC_HANDLER,, CACHING_STRATEGY, ATTRIBUTES, MUTEX &gt;</a></td><td>A connection strategy which caches connections to peers (represented by &lt;SVC_HANDLER&gt; instances), thereby allowing subsequent re-use of unused, but available, connections. This strategy should be used when the cache is bounded by maximum size</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Bounded__Set.html">ACE_Bounded_Set&lt; T &gt;</a></td><td>Implement a simple unordered set of &lt;T&gt; with maximum set at creation time</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="structACE__Bounded__Set_1_1Search__Structure.html">ACE_Bounded_Set&lt; T &gt;::Search_Structure</a></td><td></td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Bounded__Set__Iterator.html">ACE_Bounded_Set_Iterator&lt; T &gt;</a></td><td>Iterates through an unordered set</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Bounded__Stack.html">ACE_Bounded_Stack&lt; T &gt;</a></td><td>Implement a generic LIFO abstract data type</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Buffered__Svc__Handler.html">ACE_Buffered_Svc_Handler&lt;, &gt;</a></td><td>Defines the interface for a service that exchanges data with its connected peer and supports buffering</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Cache__Map__Iterator.html">ACE_Cache_Map_Iterator&lt; KEY, VALUE, IMPLEMENTATION, CACHING_STRATEGY, ATTRIBUTES &gt;</a></td><td>Defines a iterator for the Cache_Map_Manager</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Cache__Map__Manager.html">ACE_Cache_Map_Manager&lt;&gt;</a></td><td>Defines a abstraction that will purge entries from a map</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Cache__Map__Reverse__Iterator.html">ACE_Cache_Map_Reverse_Iterator&lt; KEY, VALUE, REVERSE_IMPLEMENTATION, CACHING_STRATEGY, ATTRIBUTES &gt;</a></td><td>Defines a reverse iterator for the Cache_Map_Manager</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Cached__Allocator.html">ACE_Cached_Allocator&lt; T, ACE_LOCK &gt;</a></td><td>A fixed-size allocator that caches items for quicker access</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Cached__Connect__Strategy.html">ACE_Cached_Connect_Strategy&lt; SVC_HANDLER,, MUTEX &gt;</a></td><td>A connection strategy which caches connections to peers (represented by &lt;SVC_HANDLER&gt; instances), thereby allowing subsequent re-use of unused, but available, connections</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Cached__Connect__Strategy__Ex.html">ACE_Cached_Connect_Strategy_Ex&lt; SVC_HANDLER,, CACHING_STRATEGY, ATTRIBUTES, MUTEX &gt;</a></td><td>A connection strategy which caches connections to peers (represented by &lt;SVC_HANDLER&gt; instances), thereby allowing subsequent re-use of unused, but available, connections</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Cached__Mem__Pool__Node.html">ACE_Cached_Mem_Pool_Node&lt; T &gt;</a></td><td>ACE_Cached_Mem_Pool_Node keeps unused memory within a free list</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Caching__Strategy.html">ACE_Caching_Strategy&lt; ATTRIBUTES, CACHING_UTILITY &gt;</a></td><td>This class is an abstract base class for a caching strategy</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Caching__Strategy__Adapter.html">ACE_Caching_Strategy_Adapter&lt; ATTRIBUTES, CACHING_UTILITY, IMPLEMENTATION &gt;</a></td><td>This class follows the Adaptor pattern and is used to provide External Polymorphism by deriving from <a class="el" href="classACE__Caching__Strategy.html">ACE_Caching_Strategy</a></td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Capabilities.html">ACE_Capabilities</a></td><td>This class implement the <a class="el" href="classACE.html">ACE</a> Capabilities</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__CapEntry.html">ACE_CapEntry</a></td><td>This class is the base class for all <a class="el" href="classACE.html">ACE</a> Capabilities entry subclasses</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__CDR.html">ACE_CDR</a></td><td>Keep constants and some routines common to both Output and Input CDR streams</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="structACE__CDR_1_1Double.html">ACE_CDR::Double</a></td><td></td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="structACE__CDR_1_1Float.html">ACE_CDR::Float</a></td><td></td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="structACE__CDR_1_1LongDouble.html">ACE_CDR::LongDouble</a></td><td></td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Char__Codeset__Translator.html">ACE_Char_Codeset_Translator</a></td><td>Codeset translation routines common to both Output and Input CDR streams</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Cleanup.html">ACE_Cleanup</a></td><td>Base class for objects that are cleaned by <a class="el" href="classACE__Object__Manager.html">ACE_Object_Manager</a></td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Cleanup__Adapter.html">ACE_Cleanup_Adapter&lt; TYPE &gt;</a></td><td>Adapter for <a class="el" href="classACE__Cleanup.html">ACE_Cleanup</a> objects that allows them to be readily managed by the <a class="el" href="classACE__Object__Manager.html">ACE_Object_Manager</a></td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Cleanup__Info.html">ACE_Cleanup_Info</a></td><td>Hold cleanup information for thread/process</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Cleanup__Info__Node.html">ACE_Cleanup_Info_Node</a></td><td>For maintaining a list of <a class="el" href="classACE__Cleanup__Info.html">ACE_Cleanup_Info</a> items</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Cleanup__Strategy.html">ACE_Cleanup_Strategy&lt; KEY, VALUE, CONTAINER &gt;</a></td><td>Defines a default strategy to be followed for cleaning up entries from a map which is the container</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Command__Base.html">ACE_Command_Base</a></td><td>Defines an abstract class that allows us to invoke commands without knowing anything about the implementation</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Command__Callback.html">ACE_Command_Callback&lt; RECEIVER, ACTION &gt;</a></td><td>Defines a class template that allows us to invoke a GOF command style callback to an object without knowing anything about the object except its type</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Concurrency__Strategy.html">ACE_Concurrency_Strategy&lt; SVC_HANDLER &gt;</a></td><td>Defines the interface for specifying a concurrency strategy for a SVC_HANDLER</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Condition.html">ACE_Condition&lt; MUTEX &gt;</a></td><td>ACE_Condition variable wrapper, which allows threads to block until shared data changes state</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Condition_3_01ACE__Recursive__Thread__Mutex_01_4.html">ACE_Condition&lt; ACE_Recursive_Thread_Mutex &gt;</a></td><td><a class="el" href="classACE__Condition.html">ACE_Condition</a> template specialization written using <em><a class="el" href="classACE__Recursive__Thread__Mutex.html">ACE_Recursive_Thread_Mutex</a></em>. This allows threads to block until shared data changes state using recursive mutexes</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Condition__Attributes.html">ACE_Condition_Attributes</a></td><td></td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Condition__Recursive__Thread__Mutex.html">ACE_Condition_Recursive_Thread_Mutex</a></td><td></td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Condition__Thread__Mutex.html">ACE_Condition_Thread_Mutex</a></td><td><a class="el" href="classACE__Condition.html">ACE_Condition</a> variable wrapper written using ACE_Mutexes This allows threads to block until shared data changes state. A condition variable enables threads to atomically block and test the condition under the protection of a mutual exclu- sion lock (mutex) until the condition is satisfied. That is, the mutex must have been held by the thread before calling wait or signal on the condition. If the condition is false, a thread blocks on a condition variable and atomically releases the mutex that is waiting for the condition to change. If another thread changes the condition, it may wake up waiting threads by signaling the associated condition variable. The waiting threads, upon awakening, reacquire the mutex and re-evaluate the condition</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Config__ImpExp__Base.html">ACE_Config_ImpExp_Base</a></td><td>Base class for file import/export configuration</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Configuration.html">ACE_Configuration</a></td><td></td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Configuration__ExtId.html">ACE_Configuration_ExtId</a></td><td>External ID for the section and value hash</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Configuration__Heap.html">ACE_Configuration_Heap</a></td><td>The concrete implementation of a allocator based configuration database</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Configuration__Section__IntId.html">ACE_Configuration_Section_IntId</a></td><td>The internal ID for a section hash table</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Configuration__Section__Key.html">ACE_Configuration_Section_Key</a></td><td>Reference counted wrapper for <a class="el" href="classACE__Section__Key__Internal.html">ACE_Section_Key_Internal</a></td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Configuration__Section__Key__Heap.html">ACE_Configuration_Section_Key_Heap</a></td><td>Internal section key class for heap based configuration database</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Configuration__Value__IntId.html">ACE_Configuration_Value_IntId</a></td><td>The section hash table internal value class</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Configuration__Win32Registry.html">ACE_Configuration_Win32Registry</a></td><td>The win32 registry implementation of a configuration database</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Connect__Strategy.html">ACE_Connect_Strategy&lt; SVC_HANDLER, &gt;</a></td><td>Defines the interface for specifying an active connection establishment strategy for a SVC_HANDLER</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Connection__Recycling__Strategy.html">ACE_Connection_Recycling_Strategy</a></td><td>Defines the interface for a connection recycler</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Connector.html">ACE_Connector&lt; SVC_HANDLER, &gt;</a></td><td>Generic factory for actively connecting clients and creating service handlers (SVC_HANDLERs)</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Control__Block.html">ACE_Control_Block</a></td><td>This information is stored in memory allocated by the &lt;Memory_Pool&gt;</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Control__Block_1_1ACE__Malloc__Header.html">ACE_Control_Block::ACE_Malloc_Header</a></td><td>This is the control block header. It's used by &lt;<a class="el" href="classACE__Malloc.html">ACE_Malloc</a>&gt; to keep track of each chunk of data when it's in the free list or in use</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Control__Block_1_1ACE__Name__Node.html">ACE_Control_Block::ACE_Name_Node</a></td><td>This class supports "named memory regions" within &lt;<a class="el" href="classACE__Malloc.html">ACE_Malloc</a>&gt;</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Copy__Disabled.html">ACE_Copy_Disabled</a></td><td>Helper class to disable copy construction and assignment</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Countdown__Time.html">ACE_Countdown_Time</a></td><td>Keeps track of the amount of elapsed time</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Creation__Strategy.html">ACE_Creation_Strategy&lt; SVC_HANDLER &gt;</a></td><td>Defines the interface for specifying a creation strategy for a SVC_HANDLER</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Data__Block.html">ACE_Data_Block</a></td><td>Stores the data payload that is accessed via one or more &lt;<a class="el" href="classACE__Message__Block.html">ACE_Message_Block</a>&gt;s</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Date__Time.html">ACE_Date_Time</a></td><td>System independent representation of date and time</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Deadline__Message__Strategy.html">ACE_Deadline_Message_Strategy</a></td><td>Deadline based message priority strategy</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__DEV.html">ACE_DEV</a></td><td>Defines the member functions for the base class of the ACE_DEV abstraction</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__DEV__Addr.html">ACE_DEV_Addr</a></td><td>Defines device address family address format</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__DEV__Connector.html">ACE_DEV_Connector</a></td><td>Defines an active connection factory for the <a class="el" href="classACE__DEV.html">ACE_DEV</a> wrappers</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__DEV__IO.html">ACE_DEV_IO</a></td><td>Read/Write operations on Devices</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Dev__Poll__Event__Tuple.html">ACE_Dev_Poll_Event_Tuple</a></td><td>Class that associates specific event mask with a given event handler</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Dev__Poll__Handler__Guard.html">ACE_Dev_Poll_Handler_Guard</a></td><td>Class used to make event handler reference count manipulation exception-safe</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Dev__Poll__Reactor.html">ACE_Dev_Poll_Reactor</a></td><td>A `/dev/poll' or `/dev/epoll' based Reactor implemenatation</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Dev__Poll__Reactor__Handler__Repository.html">ACE_Dev_Poll_Reactor_Handler_Repository</a></td><td>Used to map ACE_HANDLEs onto the appropriate <a class="el" href="classACE__Event__Handler.html">ACE_Event_Handler</a> *</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Dev__Poll__Reactor__Notify.html">ACE_Dev_Poll_Reactor_Notify</a></td><td>Event handler used for unblocking the <a class="el" href="classACE__Dev__Poll__Reactor.html">ACE_Dev_Poll_Reactor</a> from its event loop</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Dirent.html">ACE_Dirent</a></td><td>Define a portable C++ directory-entry iterator based on the POSIX API</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Dirent__Selector.html">ACE_Dirent_Selector</a></td><td>Define a portable C++ directory-entry iterator based on the POSIX scandir API</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__DLL.html">ACE_DLL</a></td><td>Provides an abstract interface for handling various DLL operations</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__DLL__Handle.html">ACE_DLL_Handle</a></td><td>Provides an abstract interface for handling various DLL operations</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__DLL__Manager.html">ACE_DLL_Manager</a></td><td>This class is a singleton and serves as a factory and repository for instances of <a class="el" href="classACE__DLL__Handle.html">ACE_DLL_Handle</a></td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__DLL__Singleton__Adapter__T.html">ACE_DLL_Singleton_Adapter_T&lt; TYPE &gt;</a></td><td></td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__DLL__Singleton__T.html">ACE_DLL_Singleton_T&lt; TYPE, ACE_LOCK &gt;</a></td><td>Same as <a class="el" href="classACE__Singleton.html">ACE_Singleton</a>, except that it registers for destruction with the <a class="el" href="classACE__Framework__Repository.html">ACE_Framework_Repository</a> instead of with the <a class="el" href="classACE__Object__Manager.html">ACE_Object_Manager</a> directly</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__DLL__Strategy.html">ACE_DLL_Strategy&lt; SVC_HANDLER &gt;</a></td><td>Defines the interface for specifying a creation strategy for a SVC_HANDLER based on dynamic linking of the SVC_HANDLER</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__DLList.html">ACE_DLList&lt; T &gt;</a></td><td>A double-linked list container class</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__DLList__Iterator.html">ACE_DLList_Iterator&lt; T &gt;</a></td><td>A double-linked list container class iterator</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__DLList__Node.html">ACE_DLList_Node</a></td><td>Base implementation of element in a DL list. Needed for <a class="el" href="classACE__Double__Linked__List.html">ACE_Double_Linked_List</a></td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__DLList__Reverse__Iterator.html">ACE_DLList_Reverse_Iterator&lt; T &gt;</a></td><td>A double-linked list container class iterator</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__DNode.html">ACE_DNode&lt; T &gt;</a></td><td>Implementation element in a bilinked list</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Double__Linked__List.html">ACE_Double_Linked_List&lt; T &gt;</a></td><td>A double-linked list implementation</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Double__Linked__List__Iterator.html">ACE_Double_Linked_List_Iterator&lt; T &gt;</a></td><td>Implements an iterator for a double linked list ADT</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Double__Linked__List__Iterator__Base.html">ACE_Double_Linked_List_Iterator_Base&lt; T &gt;</a></td><td>Implements a common base class for iterators for a double linked list ADT</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Double__Linked__List__Reverse__Iterator.html">ACE_Double_Linked_List_Reverse_Iterator&lt; T &gt;</a></td><td>Implements a reverse iterator for a double linked list ADT</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Dummy__Node.html">ACE_Dummy_Node</a></td><td>I forget why this is here... ;-)</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Dumpable.html">ACE_Dumpable</a></td><td>Base class that defines a uniform interface for all object dumping</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Dumpable__Adapter.html">ACE_Dumpable_Adapter&lt; Concrete &gt;</a></td><td>This class inherits the interface of the abstract <a class="el" href="classACE__Dumpable.html">ACE_Dumpable</a> class and is instantiated with the implementation of the concrete component class &lt;class Concrete&gt;</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Dumpable__Ptr.html">ACE_Dumpable_Ptr</a></td><td>A smart pointer stored in the in-memory object database <a class="el" href="classACE__ODB.html">ACE_ODB</a>. The pointee (if any) is deleted when reassigned</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Dynamic.html">ACE_Dynamic</a></td><td>Checks to see if an object was dynamically allocated</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Dynamic__Cached__Allocator.html">ACE_Dynamic_Cached_Allocator&lt; ACE_LOCK &gt;</a></td><td>A size-based allocator that caches blocks for quicker access</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Dynamic__Message__Queue.html">ACE_Dynamic_Message_Queue&lt;&gt;</a></td><td>A derived class which adapts the &lt;<a class="el" href="classACE__Message__Queue.html">ACE_Message_Queue</a>&gt; class in order to maintain dynamic priorities for enqueued &lt;ACE_Message_Blocks&gt; and manage the queue order according to these dynamic priorities</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Dynamic__Message__Strategy.html">ACE_Dynamic_Message_Strategy</a></td><td>An abstract base class which provides dynamic priority evaluation methods for use by the &lt;<a class="el" href="classACE__Dynamic__Message__Queue.html">ACE_Dynamic_Message_Queue</a>&gt; class or any other class which needs to manage the priorities of a collection of &lt;<a class="el" href="classACE__Message__Block.html">ACE_Message_Block</a>&gt;s dynamically</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Dynamic__Node.html">ACE_Dynamic_Node</a></td><td>Handle a dynamically linked node</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Dynamic__Service.html">ACE_Dynamic_Service&lt; TYPE &gt;</a></td><td>Provides a general interface to retrieve arbitrary objects from the <a class="el" href="classACE.html">ACE</a> service repository</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Dynamic__Service__Base.html">ACE_Dynamic_Service_Base</a></td><td>Base class for all <a class="el" href="classACE__Dynamic__Service.html">ACE_Dynamic_Service</a> instantiations</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__EH__Dispatch__Info.html">ACE_EH_Dispatch_Info</a></td><td>This structure contains information of the activated event handler</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Env__Value.html">ACE_Env_Value&lt; T &gt;</a></td><td>Enviroment Variable Value</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Equal__To.html">ACE_Equal_To&lt; TYPE &gt;</a></td><td>Function object for comparing two objects of the given type for equality</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Errno__Guard.html">ACE_Errno_Guard</a></td><td>Provides a wrapper to improve performance when thread-specific errno must be saved and restored in a block of code</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Event.html">ACE_Event</a></td><td>A wrapper around the Win32 event locking mechanism</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Event__Descriptions.html">ACE_Event_Descriptions</a></td><td>Event Descriptions</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Event__Handler.html">ACE_Event_Handler</a></td><td>Provides an abstract interface for handling various types of I/O, timer, and signal events</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Event__Handler__Handle__Timeout__Upcall.html">ACE_Event_Handler_Handle_Timeout_Upcall&lt; ACE_LOCK &gt;</a></td><td>Functor for Timer_Queues</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Event__Handler__T.html">ACE_Event_Handler_T&lt; T &gt;</a></td><td>Enable a class that doesn't inherit from the <a class="el" href="classACE__Event__Handler.html">ACE_Event_Handler</a> to be incorporated into the <a class="el" href="classACE__Reactor.html">ACE_Reactor</a> framework. Thanks to Greg Lavender (<a href="mailto:g.lavender@isode.com">g.lavender@isode.com</a>) for sharing this idea</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Event__Tuple.html">ACE_Event_Tuple</a></td><td>An <a class="el" href="classACE__Event__Handler.html">ACE_Event_Handler</a> and its associated ACE_HANDLE</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__FIFO.html">ACE_FIFO</a></td><td>Abstract base class for UNIX FIFOs</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__FIFO__Caching__Strategy.html">ACE_FIFO_Caching_Strategy&lt; ATTRIBUTES, CACHING_UTILITY &gt;</a></td><td>The First In First Out strategy is implemented wherein each item is ordered</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__FIFO__Recv.html">ACE_FIFO_Recv</a></td><td>Receiver side of the bytestream C++ wrapper for UNIX FIFOs</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__FIFO__Recv__Msg.html">ACE_FIFO_Recv_Msg</a></td><td>Receiver side for the record oriented C++ wrapper for UNIX FIFOs</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__FIFO__Send.html">ACE_FIFO_Send</a></td><td>Sender side for the bytestream C++ wrapper for UNIX FIFOs</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__FIFO__Send__Msg.html">ACE_FIFO_Send_Msg</a></td><td>Sender side for the Record oriented C++ wrapper for UNIX FIFOs</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__FILE.html">ACE_FILE</a></td><td>Defines the core methods of the ACE_FILE abstraction</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__FILE__Addr.html">ACE_FILE_Addr</a></td><td>Defines the FILE address family address format</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__FILE__Connector.html">ACE_FILE_Connector</a></td><td>Defines an active connection factory for the <a class="el" href="classACE__FILE.html">ACE_FILE</a> wrappers</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__FILE__Info.html">ACE_FILE_Info</a></td><td>Abstracts basic OS FILE information</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__FILE__IO.html">ACE_FILE_IO</a></td><td>Read/Write operations on Files</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__File__Lock.html">ACE_File_Lock</a></td><td>A wrapper around the UNIX file locking mechanism</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Filecache.html">ACE_Filecache</a></td><td>A hash table holding the information about entry point into the Cached Virtual Filesystem. On insertion, the reference count is incremented. On destruction, reference count is decremented</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Filecache__Handle.html">ACE_Filecache_Handle</a></td><td>Abstraction over a real file. This is meant to be the entry point into the Cached Virtual Filesystem</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Filecache__Object.html">ACE_Filecache_Object</a></td><td>Abstraction over a real file. This is what the Virtual Filesystem contains. This class is not intended for general consumption. Please consult a physician before attempting to use this class</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Fixed__Set.html">ACE_Fixed_Set&lt; T, ACE_SIZE &gt;</a></td><td>Implement a simple unordered set of &lt;T&gt; with maximum &lt;ACE_SIZE&gt;</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Fixed__Set__Const__Iterator.html">ACE_Fixed_Set_Const_Iterator&lt; T, ACE_SIZE &gt;</a></td><td>Iterates through a const unordered set</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Fixed__Set__Iterator.html">ACE_Fixed_Set_Iterator&lt; T, ACE_SIZE &gt;</a></td><td>Iterates through an unordered set</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Fixed__Stack.html">ACE_Fixed_Stack&lt; T, ACE_SIZE &gt;</a></td><td>Implement a generic LIFO abstract data type</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Flag__Manip.html">ACE_Flag_Manip</a></td><td></td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Flow__Spec.html">ACE_Flow_Spec</a></td><td>Wrapper class that defines the flow spec QoS information, which is used by IntServ (RSVP) and DiffServ</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__FlReactor.html">ACE_FlReactor</a></td><td>A Reactor implementation that uses the Fast-Light (FL) toolkit for event demultiplexing. This will let us integrate the FL toolkit with <a class="el" href="classACE.html">ACE</a> and/or TAO</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Framework__Component.html">ACE_Framework_Component</a></td><td>Base class that defines a uniform interface for all managed framework components</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Framework__Component__T.html">ACE_Framework_Component_T&lt; Concrete &gt;</a></td><td>This class inherits the interface of the abstract <a class="el" href="classACE__Framework__Component.html">ACE_Framework_Component</a> class and is instantiated with the implementation of the concrete component class &lt;class Concrete&gt;</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Framework__Repository.html">ACE_Framework_Repository</a></td><td>Contains all framework components used by an application</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Free__List.html">ACE_Free_List&lt; T &gt;</a></td><td>Implements a free list</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Free__List_3_01ACE__Cached__Mem__Pool__Node_3_01char_01_4_4.html">ACE_Free_List&lt; ACE_Cached_Mem_Pool_Node&lt; char &gt;&gt;</a></td><td></td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Free__List_3_01ACE__Cached__Mem__Pool__Node_3_01T_01_4_4.html">ACE_Free_List&lt; ACE_Cached_Mem_Pool_Node&lt; T &gt;&gt;</a></td><td></td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Function__Node.html">ACE_Function_Node</a></td><td>Keeps track of the symbol name of for a shared function</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Function__Timeprobe.html">ACE_Function_Timeprobe&lt; Timeprobe &gt;</a></td><td>Auto pointer like time probes. It will record &lt;event&gt; on construction and &lt;event + 1&gt; on destruction</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Future.html">ACE_Future&lt; T &gt;</a></td><td>This class implements a ``single write, multiple read'' pattern that can be used to return results from asynchronous method invocations</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Future__Holder.html">ACE_Future_Holder&lt; T &gt;</a></td><td>Implementation of object which has holds <a class="el" href="classACE__Future.html">ACE_Future</a></td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Future__Observer.html">ACE_Future_Observer&lt; T &gt;</a></td><td>ACE_Future_Observer&lt;T&gt;</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Future__Rep.html">ACE_Future_Rep&lt; T &gt;</a></td><td></td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Future__Set.html">ACE_Future_Set&lt; T &gt;</a></td><td>This class implements a mechanism which allows the values of a collection of <a class="el" href="classACE__Future.html">ACE_Future</a> objects to be accessed by reader threads as they become available. The caller(s) provide the ACE_Future_Set (i.e. the observer...) with the collection of <a class="el" href="classACE__Future.html">ACE_Future</a> objects (i.e. the subjects...) that are to be observed using the the <a class="el" href="classACE__Future__Set.html#a3">ACE_Future_Set::insert</a>() method. The caller(s) may then iterate over the collection in the order in which they become readable using the <a class="el" href="classACE__Future__Set.html#a4">ACE_Future_Set::next_readable</a>() method</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Get__Opt.html">ACE_Get_Opt</a></td><td>Iterator for parsing command-line arguments</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Get__Opt_1_1ACE__Get__Opt__Long__Option.html">ACE_Get_Opt::ACE_Get_Opt_Long_Option</a></td><td></td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Guard.html">ACE_Guard&lt; ACE_LOCK &gt;</a></td><td>This data structure is meant to be used within a method or function... It performs automatic aquisition and release of a parameterized synchronization object &lt;ACE_LOCK&gt;</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Guard_3_01ACE__Null__Mutex_01_4.html">ACE_Guard&lt; ACE_Null_Mutex &gt;</a></td><td>Template specialization of &lt;<a class="el" href="classACE__Guard.html">ACE_Guard</a>&gt; for the &lt;<a class="el" href="classACE__Null__Mutex.html">ACE_Null_Mutex</a>&gt;</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Guard_3_01ACE__Select__Reactor__Token__T_3_01ACE__Noop__Token_01_4_01_4.html">ACE_Guard&lt; ACE_Select_Reactor_Token_T&lt; ACE_Noop_Token &gt; &gt;</a></td><td>Template specialization of &lt;<a class="el" href="classACE__Guard.html">ACE_Guard</a>&gt; for the &lt;<a class="el" href="classACE__Null__Mutex.html">ACE_Null_Mutex</a>&gt;</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Handle__Gobbler.html">ACE_Handle_Gobbler</a></td><td>This class gobbles up handles</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Handle__Ops.html">ACE_Handle_Ops</a></td><td></td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Handle__Set.html">ACE_Handle_Set</a></td><td>C++ wrapper facade for the socket &lt;fd_set&gt; abstraction</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Handle__Set__Iterator.html">ACE_Handle_Set_Iterator</a></td><td>Iterator for the &lt;<a class="el" href="classACE__Handle__Set.html">ACE_Handle_Set</a>&gt; abstraction</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Handler.html">ACE_Handler</a></td><td>This base class defines the interface for receiving the results of asynchronous operations</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Handler__Caching__Utility.html">ACE_Handler_Caching_Utility&lt; KEY, VALUE, CONTAINER, ITERATOR, ATTRIBUTES &gt;</a></td><td>Defines a helper class for the Caching Strategies</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Handler__Cleanup__Strategy.html">ACE_Handler_Cleanup_Strategy&lt; KEY, VALUE, CONTAINER &gt;</a></td><td>Defines a strategy to be followed for cleaning up entries which are svc_handlers from a container</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Hash.html">ACE_Hash&lt; TYPE &gt;</a></td><td>Function object for hashing</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Hash_3_01char_01_4.html">ACE_Hash&lt; char &gt;</a></td><td>Function object for hashing a char</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Hash__Cache__Map__Manager.html">ACE_Hash_Cache_Map_Manager&lt; KEY, VALUE, HASH_KEY, COMPARE_KEYS, CACHING_STRATEGY, ATTRIBUTES &gt;</a></td><td>Defines a abstraction which will purge entries from a map. The map considered is the <a class="el" href="classACE__Hash__Map__Manager__Ex.html">ACE_Hash_Map_Manager_Ex</a></td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Hash__Map__Bucket__Iterator.html">ACE_Hash_Map_Bucket_Iterator&lt; EXT_ID, INT_ID, HASH_KEY, COMPARE_KEYS, ACE_LOCK &gt;</a></td><td>Forward iterator for the &lt;<a class="el" href="classACE__Hash__Map__Manager__Ex.html">ACE_Hash_Map_Manager_Ex</a>&gt; which only traverses a particular bucket. The particular bucket is specified by the &lt;EXT_ID&gt; parameter specified in the constructor</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Hash__Map__Const__Iterator.html">ACE_Hash_Map_Const_Iterator&lt; EXT_ID, INT_ID, ACE_LOCK &gt;</a></td><td>Wrapper for backward compatibility</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Hash__Map__Const__Iterator__Base__Ex.html">ACE_Hash_Map_Const_Iterator_Base_Ex&lt; EXT_ID, INT_ID, HASH_KEY, COMPARE_KEYS, ACE_LOCK &gt;</a></td><td>Base const iterator for the &lt;<a class="el" href="classACE__Hash__Map__Manager__Ex.html">ACE_Hash_Map_Manager_Ex</a>&gt;</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Hash__Map__Const__Iterator__Ex.html">ACE_Hash_Map_Const_Iterator_Ex&lt; EXT_ID, INT_ID, HASH_KEY, COMPARE_KEYS, ACE_LOCK &gt;</a></td><td>Const forward iterator for the &lt;<a class="el" href="classACE__Hash__Map__Manager__Ex.html">ACE_Hash_Map_Manager_Ex</a>&gt;</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Hash__Map__Entry.html">ACE_Hash_Map_Entry&lt; EXT_ID, INT_ID &gt;</a></td><td>Define an entry in the hash table</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Hash__Map__Iterator.html">ACE_Hash_Map_Iterator&lt; EXT_ID, INT_ID, ACE_LOCK &gt;</a></td><td>Wrapper for backward compatibility</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Hash__Map__Iterator__Base__Ex.html">ACE_Hash_Map_Iterator_Base_Ex&lt; EXT_ID, INT_ID, HASH_KEY, COMPARE_KEYS, ACE_LOCK &gt;</a></td><td>Base iterator for the &lt;<a class="el" href="classACE__Hash__Map__Manager__Ex.html">ACE_Hash_Map_Manager_Ex</a>&gt;</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Hash__Map__Iterator__Ex.html">ACE_Hash_Map_Iterator_Ex&lt; EXT_ID, INT_ID, HASH_KEY, COMPARE_KEYS, ACE_LOCK &gt;</a></td><td>Forward iterator for the &lt;<a class="el" href="classACE__Hash__Map__Manager__Ex.html">ACE_Hash_Map_Manager_Ex</a>&gt;</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Hash__Map__Manager.html">ACE_Hash_Map_Manager&lt; EXT_ID, INT_ID, ACE_LOCK &gt;</a></td><td>Wrapper for backward compatibility</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Hash__Map__Manager__Ex.html">ACE_Hash_Map_Manager_Ex&lt; EXT_ID, INT_ID, HASH_KEY, COMPARE_KEYS, ACE_LOCK &gt;</a></td><td>Define a map abstraction that efficiently associates &lt;EXT_ID&gt;s with &lt;INT_ID&gt;s</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Hash__Map__Manager__Ex__Adapter.html">ACE_Hash_Map_Manager_Ex_Adapter&lt; KEY, VALUE, HASH_KEY, COMPARE_KEYS, KEY_GENERATOR &gt;</a></td><td>Defines a map implementation</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Hash__Map__Manager__Ex__Iterator__Adapter.html">ACE_Hash_Map_Manager_Ex_Iterator_Adapter&lt; T, KEY, VALUE, HASH_KEY, COMPARE_KEYS &gt;</a></td><td>Defines a iterator implementation for the Hash_Map_Manager_Adapter</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Hash__Map__Manager__Ex__Reverse__Iterator__Adapter.html">ACE_Hash_Map_Manager_Ex_Reverse_Iterator_Adapter&lt; T, KEY, VALUE, HASH_KEY, COMPARE_KEYS &gt;</a></td><td>Defines a reverse iterator implementation for the Hash_Map_Manager_Adapter</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Hash__Map__Reverse__Iterator.html">ACE_Hash_Map_Reverse_Iterator&lt; EXT_ID, INT_ID, ACE_LOCK &gt;</a></td><td>Wrapper for backward compatibility</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Hash__Map__Reverse__Iterator__Ex.html">ACE_Hash_Map_Reverse_Iterator_Ex&lt; EXT_ID, INT_ID, HASH_KEY, COMPARE_KEYS, ACE_LOCK &gt;</a></td><td>Reverse iterator for the &lt;<a class="el" href="classACE__Hash__Map__Manager__Ex.html">ACE_Hash_Map_Manager_Ex</a>&gt;</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Hash__Map__With__Allocator.html">ACE_Hash_Map_With_Allocator&lt; EXT_ID, INT_ID &gt;</a></td><td>This class is a thin wrapper around <a class="el" href="classACE__Hash__Map__Manager.html">ACE_Hash_Map_Manager</a>, which comes handy when <a class="el" href="classACE__Hash__Map__Manager.html">ACE_Hash_Map_Manager</a> is to be used with a non-nil <a class="el" href="classACE__Allocator.html">ACE_Allocator</a>. This wrapper insures that the appropriate allocator is in place for every operation that accesses or updates the hash map</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Hashable.html">ACE_Hashable</a></td><td>ACE_Hashable</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__High__Res__Timer.html">ACE_High_Res_Timer</a></td><td>A high resolution timer class wrapper that encapsulates OS-specific high-resolution timers, such as those found on Solaris, AIX, Win32/Pentium, and VxWorks</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Incremental__Key__Generator.html">ACE_Incremental_Key_Generator&lt; T &gt;</a></td><td>Defines a simple incremental key generator</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__INET__Addr.html">ACE_INET_Addr</a></td><td>Defines a C++ wrapper facade for the Internet domain address family format</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Ini__ImpExp.html">ACE_Ini_ImpExp</a></td><td>Imports the configuration database from filename as strings. Allows non-typed values. (no #, dword: hex:, etc. prefixes) and skips whitespace (tabs and spaces) as in standard .ini and .conf files. Values (to right of equal sign) can be double quote delimited to embed tabs and spaces in the string. Caller must convert string to type</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Init__ACE.html">ACE_Init_ACE</a></td><td>Initialize <a class="el" href="classACE.html">ACE</a> library services. Can be called only once per program invocation</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__InputCDR.html">ACE_InputCDR</a></td><td>A CDR stream for reading, i.e. for demarshalling</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="structACE__InputCDR_1_1to__boolean.html">ACE_InputCDR::to_boolean</a></td><td></td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="structACE__InputCDR_1_1to__char.html">ACE_InputCDR::to_char</a></td><td></td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="structACE__InputCDR_1_1to__octet.html">ACE_InputCDR::to_octet</a></td><td></td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="structACE__InputCDR_1_1to__string.html">ACE_InputCDR::to_string</a></td><td></td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="structACE__InputCDR_1_1to__wchar.html">ACE_InputCDR::to_wchar</a></td><td></td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="structACE__InputCDR_1_1to__wstring.html">ACE_InputCDR::to_wstring</a></td><td></td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="structACE__InputCDR_1_1Transfer__Contents.html">ACE_InputCDR::Transfer_Contents</a></td><td>Helper class to transfer the contents from one input CDR to another without requiring any extra memory allocations, data copies or too many temporaries</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__IntCapEntry.html">ACE_IntCapEntry</a></td><td>This class implement the <a class="el" href="classACE.html">ACE</a> Integer Capability subclass</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Intrusive__List.html">ACE_Intrusive_List&lt; T &gt;</a></td><td>Implement an intrusive double linked list</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Intrusive__List__Node.html">ACE_Intrusive_List_Node&lt; T &gt;</a></td><td>Implement the requirements for <a class="el" href="classACE__Intrusive__List.html">ACE_Intrusive_List</a></td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__IO__Cntl__Msg.html">ACE_IO_Cntl_Msg</a></td><td>Data format for IOCTL messages</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__IO__SAP.html">ACE_IO_SAP</a></td><td>Defines the methods for the base class of the &lt;ACE_IO_SAP&gt; abstraction, which includes &lt;<a class="el" href="classACE__FILE.html">ACE_FILE</a>&gt; and &lt;<a class="el" href="classACE__DEV.html">ACE_DEV</a>&gt;</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__IOStream.html">ACE_IOStream&lt; STREAM &gt;</a></td><td>A template adapter for creating an iostream-like object using an <a class="el" href="classACE.html">ACE</a> IPC Stream for the actual I/O. Iostreams use an underlying streambuf object for the IO interface. The iostream class and derivatives provide you with a host of convenient operators that access the streambuf</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__IPC__SAP.html">ACE_IPC_SAP</a></td><td>Defines the member functions for the base class of the ACE_IPC_SAP abstraction</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Iterator.html">ACE_Iterator&lt; T &gt;</a></td><td>Defines the iterator interface</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Iterator__Impl.html">ACE_Iterator_Impl&lt; T &gt;</a></td><td>Defines a abstract iterator</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Laxity__Message__Strategy.html">ACE_Laxity_Message_Strategy</a></td><td>Laxity based message priority strategy</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Less__Than.html">ACE_Less_Than&lt; TYPE &gt;</a></td><td>Function object for determining whether the first object of the given type is less than the second object of the same type</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__LFU__Caching__Strategy.html">ACE_LFU_Caching_Strategy&lt; ATTRIBUTES, CACHING_UTILITY &gt;</a></td><td>Defines a Least Frequently Used strategy for which will decide on the item to be removed from the cache</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Lib__Find.html">ACE_Lib_Find</a></td><td></td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Lite__MMAP__Memory__Pool.html">ACE_Lite_MMAP_Memory_Pool</a></td><td>Make a ``lighter-weight'' memory pool based &lt;<a class="el" href="classACE__Mem__Map.html">ACE_Mem_Map</a>&gt;</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Local__Memory__Pool.html">ACE_Local_Memory_Pool</a></td><td>Make a memory pool that is based on C++ new/delete. This is useful for integrating existing components that use new/delete into the <a class="el" href="classACE.html">ACE</a> Malloc scheme..</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Local__Memory__Pool__Options.html">ACE_Local_Memory_Pool_Options</a></td><td>Helper class for Local Memory Pool constructor options</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Local__Mutex.html">ACE_Local_Mutex</a></td><td>Class that acquires, renews, and releases a synchronization token local to the process</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Local__Name__Space.html">ACE_Local_Name_Space&lt;, ACE_LOCK &gt;</a></td><td>Maintaining accesses Local Name Server Database. Allows to add NameBindings, change them, remove them and resolve NameBindings</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Local__RLock.html">ACE_Local_RLock</a></td><td>Class that acquires, renews, and releases a readers lock that is local to the process</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Local__WLock.html">ACE_Local_WLock</a></td><td>Class that acquires, renews, and releases a writer lock that is local to the process</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Location__Node.html">ACE_Location_Node</a></td><td>Keep track of where a shared library is located</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Lock.html">ACE_Lock</a></td><td>This is the abstract base class that contains the uniform locking API that is supported by all the <a class="el" href="classACE.html">ACE</a> synchronization mechanisms</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Lock__Adapter.html">ACE_Lock_Adapter&lt; ACE_LOCKING_MECHANISM &gt;</a></td><td>This is an adapter that allows applications to transparently combine the &lt;<a class="el" href="classACE__Lock.html">ACE_Lock</a>&gt; abstract base class (which contains pure virtual methods) with any of the other concrete <a class="el" href="classACE.html">ACE</a> synchronization classes (e.g., &lt;<a class="el" href="classACE__Mutex.html">ACE_Mutex</a>&gt;, &lt;<a class="el" href="classACE__Semaphore.html">ACE_Semaphore</a>&gt;, &lt;<a class="el" href="classACE__RW__Mutex.html">ACE_RW_Mutex</a>&gt;, etc.)</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__LOCK__SOCK__Acceptor.html">ACE_LOCK_SOCK_Acceptor&lt; ACE_LOCK &gt;</a></td><td>Specialize &lt;<a class="el" href="classACE__SOCK__Acceptor.html">ACE_SOCK_Acceptor</a>&gt; to lock around &lt;accept&gt;;</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Locked__Data__Block.html">ACE_Locked_Data_Block&lt; ACE_LOCK &gt;</a></td><td>A Data_Block with a concrete locking strategy</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Locked__Free__List.html">ACE_Locked_Free_List&lt; T, ACE_LOCK &gt;</a></td><td>Implements a free list</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Log__Msg.html">ACE_Log_Msg</a></td><td>Provides a variable length argument message logging abstraction</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Log__Msg__Backend.html">ACE_Log_Msg_Backend</a></td><td>Define the interface for <a class="el" href="classACE__Log__Msg.html">ACE_Log_Msg</a> backend strategies</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Log__Msg__Callback.html">ACE_Log_Msg_Callback</a></td><td>An interface class used to get logging callbacks</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Log__Msg__IPC.html">ACE_Log_Msg_IPC</a></td><td>Defines the interfaces for <a class="el" href="classACE__Log__Msg.html">ACE_Log_Msg</a> backend</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Log__Msg__Manager.html">ACE_Log_Msg_Manager</a></td><td>Synchronize output operations</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Log__Record.html">ACE_Log_Record</a></td><td>Defines the structure of an <a class="el" href="classACE.html">ACE</a> logging record</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Logging__Strategy.html">ACE_Logging_Strategy</a></td><td>This class provides the hooks to control the output produced by any of the network services</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__LRU__Caching__Strategy.html">ACE_LRU_Caching_Strategy&lt; ATTRIBUTES, CACHING_UTILITY &gt;</a></td><td>Defines a Least Recently Used strategy which will decide on the item to be removed from the cache</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__LSOCK.html">ACE_LSOCK</a></td><td>Create a Local <a class="el" href="classACE__SOCK.html">ACE_SOCK</a>, which is used for passing file descriptors</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__LSOCK__Acceptor.html">ACE_LSOCK_Acceptor</a></td><td>Defines the format and interface for the acceptor side of the local <a class="el" href="classACE__SOCK.html">ACE_SOCK</a> <a class="el" href="classACE__Stream.html">ACE_Stream</a></td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__LSOCK__CODgram.html">ACE_LSOCK_CODgram</a></td><td>Defines the member functions for the &lt;<a class="el" href="classACE__LSOCK.html">ACE_LSOCK</a>&gt; connected datagram abstraction</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__LSOCK__Connector.html">ACE_LSOCK_Connector</a></td><td>Defines the format and interface for the connector side of the &lt;<a class="el" href="classACE__LSOCK__Stream.html">ACE_LSOCK_Stream</a>&gt;</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__LSOCK__Dgram.html">ACE_LSOCK_Dgram</a></td><td>Create a Local <a class="el" href="classACE__SOCK.html">ACE_SOCK</a> datagram</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__LSOCK__Stream.html">ACE_LSOCK_Stream</a></td><td>Create a Local <a class="el" href="classACE__SOCK.html">ACE_SOCK</a> stream</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Malloc.html">ACE_Malloc&lt;, ACE_LOCK &gt;</a></td><td></td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Malloc__FIFO__Iterator.html">ACE_Malloc_FIFO_Iterator&lt;, ACE_LOCK &gt;</a></td><td></td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Malloc__FIFO__Iterator__T.html">ACE_Malloc_FIFO_Iterator_T&lt;, ACE_LOCK, ACE_CB &gt;</a></td><td>FIFO iterator for names stored in Malloc'd memory</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Malloc__LIFO__Iterator.html">ACE_Malloc_LIFO_Iterator&lt;, ACE_LOCK &gt;</a></td><td></td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Malloc__LIFO__Iterator__T.html">ACE_Malloc_LIFO_Iterator_T&lt;, ACE_LOCK, ACE_CB &gt;</a></td><td>LIFO iterator for names stored in Malloc'd memory</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Malloc__T.html">ACE_Malloc_T&lt;, ACE_LOCK, ACE_CB &gt;</a></td><td>Define a C++ class that uses parameterized types to provide an extensible mechanism for encapsulating various of dynamic memory management strategies</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Managed__Object.html">ACE_Managed_Object&lt; TYPE &gt;</a></td><td>Wrapper for interface to allocate an object managed by the <a class="el" href="classACE__Object__Manager.html">ACE_Object_Manager</a></td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Managed__Process.html">ACE_Managed_Process</a></td><td>A process easily managed by <a class="el" href="classACE__Process__Manager.html">ACE_Process_Manager</a></td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Manual__Event.html">ACE_Manual_Event</a></td><td>Manual Events</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Map.html">ACE_Map&lt; KEY, VALUE &gt;</a></td><td>Defines a map interface</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Map__Const__Iterator.html">ACE_Map_Const_Iterator&lt; EXT_ID, INT_ID, ACE_LOCK &gt;</a></td><td>Forward const iterator for the <a class="el" href="classACE__Map__Manager.html">ACE_Map_Manager</a></td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Map__Const__Iterator__Base.html">ACE_Map_Const_Iterator_Base&lt; EXT_ID, INT_ID, ACE_LOCK &gt;</a></td><td>Const iterator for the <a class="el" href="classACE__Map__Manager.html">ACE_Map_Manager</a></td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Map__Entry.html">ACE_Map_Entry&lt; EXT_ID, INT_ID &gt;</a></td><td>An entry in the Map</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Map__Impl.html">ACE_Map_Impl&lt; KEY, VALUE, IMPLEMENTATION, ITERATOR, REVERSE_ITERATOR, ENTRY &gt;</a></td><td>Defines a map implementation</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Map__Impl__Iterator__Adapter.html">ACE_Map_Impl_Iterator_Adapter&lt; T, IMPLEMENTATION, ENTRY &gt;</a></td><td>Defines a iterator implementation for the Map_Impl class</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Map__Impl__Reverse__Iterator__Adapter.html">ACE_Map_Impl_Reverse_Iterator_Adapter&lt; T, IMPLEMENTATION, ENTRY &gt;</a></td><td>Defines a reverse iterator implementation for the Map_Impl class</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Map__Iterator.html">ACE_Map_Iterator&lt; EXT_ID, INT_ID, ACE_LOCK &gt;</a></td><td>Forward iterator for the <a class="el" href="classACE__Map__Manager.html">ACE_Map_Manager</a></td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Map__Iterator__Base.html">ACE_Map_Iterator_Base&lt; EXT_ID, INT_ID, ACE_LOCK &gt;</a></td><td>Iterator for the <a class="el" href="classACE__Map__Manager.html">ACE_Map_Manager</a></td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Map__Manager.html">ACE_Map_Manager&lt; EXT_ID, INT_ID, ACE_LOCK &gt;</a></td><td>Define a map abstraction that associates &lt;EXT_ID&gt;s with &lt;INT_ID&gt;s</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Map__Manager__Adapter.html">ACE_Map_Manager_Adapter&lt; KEY, VALUE, KEY_GENERATOR &gt;</a></td><td>Defines a map implementation</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Map__Manager__Iterator__Adapter.html">ACE_Map_Manager_Iterator_Adapter&lt; T, KEY, VALUE &gt;</a></td><td>Defines a iterator implementation for the Map_Manager_Adapter</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Map__Manager__Reverse__Iterator__Adapter.html">ACE_Map_Manager_Reverse_Iterator_Adapter&lt; T, KEY, VALUE &gt;</a></td><td>Defines a reverse iterator implementation for the Map Manager</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Map__Reverse__Iterator.html">ACE_Map_Reverse_Iterator&lt; EXT_ID, INT_ID, ACE_LOCK &gt;</a></td><td>Reverse Iterator for the &lt;<a class="el" href="classACE__Map__Manager.html">ACE_Map_Manager</a>&gt;</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__MEM__Acceptor.html">ACE_MEM_Acceptor</a></td><td>Defines the format and interface for the acceptor side of the local mmap stream</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__MEM__Addr.html">ACE_MEM_Addr</a></td><td>Defines a C++ wrapper facade for the shared memory transport address family format</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__MEM__Connector.html">ACE_MEM_Connector</a></td><td>Defines the format and interface for connecting to a peer on a <code><a class="el" href="classACE__MEM__Stream.html">ACE_MEM_Stream</a></code> object</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__MEM__IO.html">ACE_MEM_IO</a></td><td>Defines the methods for the <a class="el" href="classACE.html">ACE</a> shared memeory wrapper I/O routines (e.g., send/recv). The shared memory transport uses ACE_SOCK_* class to implement the signaling mechanism so we can easily use the new mechanism with the Reactor pattern (which uses select under the hood.) <a class="el" href="classACE__MEM__Acceptor.html">ACE_MEM_Acceptor</a> and <a class="el" href="classACE__MEM__Connector.html">ACE_MEM_Connector</a> are used to establish connections. When a connection is established, <a class="el" href="classACE__MEM__Acceptor.html">ACE_MEM_Acceptor</a> creates the MMAP file for data exchange and sends the location of the file (complete path name) to <a class="el" href="classACE__MEM__Connector.html">ACE_MEM_Connector</a> thru the socket. <a class="el" href="classACE__MEM__Connector.html">ACE_MEM_Connector</a> then reads the location of the file off the socket and opens up the same MMAP file. <a class="el" href="classACE__MEM__Stream.html">ACE_MEM_Stream</a> at each side then contains a reference to the ACE_Mallo object using the same MMAP file. When sending information using methods provided in this class, ACE_MEM_IO requests a chunk of memory from the MALLOC_TYPE object, copy the data into the shared memory and send the memory offset (from the start of the <a class="el" href="classACE__Malloc.html">ACE_Malloc</a>) across the socket. This action also servers as a signal to the other end. The receiving side then reverses the procedures and copies the information into user buffer</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Mem__Map.html">ACE_Mem_Map</a></td><td>C++ interface OS memory mapping system call</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__MEM__SAP.html">ACE_MEM_SAP</a></td><td>Defines the methods of shared memory management for shared memory transport</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__MEM__SAP__Node.html">ACE_MEM_SAP_Node</a></td><td></td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__MEM__Stream.html">ACE_MEM_Stream</a></td><td>Defines the methods in the &lt;ACE_MEM_Stream&gt; abstraction</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Message__Block.html">ACE_Message_Block</a></td><td>Stores messages for use throughout <a class="el" href="classACE.html">ACE</a> (particularly &lt;<a class="el" href="classACE__Message__Queue.html">ACE_Message_Queue</a>&gt;)</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Message__Queue.html">ACE_Message_Queue&lt;&gt;</a></td><td>A threaded message queueing facility, modeled after the queueing facilities in System V STREAMs</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Message__Queue__Base.html">ACE_Message_Queue_Base</a></td><td>Base class for &lt;<a class="el" href="classACE__Message__Queue.html">ACE_Message_Queue</a>&gt;, which is the central queueing facility for messages in the <a class="el" href="classACE.html">ACE</a> framework</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Message__Queue__Ex.html">ACE_Message_Queue_Ex&lt; ACE_MESSAGE_TYPE, &gt;</a></td><td>A threaded message queueing facility, modeled after the queueing facilities in System V STREAMs</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Message__Queue__Factory.html">ACE_Message_Queue_Factory&lt;&gt;</a></td><td>ACE_Message_Queue_Factory is a static factory class template which provides a separate factory method for each of the major kinds of priority based message dispatching: static, earliest deadline first (EDF), and minimum laxity first (MLF)</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Message__Queue__Iterator.html">ACE_Message_Queue_Iterator&lt;&gt;</a></td><td>Iterator for the &lt;<a class="el" href="classACE__Message__Queue.html">ACE_Message_Queue</a>&gt;</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Message__Queue__Reverse__Iterator.html">ACE_Message_Queue_Reverse_Iterator&lt;&gt;</a></td><td>Reverse Iterator for the &lt;<a class="el" href="classACE__Message__Queue.html">ACE_Message_Queue</a>&gt;</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Method__Request.html">ACE_Method_Request</a></td><td>Reifies a method into a request. Subclasses must provide the necessary state and behavior</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__MMAP__Memory__Pool.html">ACE_MMAP_Memory_Pool</a></td><td>Make a memory pool that is based on &lt;mmap(2)&gt;. This implementation allows memory to be shared between processes</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__MMAP__Memory__Pool__Options.html">ACE_MMAP_Memory_Pool_Options</a></td><td>Helper class for MMAP Memory Pool constructor options</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Module.html">ACE_Module&lt;&gt;</a></td><td>An abstraction for managing a bi-directional flow of messages</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Module__Base.html">ACE_Module_Base</a></td><td>Workaround HP/C++ compiler bug with enums in templates</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Module__Type.html">ACE_Module_Type</a></td><td>Define the methods for handling the configuration of &lt;ACE_Modules&gt;</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Msg__WFMO__Reactor.html">ACE_Msg_WFMO_Reactor</a></td><td>An OO event demultiplexor and event handler dispatcher for Win32 &lt;MsgWaitForMultipleObjects&gt;</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__MT__MEM__IO.html">ACE_MT_MEM_IO</a></td><td></td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="structACE__MT__MEM__IO_1_1Channel.html">ACE_MT_MEM_IO::Channel</a></td><td></td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="structACE__MT__MEM__IO_1_1MQ__Struct.html">ACE_MT_MEM_IO::MQ_Struct</a></td><td></td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__MT__MEM__IO_1_1Simple__Queue.html">ACE_MT_MEM_IO::Simple_Queue</a></td><td></td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__MT__SYNCH.html">ACE_MT_SYNCH</a></td><td>Implement a default thread safe synchronization wrapper that typedefs the &lt;<a class="el" href="classACE__Condition.html">ACE_Condition</a>&gt; and &lt;<a class="el" href="classACE__Mutex.html">ACE_Mutex</a>&gt; to the &lt;<a class="el" href="classACE__Condition.html">ACE_Condition</a>&gt; and &lt;<a class="el" href="classACE__Mutex.html">ACE_Mutex</a>&gt; versions. Note that this should be a template, but SunC++ 4.0.1 complains about this..</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Mutex.html">ACE_Mutex</a></td><td>&lt;ACE_Mutex&gt; wrapper (valid in same process or across processes (depending on TYPE flag))</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Mutex__Invariants.html">ACE_Mutex_Invariants</a></td><td>Mutex Invariants = INVARIANTS 1. Only one owner at a time</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Mutex__Token.html">ACE_Mutex_Token</a></td><td>Class that acquires, renews, and releases a process-local synchronization token</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Name__Binding.html">ACE_Name_Binding</a></td><td>Maintains a mapping from name to value and type</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Name__Options.html">ACE_Name_Options</a></td><td>Manages the options for the <a class="el" href="classACE.html">ACE</a> Name_Server</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Name__Proxy.html">ACE_Name_Proxy</a></td><td>Proxy for dealing with remote server process managing NET_LOCAL NameBindings</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Name__Reply.html">ACE_Name_Reply</a></td><td>Message format for delivering replies from the ACE_Name Server</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="structACE__Name__Reply_1_1Transfer.html">ACE_Name_Reply::Transfer</a></td><td></td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Name__Request.html">ACE_Name_Request</a></td><td>Message format for delivering requests to the ACE_Name Server</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="structACE__Name__Request_1_1Transfer.html">ACE_Name_Request::Transfer</a></td><td></td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Name__Space.html">ACE_Name_Space</a></td><td>Abstract base class that provides an abstract interface to the database without exposing any implemenation details</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Name__Space__Map.html">ACE_Name_Space_Map&lt; ALLOCATOR &gt;</a></td><td>This class serves as a Proxy that ensures our process always has the appropriate allocator in place for every operation that accesses or updates the Map Manager</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Naming__Context.html">ACE_Naming_Context</a></td><td>Maintaining accesses Name Server Databases. Allows to add NameBindings, change them, remove them and resolve NameBindings</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__New__Allocator.html">ACE_New_Allocator</a></td><td>Defines a class that provided a simple implementation of memory allocation</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Node.html">ACE_Node&lt; T &gt;</a></td><td>Implementation element in a Queue, Set, and Stack</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__NOOP__Concurrency__Strategy.html">ACE_NOOP_Concurrency_Strategy&lt; SVC_HANDLER &gt;</a></td><td>Implements a no-op activation strategy in order to avoid calling open on a svc_handler multiple times</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__NOOP__Creation__Strategy.html">ACE_NOOP_Creation_Strategy&lt; SVC_HANDLER &gt;</a></td><td>Implements a no-op creation strategy in order to defer decisions regarding creation to some later point in time, such as in connect or accept strategy</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Noop__Key__Generator.html">ACE_Noop_Key_Generator&lt; T &gt;</a></td><td>Defines a noop key generator</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Noop__Token.html">ACE_Noop_Token</a></td><td></td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Notification__Buffer.html">ACE_Notification_Buffer</a></td><td>Simple wrapper for passing &lt;<a class="el" href="classACE__Event__Handler.html">ACE_Event_Handler</a> *&gt;s and &lt;ACE_Reactor_Mask&gt;s between threads</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Notification__Strategy.html">ACE_Notification_Strategy</a></td><td>Abstract class used for notifying an interested party</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__NS__Internal.html">ACE_NS_Internal</a></td><td>This class and <a class="el" href="classACE__NS__String.html">ACE_NS_String</a> are used as Adapters to work with the Map_Manager</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__NS__String.html">ACE_NS_String</a></td><td>This class and <a class="el" href="classACE__NS__Internal.html">ACE_NS_Internal</a> are used as Adapters to work with the Map_Manager</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__NS__WString.html">ACE_NS_WString</a></td><td>This class retain the backward compatibility for Naming_Conext and related classes. The only addition to ACE_WString is a very naive "wchar" to "char" conversion function</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__NT__Service.html">ACE_NT_Service</a></td><td>Provide the base class which defines the interface for controlling an NT service</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Null__Barrier.html">ACE_Null_Barrier</a></td><td>Implements "NULL barrier synchronization"</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Null__Caching__Strategy.html">ACE_Null_Caching_Strategy&lt; ATTRIBUTES, CACHING_UTILITY &gt;</a></td><td>The is a special caching strategy which doesnt have the purging feature</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Null__Caching__Utility.html">ACE_Null_Caching_Utility&lt; KEY, VALUE, CONTAINER, ITERATOR, ATTRIBUTES &gt;</a></td><td>Defines a dummy helper class for the Caching Strategies</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Null__Cleanup__Strategy.html">ACE_Null_Cleanup_Strategy&lt; KEY, VALUE, CONTAINER &gt;</a></td><td>Defines a do-nothing implementation of the cleanup strategy</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Null__Condition.html">ACE_Null_Condition</a></td><td>Implement a do nothing &lt;<a class="el" href="classACE__Condition.html">ACE_Condition</a>&gt; variable wrapper, i.e., all methods are no ops. This class is necessary since some C++ compilers are *very* lame..</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Null__Mutex.html">ACE_Null_Mutex</a></td><td>Implement a do nothing &lt;<a class="el" href="classACE__Mutex.html">ACE_Mutex</a>&gt;, i.e., all the methods are no ops</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Null__Semaphore.html">ACE_Null_Semaphore</a></td><td>Implement a do nothing &lt;<a class="el" href="classACE__Semaphore.html">ACE_Semaphore</a>&gt;, i.e., all the methods are no ops</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__NULL__SYNCH.html">ACE_NULL_SYNCH</a></td><td>Implement a do nothing Synchronization wrapper that typedefs the &lt;<a class="el" href="classACE__Condition.html">ACE_Condition</a>&gt; and &lt;<a class="el" href="classACE__Mutex.html">ACE_Mutex</a>&gt; to the Null* versions</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Null__Token.html">ACE_Null_Token</a></td><td>No op class for nonthreaded platform protocols</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Obchunk.html">ACE_Obchunk</a></td><td>Defines the state that represents a "chunk" of memory. Evenything in this class is public because it is designed as an internal structure of Obstack_T and users are not supposed to use this class directly</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Object__Manager.html">ACE_Object_Manager</a></td><td>Manager for <a class="el" href="classACE.html">ACE</a> library services and singleton cleanup</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Object__Manager__Base.html">ACE_Object_Manager_Base</a></td><td>Base class for ACE_Object_Manager(s)</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Object__Manager__Manager.html">ACE_Object_Manager_Manager</a></td><td>Ensure that the &lt;<a class="el" href="classACE__Object__Manager.html">ACE_Object_Manager</a>&gt; gets initialized at program startup, and destroyed at program termination</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Object__Manager__Preallocations.html">ACE_Object_Manager_Preallocations</a></td><td>Performs preallocations of certain statically allocated services needed by <a class="el" href="classACE.html">ACE</a></td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Object__Node.html">ACE_Object_Node</a></td><td>Keeps track of the symbol name for a shared object</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Obstack.html">ACE_Obstack</a></td><td>Define a simple "mark and release" memory allocation utility</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Obstack__T.html">ACE_Obstack_T&lt; CHAR &gt;</a></td><td></td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__ODB.html">ACE_ODB</a></td><td>This is the object database (ODB) that keeps track of all live <a class="el" href="classACE.html">ACE</a> objects</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="structACE__ODB_1_1Tuple.html">ACE_ODB::Tuple</a></td><td></td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Oneshot__Acceptor.html">ACE_Oneshot_Acceptor&lt; SVC_HANDLER, &gt;</a></td><td>Generic factory for passively connecting clients and creating exactly one service handler (SVC_HANDLER)</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Ordered__MultiSet.html">ACE_Ordered_MultiSet&lt; T &gt;</a></td><td>Implement a simple ordered multiset of &lt;T&gt; of unbounded size that allows duplicates. This class template requires that &lt; operator semantics be defined for the parameterized type &lt;T&gt;, but does not impose any restriction on how that ordering operator is implemented. The set is implemented as a linked list</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Ordered__MultiSet__Iterator.html">ACE_Ordered_MultiSet_Iterator&lt; T &gt;</a></td><td>Implement a bidirectional iterator over an ordered multiset. This class template requires that &lt; operator semantics be defined for the parameterized type &lt;T&gt;, but does not impose any restriction on how that ordering operator is implemented</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__OS.html">ACE_OS</a></td><td>This class defines an OS independent programming API that shields developers from nonportable aspects of writing efficient system programs on Win32, POSIX and other versions of UNIX, and various real-time operating systems</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__OS_1_1ace__flock__t.html">ACE_OS::ace_flock_t</a></td><td>OS file locking structure</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__OS__Dirent.html">ACE_OS_Dirent</a></td><td>This class is a wrapper for the dirent.h operations</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__OS__Exit__Info.html">ACE_OS_Exit_Info</a></td><td>Hold Object Manager cleanup (exit) information</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__OS__Log__Msg__Attributes.html">ACE_OS_Log_Msg_Attributes</a></td><td>The attributes required by <a class="el" href="classACE__Log__Msg.html">ACE_Log_Msg</a></td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__OS__Memory.html">ACE_OS_Memory</a></td><td>This class is a wrapper for dynamic memory operations</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__OS__Object__Manager.html">ACE_OS_Object_Manager</a></td><td></td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__OS__Object__Manager__Manager.html">ACE_OS_Object_Manager_Manager</a></td><td>Ensure that the &lt;<a class="el" href="classACE__OS__Object__Manager.html">ACE_OS_Object_Manager</a>&gt; gets initialized at program startup, and destroyed at program termination</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__OS__String.html">ACE_OS_String</a></td><td>This class includes functions available in string.h and ctype.h</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__OS__Thread__Adapter.html">ACE_OS_Thread_Adapter</a></td><td>Converts a C++ function into a function that can be called from a thread creation routine (e.g., pthread_create() or _beginthreadex()) that expects an extern "C" entry point. This class also makes it possible to transparently provide hooks to register a thread with an <a class="el" href="classACE__Thread__Manager.html">ACE_Thread_Manager</a></td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__OS__Thread__Descriptor.html">ACE_OS_Thread_Descriptor</a></td><td>Parent class of all <a class="el" href="classACE__Thread__Descriptor.html">ACE_Thread_Descriptor</a> classes. = Container for <a class="el" href="classACE__Thread__Descriptor.html">ACE_Thread_Descriptor</a> members that are used in <a class="el" href="classACE__OS.html">ACE_OS</a></td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__OS__TLI.html">ACE_OS_TLI</a></td><td>This class is a wrapper for the TLI operations</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__OutputCDR.html">ACE_OutputCDR</a></td><td>A CDR stream for writing, i.e. for marshalling</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="structACE__OutputCDR_1_1from__boolean.html">ACE_OutputCDR::from_boolean</a></td><td></td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="structACE__OutputCDR_1_1from__char.html">ACE_OutputCDR::from_char</a></td><td></td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="structACE__OutputCDR_1_1from__octet.html">ACE_OutputCDR::from_octet</a></td><td></td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="structACE__OutputCDR_1_1from__string.html">ACE_OutputCDR::from_string</a></td><td></td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="structACE__OutputCDR_1_1from__wchar.html">ACE_OutputCDR::from_wchar</a></td><td></td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="structACE__OutputCDR_1_1from__wstring.html">ACE_OutputCDR::from_wstring</a></td><td></td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Pagefile__Memory__Pool.html">ACE_Pagefile_Memory_Pool</a></td><td>Make a memory pool that is based on "anonymous" memory regions allocated from the Win32 page file</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Pagefile__Memory__Pool_1_1Control__Block.html">ACE_Pagefile_Memory_Pool::Control_Block</a></td><td>Attributes that are meaningful in local storage only</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Pagefile__Memory__Pool_1_1Control__Block_1_1Shared__Control__Block.html">ACE_Pagefile_Memory_Pool::Control_Block::Shared_Control_Block</a></td><td>Pool statistics</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Pagefile__Memory__Pool__Options.html">ACE_Pagefile_Memory_Pool_Options</a></td><td>Helper class for Pagefile Memory Pool constructor options</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Pair.html">ACE_Pair&lt; T1, T2 &gt;</a></td><td>Defines a pair</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Pair__Caching__Utility.html">ACE_Pair_Caching_Utility&lt; KEY, VALUE, CONTAINER, ITERATOR, ATTRIBUTES &gt;</a></td><td>Defines a helper class for the Caching Strategies</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Parse__Node.html">ACE_Parse_Node</a></td><td>Provide the base of the object hierarchy that defines the parse tree of Service Nodes</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__PI__Control__Block.html">ACE_PI_Control_Block</a></td><td>This information is stored in memory allocated by the &lt;Memory_Pool&gt;</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__PI__Control__Block_1_1ACE__Malloc__Header.html">ACE_PI_Control_Block::ACE_Malloc_Header</a></td><td>This is the control block header. It's used by &lt;<a class="el" href="classACE__Malloc.html">ACE_Malloc</a>&gt; to keep track of each chunk of data when it's in the free list or in use</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__PI__Control__Block_1_1ACE__Name__Node.html">ACE_PI_Control_Block::ACE_Name_Node</a></td><td>This class supports "named memory regions" within &lt;<a class="el" href="classACE__Malloc.html">ACE_Malloc</a>&gt;</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Pipe.html">ACE_Pipe</a></td><td>Provides a bidirectional "pipe" abstraction that is portable to Windows NT, SVR4 UNIX, and BSD UNIX</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Pointer__Hash.html">ACE_Pointer_Hash&lt; TYPE &gt;</a></td><td>Function object for hashing pointers</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__POSIX____Asynch__Write__Dgram__Result.html">ACE_POSIX__Asynch_Write_Dgram_Result</a></td><td>This is class provides concrete implementation for <a class="el" href="classACE__Asynch__Write__Dgram_1_1Result.html">ACE_Asynch_Write_Dgram::Result</a> class</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__POSIX__AIOCB__Proactor.html">ACE_POSIX_AIOCB_Proactor</a></td><td>This Proactor makes use of Asynchronous I/O Control Blocks (AIOCB) to notify/get the completion status of the &lt;aio_&gt; operations issued</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__POSIX__Asynch__Accept.html">ACE_POSIX_Asynch_Accept</a></td><td>For the POSIX implementation this class is common for all Proactors (AIOCB/SIG/SUN)</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__POSIX__Asynch__Accept__Result.html">ACE_POSIX_Asynch_Accept_Result</a></td><td>This is that class which will be passed back to the &lt;handler&gt; when the asynchronous accept completes</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__POSIX__Asynch__Connect.html">ACE_POSIX_Asynch_Connect</a></td><td></td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__POSIX__Asynch__Connect__Result.html">ACE_POSIX_Asynch_Connect_Result</a></td><td>This is that class which will be passed back to the completion handler when the asynchronous connect completes</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__POSIX__Asynch__Operation.html">ACE_POSIX_Asynch_Operation</a></td><td>This class implements &lt;<a class="el" href="classACE__Asynch__Operation.html">ACE_Asynch_Operation</a>&gt; for all implementations of Proactor (AIOCB, SIG, SUN) Specific future implementations can derive from this class</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__POSIX__Asynch__Read__Dgram.html">ACE_POSIX_Asynch_Read_Dgram</a></td><td>This class is a factory for starting off asynchronous reads on a UDP socket</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__POSIX__Asynch__Read__Dgram__Result.html">ACE_POSIX_Asynch_Read_Dgram_Result</a></td><td>This is class provides concrete implementation for <a class="el" href="classACE__Asynch__Read__Dgram_1_1Result.html">ACE_Asynch_Read_Dgram::Result</a> class</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__POSIX__Asynch__Read__File.html">ACE_POSIX_Asynch_Read_File</a></td><td>This class is a factory for starting off asynchronous reads on a file. This class implements &lt;<a class="el" href="classACE__Asynch__Read__File.html">ACE_Asynch_Read_File</a>&gt; for all POSIX implementations of Proactor</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__POSIX__Asynch__Read__File__Result.html">ACE_POSIX_Asynch_Read_File_Result</a></td><td>This class provides concrete implementation for &lt;<a class="el" href="classACE__Asynch__Read__File_1_1Result.html">ACE_Asynch_Read_File::Result</a>&gt; class for POSIX platforms</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__POSIX__Asynch__Read__Stream.html">ACE_POSIX_Asynch_Read_Stream</a></td><td></td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__POSIX__Asynch__Read__Stream__Result.html">ACE_POSIX_Asynch_Read_Stream_Result</a></td><td>This class provides concrete implementation for &lt;<a class="el" href="classACE__Asynch__Read__Stream_1_1Result.html">ACE_Asynch_Read_Stream::Result</a>&gt; class for POSIX platforms</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__POSIX__Asynch__Result.html">ACE_POSIX_Asynch_Result</a></td><td></td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__POSIX__Asynch__Timer.html">ACE_POSIX_Asynch_Timer</a></td><td>This class is posted to the completion port when a timer expires. When the &lt;complete method&gt; of this object is called, the &lt;handler&gt;'s &lt;handle_timeout&gt; method will be called</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__POSIX__Asynch__Transmit__File.html">ACE_POSIX_Asynch_Transmit_File</a></td><td>Implementation for transmit_file will make use of POSIX_Asynch_Transmit_Handler</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__POSIX__Asynch__Transmit__File__Result.html">ACE_POSIX_Asynch_Transmit_File_Result</a></td><td>This is that class which will be passed back to the &lt;handler&gt; when the asynchronous transmit file completes</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__POSIX__Asynch__Transmit__Handler.html">ACE_POSIX_Asynch_Transmit_Handler</a></td><td>Auxillary handler for doing &lt;Asynch_Transmit_File&gt; in Unix. &lt;<a class="el" href="classACE__POSIX__Asynch__Transmit__File.html">ACE_POSIX_Asynch_Transmit_File</a>&gt; internally uses this</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__POSIX__Asynch__Write__Dgram.html">ACE_POSIX_Asynch_Write_Dgram</a></td><td>This class is a factory for starting off asynchronous writes on a UDP socket</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__POSIX__Asynch__Write__Dgram__Result.html">ACE_POSIX_Asynch_Write_Dgram_Result</a></td><td></td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__POSIX__Asynch__Write__File.html">ACE_POSIX_Asynch_Write_File</a></td><td></td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__POSIX__Asynch__Write__File__Result.html">ACE_POSIX_Asynch_Write_File_Result</a></td><td>This class provides implementation for &lt;ACE_Asynch_Write_File_Result&gt; for POSIX platforms</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__POSIX__Asynch__Write__Stream.html">ACE_POSIX_Asynch_Write_Stream</a></td><td>This class implements &lt;<a class="el" href="classACE__Asynch__Write__Stream.html">ACE_Asynch_Write_Stream</a>&gt; for all POSIX implementations of <a class="el" href="classACE__Proactor.html">ACE_Proactor</a></td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__POSIX__Asynch__Write__Stream__Result.html">ACE_POSIX_Asynch_Write_Stream_Result</a></td><td>This class provides concrete implementation for &lt;<a class="el" href="classACE__Asynch__Write__Stream_1_1Result.html">ACE_Asynch_Write_Stream::Result</a>&gt; on POSIX platforms</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__POSIX__CB__Proactor.html">ACE_POSIX_CB_Proactor</a></td><td>Implementation of Callback-based Proactor };</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__POSIX__Proactor.html">ACE_POSIX_Proactor</a></td><td>POSIX implementation of the Proactor</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__POSIX__Wakeup__Completion.html">ACE_POSIX_Wakeup_Completion</a></td><td></td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Predefined__Naming__Contexts.html">ACE_Predefined_Naming_Contexts</a></td><td>A factory for predefined registries, which exist by default on Win32 platforms</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Priority__Reactor.html">ACE_Priority_Reactor</a></td><td>Implements priority based dispatching</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Proactor.html">ACE_Proactor</a></td><td>A manager for asynchronous event demultiplexing</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Proactor__Handle__Timeout__Upcall.html">ACE_Proactor_Handle_Timeout_Upcall</a></td><td>Functor for &lt;ACE_Timer_Queue&gt;</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Proactor__Impl.html">ACE_Proactor_Impl</a></td><td>A manager for asynchronous event demultiplexing. This class is the base class for all the concrete implementation classes</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Proactor__Timer__Handler.html">ACE_Proactor_Timer_Handler</a></td><td>A Handler for timer. It helps in the management of timers registered with the Proactor</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Process.html">ACE_Process</a></td><td>Process</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Process__Descriptor.html">ACE_Process_Descriptor</a></td><td>Information describing each process that's controlled by an &lt;<a class="el" href="classACE__Process__Manager.html">ACE_Process_Manager</a>&gt;</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Process__Manager.html">ACE_Process_Manager</a></td><td>Manages a group of processes</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Process__Mutex.html">ACE_Process_Mutex</a></td><td>A wrapper for mutexes that can be used across processes on the same host machine, as well as within a process, of course</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Process__Options.html">ACE_Process_Options</a></td><td>Process Options</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Process__Semaphore.html">ACE_Process_Semaphore</a></td><td>Wrapper for Dijkstra style general semaphores that work across processes</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Process__Strategy.html">ACE_Process_Strategy&lt; SVC_HANDLER &gt;</a></td><td>Defines the interface for specifying a concurrency strategy for a &lt;SVC_HANDLER&gt; based on multiprocessing</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Profile__Timer.html">ACE_Profile_Timer</a></td><td>This class provides both a timing mechanism and a mechanism for reporting the resource usage of a process</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Profile__Timer_1_1ACE__Elapsed__Time.html">ACE_Profile_Timer::ACE_Elapsed_Time</a></td><td>Keeps track of the various user, system, and elapsed (real) times</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="structACE__Protocol__Info.html">ACE_Protocol_Info</a></td><td></td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__QoS.html">ACE_QoS</a></td><td>Wrapper class that holds the sender and receiver flow spec information, which is used by IntServ (RSVP) and DiffServ</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__QoS__Params.html">ACE_QoS_Params</a></td><td>Wrapper class that simplifies the information passed to the QoS enabled &lt;<a class="el" href="classACE__OS.html#z50_2">ACE_OS::connect</a>&gt; and &lt;<a class="el" href="classACE__OS.html#z50_27">ACE_OS::join_leaf</a>&gt; methods</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__QtReactor.html">ACE_QtReactor</a></td><td>An object-oriented event demultiplexor and event handler dispatcher that uses the Qt Library. This class declaration also uses the extension facilities provided by the Qt. So, readers of the class declaration should not be upset with the appearence of the Keywords like Q_OBJECT, private slots etc. They are specific to Qt which uses these as a call back methods implementation mechanism</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__RB__Tree.html">ACE_RB_Tree&lt; EXT_ID, INT_ID, COMPARE_KEYS, ACE_LOCK &gt;</a></td><td>Implements a Red-Black Tree ADT, according to T. H. Corman, C. E. Leiserson, and R. L. Rivest, "Introduction to Algorithms" 1990, MIT, chapter 14</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__RB__Tree__Base.html">ACE_RB_Tree_Base</a></td><td></td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__RB__Tree__Iterator.html">ACE_RB_Tree_Iterator&lt; EXT_ID, INT_ID, COMPARE_KEYS, ACE_LOCK &gt;</a></td><td>Implements an iterator for a Red-Black Tree ADT</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__RB__Tree__Iterator__Base.html">ACE_RB_Tree_Iterator_Base&lt; EXT_ID, INT_ID, COMPARE_KEYS, ACE_LOCK &gt;</a></td><td>Implements a common base class for iterators for a Red-Black Tree ADT</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__RB__Tree__Node.html">ACE_RB_Tree_Node&lt; EXT_ID, INT_ID &gt;</a></td><td>Implements a node in a Red-Black Tree ADT</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__RB__Tree__Node__Base.html">ACE_RB_Tree_Node_Base</a></td><td></td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__RB__Tree__Reverse__Iterator.html">ACE_RB_Tree_Reverse_Iterator&lt; EXT_ID, INT_ID, COMPARE_KEYS, ACE_LOCK &gt;</a></td><td>Implements a reverse iterator for a Red-Black Tree ADT</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Reactive__MEM__IO.html">ACE_Reactive_MEM_IO</a></td><td></td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Reactive__Strategy.html">ACE_Reactive_Strategy&lt; SVC_HANDLER &gt;</a></td><td>Defines the interface for specifying a Reactive concurrency strategy for a SVC_HANDLER</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Reactor.html">ACE_Reactor</a></td><td>The responsibility of this class is to forward all methods to its delegation/implementation class, e.g., &lt;ACE_Select_Reactor&gt; or &lt;<a class="el" href="classACE__WFMO__Reactor.html">ACE_WFMO_Reactor</a>&gt;</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Reactor__Impl.html">ACE_Reactor_Impl</a></td><td>An abstract class for implementing the Reactor Pattern</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Reactor__Notification__Strategy.html">ACE_Reactor_Notification_Strategy</a></td><td>Used to notify an <a class="el" href="classACE__Reactor.html">ACE_Reactor</a></td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Reactor__Notify.html">ACE_Reactor_Notify</a></td><td>Abstract class for unblocking an &lt;<a class="el" href="classACE__Reactor__Impl.html">ACE_Reactor_Impl</a>&gt; from its event loop</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Read__Buffer.html">ACE_Read_Buffer</a></td><td>Efficiently reads an artibrarily large buffer from an input stream up to and including a termination character. Also performs search/replace on single occurrences a character in the buffer using the principles of Integrated Layer Processing</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Read__Guard.html">ACE_Read_Guard&lt; ACE_LOCK &gt;</a></td><td>This class is similar to class &lt;<a class="el" href="classACE__Guard.html">ACE_Guard</a>&gt;, though it acquires/releases a read lock automatically (naturally, the &lt;ACE_LOCK&gt; it is instantiated with must support the appropriate API)</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Read__Guard_3_01ACE__Null__Mutex_01_4.html">ACE_Read_Guard&lt; ACE_Null_Mutex &gt;</a></td><td></td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="structACE__recursive__mutex__state.html">ACE_recursive_mutex_state</a></td><td></td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Recursive__Thread__Mutex.html">ACE_Recursive_Thread_Mutex</a></td><td>Implement a C++ wrapper that allows nested acquisition and release of a mutex that occurs in the same thread</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__recursive__thread__mutex__t.html">ACE_recursive_thread_mutex_t</a></td><td>Implement a thin C++ wrapper that allows nested acquisition and release of a mutex that occurs in the same thread</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Recyclable.html">ACE_Recyclable</a></td><td></td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Recyclable__Handler__Caching__Utility.html">ACE_Recyclable_Handler_Caching_Utility&lt; KEY, VALUE, CONTAINER, ITERATOR, ATTRIBUTES &gt;</a></td><td>Defines a helper class for the Caching Strategies</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Recyclable__Handler__Cleanup__Strategy.html">ACE_Recyclable_Handler_Cleanup_Strategy&lt; KEY, VALUE, CONTAINER &gt;</a></td><td>Defines a strategy to be followed for cleaning up entries which are svc_handlers from a container</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Recycling__Strategy.html">ACE_Recycling_Strategy&lt; SVC_HANDLER &gt;</a></td><td>Defines the interface (and default implementation) for specifying a recycling strategy for a SVC_HANDLER</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Refcountable.html">ACE_Refcountable</a></td><td></td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Refcounted__Auto__Ptr.html">ACE_Refcounted_Auto_Ptr&lt; X, ACE_LOCK &gt;</a></td><td>This class implements support for a reference counted <a class="el" href="classauto__ptr.html">auto_ptr</a>. Assigning or copying instances of an ACE_Refcounted_Auto_Ptr will automatically increment the reference count. When the last instance that references a ACE_Refcounted_Auto_Ptr instance is destroyed or overwritten, it will invoke delete on its underlying pointer</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Refcounted__Auto__Ptr__Rep.html">ACE_Refcounted_Auto_Ptr_Rep&lt; X, ACE_LOCK &gt;</a></td><td>An ACE_Refcounted_Auto_Ptr_Rep&lt;X, ACE_LOCK&gt; object encapsulates a pointer to an object of type X. It is pointed to by <a class="el" href="classACE__Refcounted__Auto__Ptr.html">ACE_Refcounted_Auto_Ptr</a>&lt;X, ACE_LOCK&gt; object[s] and only accessible through them</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Refcounted__Hash__Recyclable.html">ACE_Refcounted_Hash_Recyclable&lt; T &gt;</a></td><td></td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Refcounted__Recyclable__Handler__Caching__Utility.html">ACE_Refcounted_Recyclable_Handler_Caching_Utility&lt; KEY, VALUE, CONTAINER, ITERATOR, ATTRIBUTES &gt;</a></td><td>Defines a helper class for the Caching Strategies</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Refcounted__Recyclable__Handler__Cleanup__Strategy.html">ACE_Refcounted_Recyclable_Handler_Cleanup_Strategy&lt; KEY, VALUE, CONTAINER &gt;</a></td><td>Defines a strategy to be followed for cleaning up entries which are svc_handlers from a container</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Reference__Pair.html">ACE_Reference_Pair&lt; T1, T2 &gt;</a></td><td>Defines a pair that only hold references</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Registry.html">ACE_Registry</a></td><td>A Name Server implementation</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="structACE__Registry_1_1Binding.html">ACE_Registry::Binding</a></td><td></td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Registry_1_1Binding__Iterator.html">ACE_Registry::Binding_Iterator</a></td><td>An iterator</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Registry_1_1Binding__Iterator_1_1Context__Iteration.html">ACE_Registry::Binding_Iterator::Context_Iteration</a></td><td></td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Registry_1_1Binding__Iterator_1_1Iteration__Complete.html">ACE_Registry::Binding_Iterator::Iteration_Complete</a></td><td></td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Registry_1_1Binding__Iterator_1_1Iteration__State.html">ACE_Registry::Binding_Iterator::Iteration_State</a></td><td></td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Registry_1_1Binding__Iterator_1_1Object__Iteration.html">ACE_Registry::Binding_Iterator::Object_Iteration</a></td><td></td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="structACE__Registry_1_1Name__Component.html">ACE_Registry::Name_Component</a></td><td>International string</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Registry_1_1Naming__Context.html">ACE_Registry::Naming_Context</a></td><td>An context representation</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Registry_1_1Object.html">ACE_Registry::Object</a></td><td>An object representation</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Registry__ImpExp.html">ACE_Registry_ImpExp</a></td><td>Configuration object that imports/exports data to a file formatted using the Win32 Registry file export format. This format looks like [Section] "key"="String Data" "key"=dword: numeric data "key"=hex: binary data</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Registry__Name__Space.html">ACE_Registry_Name_Space</a></td><td>Interface to a Name Server Database which is maintained by the Win32 Registry. Allows to add, change, remove and resolve NameBindings</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Remote__Mutex.html">ACE_Remote_Mutex</a></td><td>Proxy for acquiring, renewing, and releasing a distributed mutex</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Remote__Name__Space.html">ACE_Remote_Name_Space</a></td><td>Maintaining accesses Remote Name Server Database. Allows to add NameBindings, change them, remove them and resolve NameBindings</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Remote__RLock.html">ACE_Remote_RLock</a></td><td>Proxy for acquiring, renewing, and releasing a distributed readers lock</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Remote__Token__Proxy.html">ACE_Remote_Token_Proxy</a></td><td>Proxy for acquiring, renewing, and releasing a distributed synchronization token</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Remote__WLock.html">ACE_Remote_WLock</a></td><td>Proxy for acquiring, renewing, and releasing a distributed writers lock</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Remove__Node.html">ACE_Remove_Node</a></td><td>Remove a Service Node</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Resume__Node.html">ACE_Resume_Node</a></td><td>Resume a Service Node</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Reverse__Iterator.html">ACE_Reverse_Iterator&lt; T &gt;</a></td><td>Defines the reverse iterator interface</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Reverse__Iterator__Impl.html">ACE_Reverse_Iterator_Impl&lt; T &gt;</a></td><td>Defines a abstract reverse iterator</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Reverse__Lock.html">ACE_Reverse_Lock&lt; ACE_LOCKING_MECHANISM &gt;</a></td><td>A reverse (or anti) lock</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__RW__Mutex.html">ACE_RW_Mutex</a></td><td>Wrapper for readers/writer locks</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__RW__Process__Mutex.html">ACE_RW_Process_Mutex</a></td><td>Wrapper for readers/writer locks that exist across processes</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__RW__Thread__Mutex.html">ACE_RW_Thread_Mutex</a></td><td>Wrapper for readers/writer locks that exist within a process</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__RW__Token.html">ACE_RW_Token</a></td><td>Class that acquires, renews, and releases a process-local synchronization token</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__RWLock__Invariants.html">ACE_RWLock_Invariants</a></td><td>RWLock Invariants</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Sample__History.html">ACE_Sample_History</a></td><td>Save multiple samples in an array</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Sbrk__Memory__Pool.html">ACE_Sbrk_Memory_Pool</a></td><td>Make a memory pool that is based on &lt;sbrk(2)&gt;</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Sbrk__Memory__Pool__Options.html">ACE_Sbrk_Memory_Pool_Options</a></td><td>Helper class for Sbrk Memory Pool constructor options</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Sched__Params.html">ACE_Sched_Params</a></td><td>Container for scheduling-related parameters</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Sched__Priority__Iterator.html">ACE_Sched_Priority_Iterator</a></td><td>An iterator over the OS-defined scheduling priorities</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Schedule__All__Reactive__Strategy.html">ACE_Schedule_All_Reactive_Strategy&lt; SVC_HANDLER &gt;</a></td><td>Defines the interface for specifying how to suspend and resume a single-threaded reactive service </td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Schedule__All__Threaded__Strategy.html">ACE_Schedule_All_Threaded_Strategy&lt; SVC_HANDLER &gt;</a></td><td>Defines the interface for specifying how to suspend and resume a multithreaded service </td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Scheduling__Strategy.html">ACE_Scheduling_Strategy&lt; SVC_HANDLER &gt;</a></td><td>Defines the interface for specifying how to suspend and resume a service </td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__SDM__helpers.html">ACE_SDM_helpers</a></td><td></td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Section__Key__Internal.html">ACE_Section_Key_Internal</a></td><td></td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Section__Key__Win32.html">ACE_Section_Key_Win32</a></td><td>The Win32 registry implementation of an internal section key</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Select__Reactor__Handle__Set.html">ACE_Select_Reactor_Handle_Set</a></td><td>Track handles we are interested for various events</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Select__Reactor__Handler__Repository.html">ACE_Select_Reactor_Handler_Repository</a></td><td>Used to map &lt;ACE_HANDLE&gt;s onto the appropriate &lt;<a class="el" href="classACE__Event__Handler.html">ACE_Event_Handler</a>&gt; *</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Select__Reactor__Handler__Repository__Iterator.html">ACE_Select_Reactor_Handler_Repository_Iterator</a></td><td>Iterate through the &lt;<a class="el" href="classACE__Select__Reactor__Handler__Repository.html">ACE_Select_Reactor_Handler_Repository</a>&gt;</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Select__Reactor__Impl.html">ACE_Select_Reactor_Impl</a></td><td>This class simply defines how Select_Reactor's basic interface functions should look like and provides a common base class for &lt;Select_Reactor&gt; using various locking mechanism</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Select__Reactor__Notify.html">ACE_Select_Reactor_Notify</a></td><td>Unblock the &lt;ACE_Select_Reactor&gt; from its event loop</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Select__Reactor__T.html">ACE_Select_Reactor_T&lt; ACE_SELECT_REACTOR_TOKEN &gt;</a></td><td>An object oriented event demultiplexor and event handler dispatcher</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Select__Reactor__Token__T.html">ACE_Select_Reactor_Token_T&lt; ACE_SELECT_REACTOR_MUTEX &gt;</a></td><td>Used as a synchronization mechanism to coordinate concurrent access to a Select_Reactor object</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Semaphore.html">ACE_Semaphore</a></td><td>Wrapper for Dijkstra style general semaphores</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Service__Config.html">ACE_Service_Config</a></td><td>Supplies common server operations for dynamic and static configuration of services</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Service__Handler.html">ACE_Service_Handler</a></td><td>This base class defines the interface for the <a class="el" href="classACE__Asynch__Acceptor.html">ACE_Asynch_Acceptor</a> to call into when new connection are accepted</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Service__Manager.html">ACE_Service_Manager</a></td><td>Provide a standard <a class="el" href="classACE.html">ACE</a> service for managing all the services configured in an &lt;<a class="el" href="classACE__Service__Repository.html">ACE_Service_Repository</a>&gt;</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Service__Object.html">ACE_Service_Object</a></td><td>Provide the abstract base class common to all service implementations</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Service__Object__Ptr.html">ACE_Service_Object_Ptr</a></td><td>This is a smart pointer that holds onto the associated &lt;<a class="el" href="classACE__Service__Object.html">ACE_Service_Object</a>&gt; * until the current scope is left, at which point the object's &lt;fini&gt; hook is called and the service_object_ gets deleted</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Service__Object__Type.html">ACE_Service_Object_Type</a></td><td>Define the methods for handling the configuration of &lt;ACE_Service_Objects&gt;</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Service__Repository.html">ACE_Service_Repository</a></td><td>Contains all the services offered by a Service Configurator-based application</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Service__Repository__Iterator.html">ACE_Service_Repository_Iterator</a></td><td>Iterate through the &lt;<a class="el" href="classACE__Service__Repository.html">ACE_Service_Repository</a>&gt;</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Service__Type.html">ACE_Service_Type</a></td><td>Keeps track of information related to the various &lt;<a class="el" href="classACE__Service__Type__Impl.html">ACE_Service_Type_Impl</a>&gt; subclasses</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Service__Type__Impl.html">ACE_Service_Type_Impl</a></td><td>The abstract base class of the hierarchy that defines the contents of the &lt;<a class="el" href="classACE__Service__Repository.html">ACE_Service_Repository</a>&gt;. The subclasses of this class allow the configuration of &lt;ACE_Service_Objects&gt;, &lt;ACE_Modules&gt;, and &lt;ACE_Streams&gt;</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Shared__Memory.html">ACE_Shared_Memory</a></td><td>This base class adapts both System V shared memory and "BSD" mmap to a common API</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Shared__Memory__MM.html">ACE_Shared_Memory_MM</a></td><td>Shared memory wrapper based on MMAP</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Shared__Memory__Pool.html">ACE_Shared_Memory_Pool</a></td><td>Make a memory pool that is based on System V shared memory (shmget(2) etc.). This implementation allows memory to be shared between processes. If your platform doesn't support System V shared memory (e.g., Win32 and many RTOS platforms do not) then you should use &lt;<a class="el" href="classACE__MMAP__Memory__Pool.html">ACE_MMAP_Memory_Pool</a>&gt; instead of this class. In fact, you should probably use &lt;<a class="el" href="classACE__MMAP__Memory__Pool.html">ACE_MMAP_Memory_Pool</a>&gt; on platforms that *do* support System V shared memory since it provides more powerful features, such as persistent backing store and greatly scalability</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="structACE__Shared__Memory__Pool_1_1SHM__TABLE.html">ACE_Shared_Memory_Pool::SHM_TABLE</a></td><td>Keeps track of all the segments being used</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Shared__Memory__Pool__Options.html">ACE_Shared_Memory_Pool_Options</a></td><td>Helper class for Shared Memory Pool constructor options</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Shared__Memory__SV.html">ACE_Shared_Memory_SV</a></td><td>Shared memory wrapper based on System V shared memory</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Shared__Object.html">ACE_Shared_Object</a></td><td>Provide the abstract base class used to access dynamic linking facilities</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Sig__Action.html">ACE_Sig_Action</a></td><td>C++ wrapper facade for the &lt;sigaction&gt; struct</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Sig__Adapter.html">ACE_Sig_Adapter</a></td><td>Provide an adapter that transforms various types of signal handlers into the scheme used by the &lt;<a class="el" href="classACE__Reactor.html">ACE_Reactor</a>&gt;</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Sig__Guard.html">ACE_Sig_Guard</a></td><td>Hold signals in MASK for duration of a C++ statement block. Note that a "0" for mask causes all signals to be held</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Sig__Handler.html">ACE_Sig_Handler</a></td><td>This is the main dispatcher of signals for <a class="el" href="classACE.html">ACE</a>. It improves the existing UNIX signal handling mechanism by allowing C++ objects to handle signals in a way that avoids the use of global/static variables and functions</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Sig__Handlers.html">ACE_Sig_Handlers</a></td><td>This is an alternative signal handling dispatcher for <a class="el" href="classACE.html">ACE</a>. It allows a list of signal handlers to be registered for each signal. It also makes SA_RESTART the default mode</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Sig__Handlers__Set.html">ACE_Sig_Handlers_Set</a></td><td></td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Sig__Set.html">ACE_Sig_Set</a></td><td>Provide a C++ wrapper for the C sigset_t interface</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Singleton.html">ACE_Singleton&lt; TYPE, ACE_LOCK &gt;</a></td><td>A Singleton Adapter uses the Adapter pattern to turn ordinary classes into Singletons optimized with the Double-Checked Locking optimization pattern</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Singleton__Strategy.html">ACE_Singleton_Strategy&lt; SVC_HANDLER &gt;</a></td><td>Defines the interface for specifying a creation strategy for a &lt;SVC_HANDLER&gt; that always returns the same &lt;SVC_HANDLER&gt; (i.e., it's a Singleton)</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__SOCK.html">ACE_SOCK</a></td><td>An abstract class that forms the basis for more specific classes, such as &lt;<a class="el" href="classACE__SOCK__Acceptor.html">ACE_SOCK_Acceptor</a>&gt; and &lt;<a class="el" href="classACE__SOCK__Stream.html">ACE_SOCK_Stream</a>&gt;. Do not instantiate this class</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__SOCK__Acceptor.html">ACE_SOCK_Acceptor</a></td><td>Defines a factory that creates new &lt;<a class="el" href="classACE__Stream.html">ACE_Stream</a>&gt;s passively</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__SOCK__CODgram.html">ACE_SOCK_CODgram</a></td><td>Defines the member functions for the <a class="el" href="classACE__SOCK.html">ACE_SOCK</a> connected datagram abstraction</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Sock__Connect.html">ACE_Sock_Connect</a></td><td></td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__SOCK__Connector.html">ACE_SOCK_Connector</a></td><td>Defines a factory that actively connects to a remote IP address and TCP port, creating a new <code><a class="el" href="classACE__SOCK__Stream.html">ACE_SOCK_Stream</a></code> object</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__SOCK__Dgram.html">ACE_SOCK_Dgram</a></td><td>Defines the member functions for the <a class="el" href="classACE__SOCK.html">ACE_SOCK</a> datagram abstraction</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__SOCK__Dgram__Bcast.html">ACE_SOCK_Dgram_Bcast</a></td><td>Defines the member functions for the <a class="el" href="classACE__SOCK.html">ACE_SOCK</a> datagram abstraction</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__SOCK__Dgram__Mcast.html">ACE_SOCK_Dgram_Mcast</a></td><td>Defines the <a class="el" href="classACE.html">ACE</a> socket wrapper for UDP/IP multicast</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__SOCK__Dgram__SC.html">ACE_SOCK_Dgram_SC&lt; STREAM &gt;</a></td><td>"Dgram_SC" is short for "Datagram Self-Contained."</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__SOCK__IO.html">ACE_SOCK_IO</a></td><td>Defines the methods for the <a class="el" href="classACE.html">ACE</a> socket wrapper I/O routines (e.g., send/recv)</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__SOCK__Stream.html">ACE_SOCK_Stream</a></td><td>Defines the methods in the &lt;ACE_SOCK_Stream&gt; abstraction</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__SPIPE.html">ACE_SPIPE</a></td><td>Defines the member functions for the base class of the ACE_SPIPE abstraction</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__SPIPE__Acceptor.html">ACE_SPIPE_Acceptor</a></td><td>A factory class that produces <a class="el" href="classACE__SPIPE__Stream.html">ACE_SPIPE_Stream</a> objects</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__SPIPE__Addr.html">ACE_SPIPE_Addr</a></td><td>Defines the SVR4 STREAM pipe address family address format</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="structACE__SPIPE__Addr_1_1SPIPE__Addr.html">ACE_SPIPE_Addr::SPIPE_Addr</a></td><td>Contains security attributes</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__SPIPE__Connector.html">ACE_SPIPE_Connector</a></td><td>Defines an active connection factory for &lt;<a class="el" href="classACE__SPIPE__Stream.html">ACE_SPIPE_Stream</a>&gt;. On Windows this is mapped to Named Pipes, whereas on UNIX it is mapped to STREAM pipes</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__SPIPE__Stream.html">ACE_SPIPE_Stream</a></td><td>Defines the methods in the &lt;ACE_SPIPE_Stream&gt; abstraction</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__SString.html">ACE_SString</a></td><td>A very Simple String ACE_SString class. This is not a general-purpose string class, and you should probably consider using ACE_CString is you don't understand why this class exists..</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Static__Allocator.html">ACE_Static_Allocator&lt; POOL_SIZE &gt;</a></td><td>Defines a class that provided a highly optimized memory management scheme for allocating memory statically</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Static__Allocator__Base.html">ACE_Static_Allocator_Base</a></td><td>Defines a class that provided a highly optimized memory management scheme for allocating memory statically</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Static__Function__Node.html">ACE_Static_Function_Node</a></td><td>Keeps track of the symbol name for a function that is not linked in from a DLL, but is statically linked with the application</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Static__Node.html">ACE_Static_Node</a></td><td>Handle a statically linked node</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Static__Object__Lock.html">ACE_Static_Object_Lock</a></td><td>Provide an interface to access a global lock</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Static__Svc__Descriptor.html">ACE_Static_Svc_Descriptor</a></td><td>Holds the information necessary to describe a statically linked Svc</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Stats.html">ACE_Stats</a></td><td>Provides simple statistical analysis</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Stats__Value.html">ACE_Stats_Value</a></td><td>Helper class for <a class="el" href="classACE__Stats.html">ACE_Stats</a></td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Str__Buf.html">ACE_Str_Buf</a></td><td>Simple wrapper for STREAM pipes <a class="el" href="structstrbuf.html">strbuf</a></td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Strategy__Acceptor.html">ACE_Strategy_Acceptor&lt; SVC_HANDLER, &gt;</a></td><td>Abstract factory for creating a service handler (SVC_HANDLER), accepting into the SVC_HANDLER, and activating the SVC_HANDLER</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Strategy__Connector.html">ACE_Strategy_Connector&lt; SVC_HANDLER, &gt;</a></td><td>Abstract factory for creating a service handler (SVC_HANDLER), connecting the SVC_HANDLER, and activating the SVC_HANDLER</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Stream.html">ACE_Stream&lt;&gt;</a></td><td>This class is the primary abstraction for the ASX framework. It is moduled after System V Stream</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Stream__Head.html">ACE_Stream_Head&lt;&gt;</a></td><td>Standard module that acts as the head of a ustream</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Stream__Iterator.html">ACE_Stream_Iterator&lt;&gt;</a></td><td>Iterate through an &lt;<a class="el" href="classACE__Stream.html">ACE_Stream</a>&gt;</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Stream__Node.html">ACE_Stream_Node</a></td><td>Handle a Stream</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Stream__Tail.html">ACE_Stream_Tail&lt;&gt;</a></td><td>Standard module that acts as the head of a ustream</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Stream__Type.html">ACE_Stream_Type</a></td><td>Define the methods for handling the configuration of &lt;ACE_Streams&gt;</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Streambuf.html">ACE_Streambuf</a></td><td>Create your custom streambuf by providing and ACE_*_Stream object to this template. I have tested it with <a class="el" href="classACE__SOCK__Stream.html">ACE_SOCK_Stream</a> and it should work fine for others as well</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Streambuf__T.html">ACE_Streambuf_T&lt; STREAM &gt;</a></td><td></td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__String__Base.html">ACE_String_Base&lt; CHAR &gt;</a></td><td>This class provides a wrapper facade for C strings</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__String__Base__Const.html">ACE_String_Base_Const</a></td><td>This class defines a constant for <a class="el" href="classACE__String__Base.html">ACE_String_Base</a> to circumvent a bug in SunCC 6.0</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__StringCapEntry.html">ACE_StringCapEntry</a></td><td>This class implement the <a class="el" href="classACE.html">ACE</a> String Capability subclass</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Strong__Bound__Ptr.html">ACE_Strong_Bound_Ptr&lt; X, ACE_LOCK &gt;</a></td><td>This class implements support for a reference counted pointer</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="structACE__Sub__Barrier.html">ACE_Sub_Barrier</a></td><td></td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Suspend__Node.html">ACE_Suspend_Node</a></td><td>Suspend a Service Node</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__SV__Message.html">ACE_SV_Message</a></td><td>Defines the header file for the C++ wrapper for message queues</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__SV__Message__Queue.html">ACE_SV_Message_Queue</a></td><td>Defines the header file for the C++ wrapper for System V IPC message queues</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__SV__Semaphore__Complex.html">ACE_SV_Semaphore_Complex</a></td><td>This is a more complex semaphore wrapper that handles race conditions for initialization correctly..</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__SV__Semaphore__Simple.html">ACE_SV_Semaphore_Simple</a></td><td>This is a simple semaphore package that assumes there are no race conditions for initialization (i.e., the order of process startup must be well defined)</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__SV__Shared__Memory.html">ACE_SV_Shared_Memory</a></td><td>This is a wrapper for System V shared memory</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Svc__Conf__Lexer__Guard.html">ACE_Svc_Conf_Lexer_Guard</a></td><td>"Guard" that ensures lexer buffer switching is exception-safe</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Svc__Conf__Param.html">ACE_Svc_Conf_Param</a></td><td>An instance of this object will be passed down to the yyparse() and yylex() functions</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Svc__Handler.html">ACE_Svc_Handler&lt;, &gt;</a></td><td>Defines the interface for a service that exchanges data with its connected peer</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Svc__Tuple.html">ACE_Svc_Tuple&lt; SVC_HANDLER &gt;</a></td><td>Holds the <a class="el" href="classACE__Svc__Handler.html">ACE_Svc_Handler</a> and its argument and &lt;ACE_Timer_Handle&gt; until an asynchronous connection completes</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Swap.html">ACE_Swap&lt; T &gt;</a></td><td>Defines a function to swap two variables</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Synch__Options.html">ACE_Synch_Options</a></td><td>Contains the values of options used to determine the synchronous and asynchronous behavior</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__System__Time.html">ACE_System_Time</a></td><td>Defines the timer services of the OS interface to access the system time either on the local host or on the central time server in the network</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Task.html">ACE_Task&lt;&gt;</a></td><td>Primary interface for application message processing, as well as input and output message queueing</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Task__Base.html">ACE_Task_Base</a></td><td>Direct base class for the <a class="el" href="classACE__Task.html">ACE_Task</a> template</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Task__Flags.html">ACE_Task_Flags</a></td><td>These flags are used within the <a class="el" href="classACE__Task.html">ACE_Task</a></td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Test__and__Set.html">ACE_Test_and_Set&lt; ACE_LOCK, TYPE &gt;</a></td><td>Implements the classic ``test and set'' operation</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Thread.html">ACE_Thread</a></td><td>Provides a wrapper for threads</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Thread__Adapter.html">ACE_Thread_Adapter</a></td><td>Converts a C++ function into a function that can be called from a thread creation routine (e.g., pthread_create() or _beginthreadex()) that expects an extern "C" entry point. This class also makes it possible to transparently provide hooks to register a thread with an <a class="el" href="classACE__Thread__Manager.html">ACE_Thread_Manager</a></td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Thread__Barrier.html">ACE_Thread_Barrier</a></td><td>Implements "barrier synchronization" using ACE_Thread_Mutexes!</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Thread__Condition.html">ACE_Thread_Condition&lt; MUTEX &gt;</a></td><td><a class="el" href="classACE__Condition.html">ACE_Condition</a> variable wrapper that works within processes</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Thread__Control.html">ACE_Thread_Control</a></td><td>Used to keep track of a thread's activities within its entry point function</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Thread__Descriptor.html">ACE_Thread_Descriptor</a></td><td>Information for controlling threads that run under the control of the &lt;Thread_Manager&gt;</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Thread__Descriptor__Base.html">ACE_Thread_Descriptor_Base</a></td><td>Basic information for thread descriptors. These information gets extracted out because we need it after a thread is terminated</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Thread__Exit.html">ACE_Thread_Exit</a></td><td>Keep exit information for a Thread in thread specific storage. so that the thread-specific exit hooks will get called no matter how the thread exits (e.g., via &lt;<a class="el" href="classACE__Thread.html#d13">ACE_Thread::exit</a>&gt;, C++ or Win32 exception, "falling off the end" of the thread entry point function, etc.)</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Thread__Exit__Maybe.html">ACE_Thread_Exit_Maybe</a></td><td>A version of <a class="el" href="classACE__Thread__Exit.html">ACE_Thread_Exit</a> that is created dynamically under the hood if the flag is set to TRUE</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Thread__Hook.html">ACE_Thread_Hook</a></td><td>This class makes it possible to provide user-defined "start" hooks that are called before the thread entry point function is invoked</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Thread__ID.html">ACE_Thread_ID</a></td><td>Defines a platform-independent thread ID</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Thread__Manager.html">ACE_Thread_Manager</a></td><td>Manages a pool of threads</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Thread__Mutex.html">ACE_Thread_Mutex</a></td><td>ACE_Thread_Mutex wrapper (only valid for threads in the same process)</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Thread__Semaphore.html">ACE_Thread_Semaphore</a></td><td>Wrapper for Dijkstra style general semaphores that work only within one process</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Thread__Strategy.html">ACE_Thread_Strategy&lt; SVC_HANDLER &gt;</a></td><td>Defines the interface for specifying a concurrency strategy for a &lt;SVC_HANDLER&gt; based on multithreading</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Thread__Timer__Queue__Adapter.html">ACE_Thread_Timer_Queue_Adapter&lt; TQ &gt;</a></td><td>Adapts a Timer_Queue using a separate thread for dispatching</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Throughput__Stats.html">ACE_Throughput_Stats</a></td><td>A simple class to make throughput and latency analysis</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Thru__Task.html">ACE_Thru_Task&lt;&gt;</a></td><td>Standard module that acts as a "no op", simply passing on all data to its adjacent neighbor</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Time__Request.html">ACE_Time_Request</a></td><td>Message format for delivering requests to the ACE_Time Server</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="structACE__Time__Request_1_1Transfer.html">ACE_Time_Request::Transfer</a></td><td></td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Time__Value.html">ACE_Time_Value</a></td><td>Operations on "timeval" structures, which express time in seconds (secs) and microseconds (usecs)</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Timeprobe.html">ACE_Timeprobe&lt; ACE_LOCK &gt;</a></td><td>This class is used to instrument code. This is accomplished by inserting time probes at different location in the code. ACE_Timeprobe then measures the time difference between two time probes</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__timeprobe__t.html">ACE_timeprobe_t</a></td><td>Time probe record</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="unionACE__timeprobe__t_1_1event.html">ACE_timeprobe_t::event</a></td><td>Events are record as strings or numbers</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Timer__Hash__Iterator__T.html">ACE_Timer_Hash_Iterator_T&lt; TYPE, FUNCTOR, ACE_LOCK, BUCKET &gt;</a></td><td>Iterates over an &lt;<a class="el" href="classACE__Timer__Hash__T.html">ACE_Timer_Hash_T</a>&gt;</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Timer__Hash__T.html">ACE_Timer_Hash_T&lt; TYPE, FUNCTOR, ACE_LOCK, BUCKET &gt;</a></td><td>Provides a hash table of &lt;BUCKET&gt;s as an implementation for a timer queue</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Timer__Hash__Upcall.html">ACE_Timer_Hash_Upcall&lt; TYPE, FUNCTOR, ACE_LOCK &gt;</a></td><td>Functor for Timer_Hash</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Timer__Heap__Iterator__T.html">ACE_Timer_Heap_Iterator_T&lt; TYPE, FUNCTOR, ACE_LOCK &gt;</a></td><td>Iterates over an &lt;<a class="el" href="classACE__Timer__Heap__T.html">ACE_Timer_Heap_T</a>&gt;</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Timer__Heap__T.html">ACE_Timer_Heap_T&lt; TYPE, FUNCTOR, ACE_LOCK &gt;</a></td><td>Provides a very fast and predictable timer implementation</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Timer__List__Iterator__T.html">ACE_Timer_List_Iterator_T&lt; TYPE, FUNCTOR, ACE_LOCK &gt;</a></td><td>Iterates over an &lt;ACE_Timer_List&gt;</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Timer__List__T.html">ACE_Timer_List_T&lt; TYPE, FUNCTOR, ACE_LOCK &gt;</a></td><td>Provides a simple implementation of timers</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Timer__Node__Dispatch__Info__T.html">ACE_Timer_Node_Dispatch_Info_T&lt; TYPE &gt;</a></td><td>Maintains generated dispatch information for Timer nodes</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Timer__Node__T.html">ACE_Timer_Node_T&lt; TYPE &gt;</a></td><td>Maintains the state associated with a Timer entry</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Timer__Queue__Iterator__T.html">ACE_Timer_Queue_Iterator_T&lt; TYPE, FUNCTOR, ACE_LOCK &gt;</a></td><td>Generic interface for iterating over a subclass of &lt;ACE_Timer_Queue&gt;</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Timer__Queue__T.html">ACE_Timer_Queue_T&lt; TYPE, FUNCTOR, ACE_LOCK &gt;</a></td><td>Provides an interface to timers</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Timer__Wheel__Iterator__T.html">ACE_Timer_Wheel_Iterator_T&lt; TYPE, FUNCTOR, ACE_LOCK &gt;</a></td><td>Iterates over an &lt;ACE_Timer_Wheel&gt;</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Timer__Wheel__T.html">ACE_Timer_Wheel_T&lt; TYPE, FUNCTOR, ACE_LOCK &gt;</a></td><td>Provides a Timing Wheel version of ACE_Timer_Queue</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__TkReactor.html">ACE_TkReactor</a></td><td>An object-oriented event demultiplexor and event handler dispatcher that uses the Tk functions</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__TkReactor__Input__Callback.html">ACE_TkReactor_Input_Callback</a></td><td></td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__TkReactorID.html">ACE_TkReactorID</a></td><td>This little class is necessary due to the way that Microsoft implements sockets to be pointers rather than indices</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__TLI.html">ACE_TLI</a></td><td>Defines the member functions for the base class of the ACE_TLI abstraction</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__TLI__Acceptor.html">ACE_TLI_Acceptor</a></td><td>Defines the member functions for ACE_TLI_Acceptor abstraction</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__TLI__Connector.html">ACE_TLI_Connector</a></td><td>Defines an active connection factory for the <a class="el" href="classACE__TLI.html">ACE_TLI</a> C++ wrappers</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="structACE__TLI__Request.html">ACE_TLI_Request</a></td><td></td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__TLI__Request__Queue.html">ACE_TLI_Request_Queue</a></td><td></td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__TLI__Stream.html">ACE_TLI_Stream</a></td><td>Defines the member functions for ACE_TLI_Stream abstraction</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Token.html">ACE_Token</a></td><td>Class that acquires, renews, and releases a synchronization token that is serviced in strict FIFO/LIFO ordering and that also supports (1) recursion and (2) readers/writer semantics</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="structACE__Token_1_1ACE__Token__Queue.html">ACE_Token::ACE_Token_Queue</a></td><td></td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="structACE__Token_1_1ACE__Token__Queue__Entry.html">ACE_Token::ACE_Token_Queue_Entry</a></td><td>The following structure implements a LIFO/FIFO queue of waiter threads that are asleep waiting to obtain the token</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Token__Collection.html">ACE_Token_Collection</a></td><td>Allows atomic token group operations AND provides a <a class="el" href="classACE__Token.html">ACE_Token</a> manager interface</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__TOKEN__CONST.html">ACE_TOKEN_CONST</a></td><td>Not a public interface</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Token__Invariant__Manager.html">ACE_Token_Invariant_Manager</a></td><td>Token Invariants</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Token__Manager.html">ACE_Token_Manager</a></td><td>Manages all tokens in a process space</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Token__Name.html">ACE_Token_Name</a></td><td>Allows Token_Manger to identify tokens</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Token__Proxy.html">ACE_Token_Proxy</a></td><td>Abstract representation of <a class="el" href="classACE.html">ACE</a> tokens</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Token__Proxy__Queue.html">ACE_Token_Proxy_Queue</a></td><td>Token waiter list</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Token__Reply.html">ACE_Token_Reply</a></td><td>Message format for delivering replies from the <a class="el" href="classACE__Token.html">ACE_Token</a> Server</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="structACE__Token__Reply_1_1Transfer.html">ACE_Token_Reply::Transfer</a></td><td></td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Token__Request.html">ACE_Token_Request</a></td><td>Message format for delivering requests to the <a class="el" href="classACE__Token.html">ACE_Token</a> Server</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="structACE__Token__Request_1_1Transfer.html">ACE_Token_Request::Transfer</a></td><td></td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Tokenizer.html">ACE_Tokenizer</a></td><td>Tokenizer</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Tokenizer_1_1Delimiter__Entry.html">ACE_Tokenizer::Delimiter_Entry</a></td><td>Delimiter Entry</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Tokenizer_1_1Preserve__Entry.html">ACE_Tokenizer::Preserve_Entry</a></td><td>Preserve Entry</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Tokens.html">ACE_Tokens</a></td><td>Abstract representation of <a class="el" href="classACE.html">ACE</a> tokens</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__TP__Reactor.html">ACE_TP_Reactor</a></td><td>Specialization of Select Reactor to support thread-pool based event dispatching</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__TP__Token__Guard.html">ACE_TP_Token_Guard</a></td><td>A helper class that helps grabbing, releasing and waiting on tokens for a thread that tries calling handle_events ()</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__TPQ__Entry.html">ACE_TPQ_Entry</a></td><td>Token Proxy Queue entry. Used in the <a class="el" href="classACE__Token__Proxy__Queue.html">ACE_Token_Proxy_Queue</a></td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__TPQ__Iterator.html">ACE_TPQ_Iterator</a></td><td>Iterates through ACE_Token_Proxy_Queues</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Trace.html">ACE_Trace</a></td><td>A C++ trace facility that keeps track of which methods are entered and exited</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__TSS.html">ACE_TSS&lt; TYPE &gt;</a></td><td>Allows objects that are "physically" in thread specific storage (i.e., private to a thread) to be accessed as though they were "logically" global to a program</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__TSS__Adapter.html">ACE_TSS_Adapter</a></td><td>This class encapsulates a TSS object and its associated C++ destructor function. It is used by the <a class="el" href="classACE__TSS.html">ACE_TSS</a>... methods (in <a class="el" href="Synch__T_8cpp.html">Synch_T.cpp</a>) in order to allow an extern "C" cleanup routine to be used. Needed by the "frigging" MVS C++ compiler</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__TSS__Cleanup.html">ACE_TSS_Cleanup</a></td><td>Singleton that knows how to clean up all the thread-specific resources for Win32</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__TSS__Connection.html">ACE_TSS_Connection</a></td><td>Class for providing a connection per thread</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__TSS__Info.html">ACE_TSS_Info</a></td><td>Thread Specific Key management</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__TSS__Keys.html">ACE_TSS_Keys</a></td><td>Collection of in-use flags for a thread's TSS keys. For internal use only by <a class="el" href="classACE__TSS__Cleanup.html">ACE_TSS_Cleanup</a>; it is public because some compilers can't use nested classes for template instantiation parameters</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__TSS__Ref.html">ACE_TSS_Ref</a></td><td>"Reference count" for thread-specific storage keys</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__TSS__Singleton.html">ACE_TSS_Singleton&lt; TYPE, ACE_LOCK &gt;</a></td><td>This class uses the Adapter pattern to turn ordinary classes into Thread-specific Singletons optimized with the Double-Checked Locking optimization pattern</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__TSS__TPQ__Entry.html">ACE_TSS_TPQ_Entry</a></td><td>ACE_TSS_TPQ_Entry</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__TSS__Type__Adapter.html">ACE_TSS_Type_Adapter&lt; TYPE &gt;</a></td><td>Adapter that allows built-in types to be used with <a class="el" href="classACE__TSS.html">ACE_TSS</a></td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__TTY__IO.html">ACE_TTY_IO</a></td><td>Class definitions for platform specific TTY features</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="structACE__TTY__IO_1_1Serial__Params.html">ACE_TTY_IO::Serial_Params</a></td><td></td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Typed__SV__Message.html">ACE_Typed_SV_Message&lt; T &gt;</a></td><td>Defines the header file for the C++ wrapper for System V message queues</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Typed__SV__Message__Queue.html">ACE_Typed_SV_Message_Queue&lt; T &gt;</a></td><td>Defines the header file for the C++ wrapper facade for typed message queues</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Unbounded__Queue.html">ACE_Unbounded_Queue&lt; T &gt;</a></td><td>A Queue of "infinite" length</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Unbounded__Queue__Const__Iterator.html">ACE_Unbounded_Queue_Const_Iterator&lt; T &gt;</a></td><td>Implement an iterator over an const unbounded queue</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Unbounded__Queue__Iterator.html">ACE_Unbounded_Queue_Iterator&lt; T &gt;</a></td><td>Implement an iterator over an unbounded queue</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Unbounded__Set.html">ACE_Unbounded_Set&lt; T &gt;</a></td><td>Implement a simple unordered set of &lt;T&gt; of unbounded size</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Unbounded__Set__Const__Iterator.html">ACE_Unbounded_Set_Const_Iterator&lt; T &gt;</a></td><td>Implement an const iterator over an unbounded set</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Unbounded__Set__Iterator.html">ACE_Unbounded_Set_Iterator&lt; T &gt;</a></td><td>Implement an iterator over an unbounded set</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Unbounded__Stack.html">ACE_Unbounded_Stack&lt; T &gt;</a></td><td>Implement a generic LIFO abstract data type</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Unbounded__Stack__Iterator.html">ACE_Unbounded_Stack_Iterator&lt; T &gt;</a></td><td>Implement an iterator over an unbounded Stack</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__UNIX__Addr.html">ACE_UNIX_Addr</a></td><td>Defines the ``UNIX domain address family'' address format</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Unmanaged__Singleton.html">ACE_Unmanaged_Singleton&lt; TYPE, ACE_LOCK &gt;</a></td><td>Same as <a class="el" href="classACE__Singleton.html">ACE_Singleton</a>, except does _not_ register with <a class="el" href="classACE__Object__Manager.html">ACE_Object_Manager</a> for destruction</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Unmanaged__TSS__Singleton.html">ACE_Unmanaged_TSS_Singleton&lt; TYPE, ACE_LOCK &gt;</a></td><td>Same as <a class="el" href="classACE__TSS__Singleton.html">ACE_TSS_Singleton</a>, except does _not_ register with <a class="el" href="classACE__Object__Manager.html">ACE_Object_Manager</a> for destruction</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__UPIPE__Acceptor.html">ACE_UPIPE_Acceptor</a></td><td>Defines the format and interface for the listener side of the <a class="el" href="classACE__UPIPE__Stream.html">ACE_UPIPE_Stream</a></td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__UPIPE__Connector.html">ACE_UPIPE_Connector</a></td><td>Defines an active connection factory for the ACE_UPIPE_STREAM wrappers</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__UPIPE__Stream.html">ACE_UPIPE_Stream</a></td><td>Defines the method that transfer data on a UPIPE</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Vector.html">ACE_Vector&lt; T, DEFAULT_SIZE &gt;</a></td><td>Defines an STL-like vector container</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Wakeup__All__Threads__Handler.html">ACE_Wakeup_All_Threads_Handler</a></td><td>This is a helper class whose sole purpose is to handle events on &lt;<a class="el" href="classACE__WFMO__Reactor.html">ACE_WFMO_Reactor</a>-&gt;wakeup_all_threads_&gt;</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__WChar__Codeset__Translator.html">ACE_WChar_Codeset_Translator</a></td><td>Codeset translation routines common to both Output and Input CDR streams</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Weak__Bound__Ptr.html">ACE_Weak_Bound_Ptr&lt; X, ACE_LOCK &gt;</a></td><td>This class implements support for a weak pointer that complements <a class="el" href="classACE__Strong__Bound__Ptr.html">ACE_Strong_Bound_Ptr</a></td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__WFMO__Reactor.html">ACE_WFMO_Reactor</a></td><td>An object oriented event demultiplexor and event handler. ACE_WFMO_Reactor is a Windows-only implementation of the <a class="el" href="classACE__Reactor.html">ACE_Reactor</a> interface that uses the WaitForMultipleObjects() event demultiplexer</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__WFMO__Reactor__Handler__Repository.html">ACE_WFMO_Reactor_Handler_Repository</a></td><td>Used to map &lt;ACE_HANDLE&gt;s onto the appropriate &lt;<a class="el" href="classACE__Event__Handler.html">ACE_Event_Handler</a>&gt; * and other information</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__WFMO__Reactor__Handler__Repository_1_1Common__Info.html">ACE_WFMO_Reactor_Handler_Repository::Common_Info</a></td><td>This struct contains the necessary information for every &lt;Event_Handler&gt; entry. The reason the event is not in this structure is because we need to pass an event array into WaitForMultipleObjects and therefore keeping the events seperate makes sense</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__WFMO__Reactor__Handler__Repository_1_1Current__Info.html">ACE_WFMO_Reactor_Handler_Repository::Current_Info</a></td><td>This structure inherits from the common structure to add information for current entries</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__WFMO__Reactor__Handler__Repository_1_1Suspended__Info.html">ACE_WFMO_Reactor_Handler_Repository::Suspended_Info</a></td><td>This structure inherits from the common structure to add information for suspended entries</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__WFMO__Reactor__Handler__Repository_1_1To__Be__Added__Info.html">ACE_WFMO_Reactor_Handler_Repository::To_Be_Added_Info</a></td><td>This structure inherits from the common structure to add information for &lt;to_be_added&gt; entries</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__WFMO__Reactor__Notify.html">ACE_WFMO_Reactor_Notify</a></td><td>Unblock the &lt;<a class="el" href="classACE__WFMO__Reactor.html">ACE_WFMO_Reactor</a>&gt; from its event loop, passing it an optional &lt;<a class="el" href="classACE__Event__Handler.html">ACE_Event_Handler</a>&gt; to dispatch</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__WIN32__Asynch__Accept.html">ACE_WIN32_Asynch_Accept</a></td><td>This class is a factory for starting off asynchronous accepts on a listen handle</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__WIN32__Asynch__Accept__Result.html">ACE_WIN32_Asynch_Accept_Result</a></td><td>This class implements <a class="el" href="classACE__Asynch__Accept_1_1Result.html">ACE_Asynch_Accept::Result</a> for WIN32 platform</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__WIN32__Asynch__Connect.html">ACE_WIN32_Asynch_Connect</a></td><td></td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__WIN32__Asynch__Connect__Result.html">ACE_WIN32_Asynch_Connect_Result</a></td><td>This is that class which will be passed back to the completion handler when the asynchronous connect completes</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__WIN32__Asynch__Operation.html">ACE_WIN32_Asynch_Operation</a></td><td>This class abstracts out the common things needed for implementing Asynch_Operation for WIN32 platform</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__WIN32__Asynch__Read__Dgram.html">ACE_WIN32_Asynch_Read_Dgram</a></td><td>This class is a factory for starting off asynchronous reads on a UDP socket</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__WIN32__Asynch__Read__Dgram__Result.html">ACE_WIN32_Asynch_Read_Dgram_Result</a></td><td>This class provides concrete implementation for <a class="el" href="classACE__Asynch__Read__Dgram_1_1Result.html">ACE_Asynch_Read_Dgram::Result</a> class</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__WIN32__Asynch__Read__File.html">ACE_WIN32_Asynch_Read_File</a></td><td>This class is a factory for starting off asynchronous reads on a file</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__WIN32__Asynch__Read__File__Result.html">ACE_WIN32_Asynch_Read_File_Result</a></td><td>This class provides concrete implementation for <a class="el" href="classACE__Asynch__Read__File_1_1Result.html">ACE_Asynch_Read_File::Result</a> class</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__WIN32__Asynch__Read__Stream.html">ACE_WIN32_Asynch_Read_Stream</a></td><td>This class is a factory for starting off asynchronous reads on a stream</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__WIN32__Asynch__Read__Stream__Result.html">ACE_WIN32_Asynch_Read_Stream_Result</a></td><td>This class provides concrete implementation for <a class="el" href="classACE__Asynch__Read__Stream_1_1Result.html">ACE_Asynch_Read_Stream::Result</a> class</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__WIN32__Asynch__Result.html">ACE_WIN32_Asynch_Result</a></td><td>An abstract class which adds information to the OVERLAPPED structure to make it more useful</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__WIN32__Asynch__Timer.html">ACE_WIN32_Asynch_Timer</a></td><td>This class is posted to the completion port when a timer expires. When the complete method of this object is called, the &lt;handler&gt;'s handle_timeout method will be called</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__WIN32__Asynch__Transmit__File.html">ACE_WIN32_Asynch_Transmit_File</a></td><td>This class is a factory for starting off asynchronous transmit files on a stream</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__WIN32__Asynch__Transmit__File__Result.html">ACE_WIN32_Asynch_Transmit_File_Result</a></td><td>This class implements <a class="el" href="classACE__Asynch__Transmit__File_1_1Result.html">ACE_Asynch_Transmit_File::Result</a> for WIN32 platforms</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__WIN32__Asynch__Write__Dgram.html">ACE_WIN32_Asynch_Write_Dgram</a></td><td>This class is a factory for starting off asynchronous writes on a UDP socket</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__WIN32__Asynch__Write__Dgram__Result.html">ACE_WIN32_Asynch_Write_Dgram_Result</a></td><td>This class provides concrete implementation for <a class="el" href="classACE__Asynch__Write__Dgram_1_1Result.html">ACE_Asynch_Write_Dgram::Result</a> class</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__WIN32__Asynch__Write__File.html">ACE_WIN32_Asynch_Write_File</a></td><td>This class is a factory for starting off asynchronous writes on a file</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__WIN32__Asynch__Write__File__Result.html">ACE_WIN32_Asynch_Write_File_Result</a></td><td>This class provides implementation for ACE_Asynch_Write_File_Result for WIN32 platforms</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__WIN32__Asynch__Write__Stream.html">ACE_WIN32_Asynch_Write_Stream</a></td><td>This class is a factory for starting off asynchronous writes on a stream</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__WIN32__Asynch__Write__Stream__Result.html">ACE_WIN32_Asynch_Write_Stream_Result</a></td><td>This class provides concrete implementation for <a class="el" href="classACE__Asynch__Write__Stream_1_1Result.html">ACE_Asynch_Write_Stream::Result</a> class</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__WIN32__Proactor.html">ACE_WIN32_Proactor</a></td><td>A manager for asynchronous event demultiplexing on Win32</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__WIN32__Wakeup__Completion.html">ACE_WIN32_Wakeup_Completion</a></td><td></td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Write__Guard.html">ACE_Write_Guard&lt; ACE_LOCK &gt;</a></td><td>This class is similar to class &lt;<a class="el" href="classACE__Guard.html">ACE_Guard</a>&gt;, though it acquires/releases a write lock automatically (naturally, the &lt;ACE_LOCK&gt; it is instantiated with must support the appropriate API)</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__Write__Guard_3_01ACE__Null__Mutex_01_4.html">ACE_Write_Guard&lt; ACE_Null_Mutex &gt;</a></td><td></td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__XTI__ATM__Mcast.html">ACE_XTI_ATM_Mcast</a></td><td>Defines an active connection factory for the <a class="el" href="classACE__TLI.html">ACE_TLI</a> C++ wrappers to support XTI/ATM multicast</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__XtReactor.html">ACE_XtReactor</a></td><td>An object-oriented event demultiplexor and event handler dispatcher that uses the X Toolkit functions</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACE__XtReactorID.html">ACE_XtReactorID</a></td><td>This little class is necessary due to the way that Microsoft implements sockets to be pointers rather than indices</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="unionACE__YYSTYPE.html">ACE_YYSTYPE</a></td><td></td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classACMM.html">ACMM</a></td><td></td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classauto__ptr.html">auto_ptr&lt; X &gt;</a></td><td>Implements the draft C++ standard auto_ptr abstraction</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="structcancel__state.html">cancel_state</a></td><td></td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="structdirent.html">dirent</a></td><td></td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="structHash__Token.html">Hash_Token</a></td><td></td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="structiovec.html">iovec</a></td><td>The ordering of the fields in this struct is important. It has to match those in WSABUF</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="structip__mreq.html">ip_mreq</a></td><td></td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="structmsghdr.html">msghdr</a></td><td></td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="structmsqid__ds.html">msqid_ds</a></td><td></td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="structrusage.html">rusage</a></td><td>Fake the UNIX rusage structure. Perhaps we can add more to this later on?</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="unionsemun.html">semun</a></td><td></td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="structshmaddr.html">shmaddr</a></td><td></td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="structsiginfo__t.html">siginfo_t</a></td><td></td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="structstrbuf.html">strbuf</a></td><td></td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="structtimespec.html">timespec</a></td><td></td></tr>
</table>
<hr><address><small>Generated on Wed Jan 15 19:06:26 2003 for ACE by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.gif" alt="doxygen" align="middle" border=0 
width=110 height=53></a>1.2.13.1 written by <a href="mailto:dimitri@stack.nl">Dimitri van Heesch</a>,
 &copy;&nbsp;1997-2001</small></address>
</body>
</html>
