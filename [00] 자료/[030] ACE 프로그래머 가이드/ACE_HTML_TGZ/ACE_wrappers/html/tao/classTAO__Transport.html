<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>TAO_Transport class Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body bgcolor="#ffffff">
<!-- Generated by Doxygen 1.2.13.1 -->
<center>
<a class="qindex" href="index.html">Main Page</a> &nbsp; <a class="qindex" href="namespaces.html">Namespace List</a> &nbsp; <a class="qindex" href="hierarchy.html">Class Hierarchy</a> &nbsp; <a class="qindex" href="classes.html">Alphabetical List</a> &nbsp; <a class="qindex" href="annotated.html">Compound List</a> &nbsp; <a class="qindex" href="files.html">File List</a> &nbsp; <a class="qindex" href="namespacemembers.html">Namespace Members</a> &nbsp; <a class="qindex" href="functions.html">Compound Members</a> &nbsp; <a class="qindex" href="globals.html">File Members</a> &nbsp; <a class="qindex" href="pages.html">Related Pages</a> &nbsp; </center>
<hr><h1>TAO_Transport  Class Reference</h1>Generic definitions for the Transport class. 
<a href="#_details">More...</a>
<p>
<code>#include &lt;Transport.h&gt;</code>
<p>
Inheritance diagram for TAO_Transport:<p><center><img src="classTAO__Transport__inherit__graph.gif" border="0" usemap="#TAO__Transport__inherit__map" alt="Inheritance graph"></center>
<map name="TAO__Transport__inherit__map">
<area href="classTAO__IIOP__Transport.html" shape="rect" coords="29,223,165,242" alt="">
<area href="classTAO__Synch__Refcountable.html" shape="rect" coords="14,85,179,103" alt="">
<area doxygen="ACE.tag:../ace/" href="../ace/classACE__Refcountable.html" shape="rect" coords="37,15,157,34" alt="">
</map>
<center><font size="2">[<a href="graph_legend.html">legend</a>]</font></center>Collaboration diagram for TAO_Transport:<p><center><img src="classTAO__Transport__coll__graph.gif" border="0" usemap="#TAO__Transport__coll__map" alt="Collaboration graph"></center>
<map name="TAO__Transport__coll__map">
<area href="classTAO__Transport__Timer.html" shape="rect" coords="1373,67,1517,85" alt="">
<area href="classTAO__Wait__Strategy.html" shape="rect" coords="1381,203,1509,221" alt="">
<area href="classTAO__Transport__Mux__Strategy.html" shape="rect" coords="1350,337,1539,356" alt="">
<area href="classTAO__Synch__Refcountable.html" shape="rect" coords="685,112,850,131" alt="">
<area doxygen="ACE.tag:../ace/" href="../ace/classACE__Lock.html" shape="rect" coords="407,76,479,95" alt="">
<area doxygen="ACE.tag:../ace/" href="../ace/classACE__Time__Value.html" shape="rect" coords="26,201,141,220" alt="">
<area href="classTAO__ORB__Core.html" shape="rect" coords="389,233,498,252" alt="">
<area href="classTAO__Queued__Message.html" shape="rect" coords="691,392,843,411" alt="">
<area href="classTAO__Incoming__Message__Queue.html" shape="rect" coords="666,291,869,309" alt="">
</map>
<center><font size="2">[<a href="graph_legend.html">legend</a>]</font></center><a href="classTAO__Transport-members.html">List of all members.</a><table border=0 cellpadding=0 cellspacing=0>
<tr><td colspan=2><br><h2>Public Types</h2></td></tr>
<tr><td nowrap align=right valign=top>enum &nbsp;</td><td valign=bottom>{ <a class="el" href="classTAO__Transport.html#s3s0">TAO_ONEWAY_REQUEST</a> =  0, 
<a class="el" href="classTAO__Transport.html#s3s1">TAO_TWOWAY_REQUEST</a> =  1, 
<a class="el" href="classTAO__Transport.html#s3s2">TAO_REPLY</a>
 }</td></tr>
<tr><td colspan=2><br><h2>Public Methods</h2></td></tr>
<tr><td nowrap align=right valign=top>&nbsp;</td><td valign=bottom><a class="el" href="classTAO__Transport.html#a0">TAO_Transport</a> (<a class="el" href="namespaceCORBA.html#a11">CORBA::ULong</a> tag, <a class="el" href="classTAO__ORB__Core.html">TAO_ORB_Core</a> *orb_core)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>default creator, requres the tag value be supplied.</em> <a href="#a0">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>virtual&nbsp;</td><td valign=bottom><a class="el" href="classTAO__Transport.html#a1">~TAO_Transport</a> (void)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>destructor.</em> <a href="#a1">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top><a class="el" href="namespaceCORBA.html#a11">CORBA::ULong</a>&nbsp;</td><td valign=bottom><a class="el" href="classTAO__Transport.html#a2">tag</a> (void) const</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Return the protocol tag.</em> <a href="#a2">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top><a class="el" href="classTAO__ORB__Core.html">TAO_ORB_Core</a> *&nbsp;</td><td valign=bottom><a class="el" href="classTAO__Transport.html#a3">orb_core</a> (void) const</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Access the ORB that owns this connection.</em> <a href="#a3">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top><a class="el" href="classTAO__Transport__Mux__Strategy.html">TAO_Transport_Mux_Strategy</a> *&nbsp;</td><td valign=bottom><a class="el" href="classTAO__Transport.html#a4">tms</a> (void) const</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Get the TAO_Tranport_Mux_Strategy used by this object.</em> <a href="#a4">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top><a class="el" href="classTAO__Wait__Strategy.html">TAO_Wait_Strategy</a> *&nbsp;</td><td valign=bottom><a class="el" href="classTAO__Transport.html#a5">wait_strategy</a> (void) const</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Return the <a class="el" href="classTAO__Wait__Strategy.html">TAO_Wait_Strategy</a> used by this object.</em> <a href="#a5">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>int&nbsp;</td><td valign=bottom><a class="el" href="classTAO__Transport.html#a6">handle_output</a> (void)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Callback method to reactively drain the outgoing data queue.</em> <a href="#a6">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>int&nbsp;</td><td valign=bottom><a class="el" href="classTAO__Transport.html#a7">bidirectional_flag</a> (void) const</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Get/Set the bidirectional flag.</em> <a href="#a7">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classTAO__Transport.html#a8">bidirectional_flag</a> (int flag)</td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classTAO__Transport.html#a9">cache_map_entry</a> (<a class="el" href="classTAO__Transport__Cache__Manager.html#s2">TAO_Transport_Cache_Manager::HASH_MAP_ENTRY</a> *entry)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Set/Get the Cache Map entry.</em> <a href="#a9">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top><a class="el" href="classTAO__Transport__Cache__Manager.html#s2">TAO_Transport_Cache_Manager::HASH_MAP_ENTRY</a> *&nbsp;</td><td valign=bottom><a class="el" href="classTAO__Transport.html#a10">cache_map_entry</a> (void)</td></tr>
<tr><td nowrap align=right valign=top>int&nbsp;</td><td valign=bottom><a class="el" href="classTAO__Transport.html#a11">id</a> (void) const</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Set and Get the identifier for this transport instance.</em> <a href="#a11">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classTAO__Transport.html#a12">id</a> (int id)</td></tr>
<tr><td nowrap align=right valign=top>unsigned long&nbsp;</td><td valign=bottom><a class="el" href="classTAO__Transport.html#a13">purging_order</a> (void) const</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Get and Set the purging order. The purging strategy uses the set version to set the purging order.</em> <a href="#a13">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classTAO__Transport.html#a14">purging_order</a> (unsigned long value)</td></tr>
<tr><td nowrap align=right valign=top>int&nbsp;</td><td valign=bottom><a class="el" href="classTAO__Transport.html#a15">queue_is_empty</a> (void)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Check if there are messages pending in the queue.</em> <a href="#a15">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classTAO__Transport.html#a16">provide_handle</a> (<a class="elRef" doxygen="ACE.tag:../ace/" href="../ace/classACE__Handle__Set.html">ACE_Handle_Set</a> &amp;reactor_registered, <a class="el" href="Transport__Cache__Manager_8h.html#a1">TAO_EventHandlerSet</a> &amp;unregistered)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Fill in a handle_set with any associated handler's reactor handle.</em> <a href="#a16">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>int&nbsp;</td><td valign=bottom><a class="el" href="classTAO__Transport.html#a17">register_handler</a> (void)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Remove all messages from the outgoing queue.</em> <a href="#a17">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top><a class="elRef" doxygen="ACE.tag:../ace/" href="../ace/Basic__Types_8h.html#a38">ssize_t</a>&nbsp;</td><td valign=bottom><a class="el" href="classTAO__Transport.html#a18">send</a> (<a class="elRef" doxygen="ACE.tag:../ace/" href="../ace/structiovec.html">iovec</a> *iov, int iovcnt, size_t &amp;bytes_transferred, const <a class="elRef" doxygen="ACE.tag:../ace/" href="../ace/classACE__Time__Value.html">ACE_Time_Value</a> *timeout=0)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Write the complete Message_Block chain to the connection.</em> <a href="#a18">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top><a class="elRef" doxygen="ACE.tag:../ace/" href="../ace/Basic__Types_8h.html#a38">ssize_t</a>&nbsp;</td><td valign=bottom><a class="el" href="classTAO__Transport.html#a19">recv</a> (char *buffer, size_t len, const <a class="elRef" doxygen="ACE.tag:../ace/" href="../ace/classACE__Time__Value.html">ACE_Time_Value</a> *timeout=0)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Read len bytes from into buf.</em> <a href="#a19">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>virtual int&nbsp;</td><td valign=bottom><a class="el" href="classTAO__Transport.html#a20">messaging_init</a> (<a class="el" href="namespaceCORBA.html#a3">CORBA::Octet</a> major, <a class="el" href="namespaceCORBA.html#a3">CORBA::Octet</a> minor)=0</td></tr>
<tr><td nowrap align=right valign=top>virtual int&nbsp;</td><td valign=bottom><a class="el" href="classTAO__Transport.html#a21">tear_listen_point_list</a> (<a class="el" href="classTAO__InputCDR.html">TAO_InputCDR</a> &amp;cdr)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Extracts the list of listen points from the &lt;cdr&gt; stream. The list would have the protocol specific details of the ListenPoints.</em> <a href="#a21">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>int&nbsp;</td><td valign=bottom><a class="el" href="classTAO__Transport.html#a22">generate_locate_request</a> (<a class="el" href="classTAO__Target__Specification.html">TAO_Target_Specification</a> &amp;spec, <a class="el" href="classTAO__Operation__Details.html">TAO_Operation_Details</a> &amp;opdetails, <a class="el" href="classTAO__OutputCDR.html">TAO_OutputCDR</a> &amp;output)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>This is a request for the transport object to write a LocateRequest header before it is sent out.</em> <a href="#a22">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>virtual int&nbsp;</td><td valign=bottom><a class="el" href="classTAO__Transport.html#a23">generate_request_header</a> (<a class="el" href="classTAO__Operation__Details.html">TAO_Operation_Details</a> &amp;opd, <a class="el" href="classTAO__Target__Specification.html">TAO_Target_Specification</a> &amp;spec, <a class="el" href="classTAO__OutputCDR.html">TAO_OutputCDR</a> &amp;msg)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>This is a request for the transport object to write a request header before it sends out the request.</em> <a href="#a23">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>int&nbsp;</td><td valign=bottom><a class="el" href="classTAO__Transport.html#a24">recache_transport</a> (<a class="el" href="classTAO__Transport__Descriptor__Interface.html">TAO_Transport_Descriptor_Interface</a> *desc)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>recache ourselves in the cache.</em> <a href="#a24">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>virtual void&nbsp;</td><td valign=bottom><a class="el" href="classTAO__Transport.html#a25">connection_handler_closing</a> (void)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Method for the connection handler to signify that it is being closed and destroyed.</em> <a href="#a25">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>virtual int&nbsp;</td><td valign=bottom><a class="el" href="classTAO__Transport.html#a26">handle_input_i</a> (<a class="el" href="classTAO__Resume__Handle.html">TAO_Resume_Handle</a> &amp;rh, <a class="elRef" doxygen="ACE.tag:../ace/" href="../ace/classACE__Time__Value.html">ACE_Time_Value</a> *max_wait_time=0, int block=0)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Callback to read incoming data.</em> <a href="#a26">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>virtual int&nbsp;</td><td valign=bottom><a class="el" href="classTAO__Transport.html#a27">send_request</a> (<a class="el" href="classTAO__Stub.html">TAO_Stub</a> *stub, <a class="el" href="classTAO__ORB__Core.html">TAO_ORB_Core</a> *orb_core, <a class="el" href="classTAO__OutputCDR.html">TAO_OutputCDR</a> &amp;stream, int message_semantics, <a class="elRef" doxygen="ACE.tag:../ace/" href="../ace/classACE__Time__Value.html">ACE_Time_Value</a> *max_time_wait)=0</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Prepare the waiting and demuxing strategy to receive a reply for a new request.</em> <a href="#a27">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>virtual int&nbsp;</td><td valign=bottom><a class="el" href="classTAO__Transport.html#a28">send_message</a> (<a class="el" href="classTAO__OutputCDR.html">TAO_OutputCDR</a> &amp;stream, <a class="el" href="classTAO__Stub.html">TAO_Stub</a> *stub=0, int message_semantics=TAO_Transport::TAO_TWOWAY_REQUEST, <a class="elRef" doxygen="ACE.tag:../ace/" href="../ace/classACE__Time__Value.html">ACE_Time_Value</a> *max_time_wait=0)=0</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>This method formats the stream and then sends the message on the transport.</em> <a href="#a28">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>virtual int&nbsp;</td><td valign=bottom><a class="el" href="classTAO__Transport.html#a29">send_message_shared</a> (<a class="el" href="classTAO__Stub.html">TAO_Stub</a> *stub, int message_semantics, const <a class="elRef" doxygen="ACE.tag:../ace/" href="../ace/classACE__Message__Block.html">ACE_Message_Block</a> *message_block, <a class="elRef" doxygen="ACE.tag:../ace/" href="../ace/classACE__Time__Value.html">ACE_Time_Value</a> *max_wait_time)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Sent the contents of &lt;message_block&gt;.</em> <a href="#a29">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>int&nbsp;</td><td valign=bottom><a class="el" href="classTAO__Transport.html#a30">send_message_block_chain</a> (const <a class="elRef" doxygen="ACE.tag:../ace/" href="../ace/classACE__Message__Block.html">ACE_Message_Block</a> *message_block, size_t &amp;bytes_transferred, <a class="elRef" doxygen="ACE.tag:../ace/" href="../ace/classACE__Time__Value.html">ACE_Time_Value</a> *max_wait_time=0)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Send a message block chain,.</em> <a href="#a30">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>int&nbsp;</td><td valign=bottom><a class="el" href="classTAO__Transport.html#a31">send_message_block_chain_i</a> (const <a class="elRef" doxygen="ACE.tag:../ace/" href="../ace/classACE__Message__Block.html">ACE_Message_Block</a> *message_block, size_t &amp;bytes_transferred, <a class="elRef" doxygen="ACE.tag:../ace/" href="../ace/classACE__Time__Value.html">ACE_Time_Value</a> *max_wait_time)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Send a message block chain, assuming the lock is held.</em> <a href="#a31">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classTAO__Transport.html#a32">purge_entry</a> (void)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Cache management.</em> <a href="#a32">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>int&nbsp;</td><td valign=bottom><a class="el" href="classTAO__Transport.html#a33">make_idle</a> (void)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Cache management.</em> <a href="#a33">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>int&nbsp;</td><td valign=bottom><a class="el" href="classTAO__Transport.html#a34">update_transport</a> (void)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Cache management.</em> <a href="#a34">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>int&nbsp;</td><td valign=bottom><a class="el" href="classTAO__Transport.html#a35">handle_timeout</a> (const <a class="elRef" doxygen="ACE.tag:../ace/" href="../ace/classACE__Time__Value.html">ACE_Time_Value</a> &amp;current_time, const void *act)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>The timeout callback, invoked when any of the timers related to this transport expire.</em> <a href="#a35">More...</a><em></em></font><br><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Control connection lifecycle</div></td></tr>
<tr><td colspan="2"><div class="groupText">These methods are routed through the TMS object. The TMS strategies implement them correctly.<br><br></div></td></tr>
<tr><td nowrap align=right valign=top>virtual int&nbsp;</td><td valign=bottom><a class="el" href="classTAO__Transport.html#z69_0">idle_after_send</a> (void)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Request has been just sent, but the reply is not received. Idle the transport now.</em> <a href="#z69_0">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>virtual int&nbsp;</td><td valign=bottom><a class="el" href="classTAO__Transport.html#z69_1">idle_after_reply</a> (void)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Request is sent and the reply is received. Idle the transport now.</em> <a href="#z69_1">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>virtual void&nbsp;</td><td valign=bottom><a class="el" href="classTAO__Transport.html#z69_2">close_connection</a> (void)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Call the implementation method after obtaining the lock.</em> <a href="#z69_2">More...</a><em></em></font><br><br></td></tr>
<tr><td colspan=2><br><h2>Static Public Methods</h2></td></tr>
<tr><td nowrap align=right valign=top>TAO_Transport *&nbsp;</td><td valign=bottom><a class="el" href="classTAO__Transport.html#d0">_duplicate</a> (TAO_Transport *transport)</td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classTAO__Transport.html#d1">release</a> (TAO_Transport *transport)</td></tr>
<tr><td colspan=2><br><h2>Protected Methods</h2></td></tr>
<tr><td nowrap align=right valign=top>virtual <a class="elRef" doxygen="ACE.tag:../ace/" href="../ace/classACE__Event__Handler.html">ACE_Event_Handler</a> *&nbsp;</td><td valign=bottom><a class="el" href="classTAO__Transport.html#b0">event_handler_i</a> (void)=0</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Return the event handler used to receive notifications from the Reactor.</em> <a href="#b0">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>virtual <a class="el" href="classTAO__Connection__Handler.html">TAO_Connection_Handler</a> *&nbsp;</td><td valign=bottom><a class="el" href="classTAO__Transport.html#b1">connection_handler_i</a> (void)=0</td></tr>
<tr><td nowrap align=right valign=top>virtual <a class="el" href="classTAO__Connection__Handler.html">TAO_Connection_Handler</a> *&nbsp;</td><td valign=bottom><a class="el" href="classTAO__Transport.html#b2">invalidate_event_handler_i</a> (void)=0</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Called by <code><a class="el" href="classTAO__Transport.html#a25">connection_handler_closing</a>()</code> to signal that the protocol-specific transport should dissociate itself with the protocol-specific connection handler.</em> <a href="#b2">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>virtual <a class="el" href="classTAO__Pluggable__Messaging.html">TAO_Pluggable_Messaging</a> *&nbsp;</td><td valign=bottom><a class="el" href="classTAO__Transport.html#b3">messaging_object</a> (void)=0</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Return the messaging object that is used to format the data that needs to be sent.</em> <a href="#b3">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>virtual <a class="elRef" doxygen="ACE.tag:../ace/" href="../ace/Basic__Types_8h.html#a38">ssize_t</a>&nbsp;</td><td valign=bottom><a class="el" href="classTAO__Transport.html#b4">send_i</a> (<a class="elRef" doxygen="ACE.tag:../ace/" href="../ace/structiovec.html">iovec</a> *iov, int iovcnt, size_t &amp;bytes_transferred, const <a class="elRef" doxygen="ACE.tag:../ace/" href="../ace/classACE__Time__Value.html">ACE_Time_Value</a> *timeout=0)=0</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Write the complete <a class="elRef" doxygen="ACE.tag:../ace/" href="../ace/structiovec.html">iovec</a> chain to the connection.</em> <a href="#b4">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>virtual <a class="elRef" doxygen="ACE.tag:../ace/" href="../ace/Basic__Types_8h.html#a38">ssize_t</a>&nbsp;</td><td valign=bottom><a class="el" href="classTAO__Transport.html#b5">recv_i</a> (char *buffer, size_t len, const <a class="elRef" doxygen="ACE.tag:../ace/" href="../ace/classACE__Time__Value.html">ACE_Time_Value</a> *timeout=0)=0</td></tr>
<tr><td nowrap align=right valign=top>virtual int&nbsp;</td><td valign=bottom><a class="el" href="classTAO__Transport.html#b6">register_handler_i</a> (void)=0</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Register the handler with the reactor.</em> <a href="#b6">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>int&nbsp;</td><td valign=bottom><a class="el" href="classTAO__Transport.html#b7">parse_consolidate_messages</a> (<a class="elRef" doxygen="ACE.tag:../ace/" href="../ace/classACE__Message__Block.html">ACE_Message_Block</a> &amp;bl, <a class="el" href="classTAO__Resume__Handle.html">TAO_Resume_Handle</a> &amp;rh, <a class="elRef" doxygen="ACE.tag:../ace/" href="../ace/classACE__Time__Value.html">ACE_Time_Value</a> *time=0)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Called by the handle_input_i (). This method is used to parse message read by the handle_input_i () call. It also decides whether the message needs consolidation before processing.</em> <a href="#b7">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>int&nbsp;</td><td valign=bottom><a class="el" href="classTAO__Transport.html#b8">parse_incoming_messages</a> (<a class="elRef" doxygen="ACE.tag:../ace/" href="../ace/classACE__Message__Block.html">ACE_Message_Block</a> &amp;message_block)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Method does parsing of the message if we have a fresh message in the &lt;message_block&gt; or just returns if we have read part of the previously stored message.</em> <a href="#b8">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>size_t&nbsp;</td><td valign=bottom><a class="el" href="classTAO__Transport.html#b9">missing_data</a> (<a class="elRef" doxygen="ACE.tag:../ace/" href="../ace/classACE__Message__Block.html">ACE_Message_Block</a> &amp;message_block)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Return if we have any missing data in the queue of messages or determine if we have more information left out in the presently read message to make it complete.</em> <a href="#b9">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>virtual int&nbsp;</td><td valign=bottom><a class="el" href="classTAO__Transport.html#b10">consolidate_message</a> (<a class="elRef" doxygen="ACE.tag:../ace/" href="../ace/classACE__Message__Block.html">ACE_Message_Block</a> &amp;incoming, <a class="elRef" doxygen="ACE.tag:../ace/" href="../ace/Basic__Types_8h.html#a38">ssize_t</a> missing_data, <a class="el" href="classTAO__Resume__Handle.html">TAO_Resume_Handle</a> &amp;rh, <a class="elRef" doxygen="ACE.tag:../ace/" href="../ace/classACE__Time__Value.html">ACE_Time_Value</a> *max_wait_time)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Consolidate the currently read message or consolidate the last message in the queue. The consolidation of the last message in the queue is done by calling consolidate_message_queue ().</em> <a href="#b10">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>int&nbsp;</td><td valign=bottom><a class="el" href="classTAO__Transport.html#b11">consolidate_fragments</a> (<a class="el" href="classTAO__Queued__Data.html">TAO_Queued_Data</a> *qd, <a class="el" href="classTAO__Resume__Handle.html">TAO_Resume_Handle</a> &amp;rh)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Bala: Docu???</em> <a href="#b11">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>int&nbsp;</td><td valign=bottom><a class="el" href="classTAO__Transport.html#b12">consolidate_message_queue</a> (<a class="elRef" doxygen="ACE.tag:../ace/" href="../ace/classACE__Message__Block.html">ACE_Message_Block</a> &amp;incoming, <a class="elRef" doxygen="ACE.tag:../ace/" href="../ace/Basic__Types_8h.html#a38">ssize_t</a> missing_data, <a class="el" href="classTAO__Resume__Handle.html">TAO_Resume_Handle</a> &amp;rh, <a class="elRef" doxygen="ACE.tag:../ace/" href="../ace/classACE__Time__Value.html">ACE_Time_Value</a> *max_wait_time)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>First consolidate the message queue. If the message is still not complete, try to read from the handle again to make it complete. If these dont help put the message back in the queue and try to check the queue if we have message to process. (the thread needs to do some work anyway :-)).</em> <a href="#b12">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>int&nbsp;</td><td valign=bottom><a class="el" href="classTAO__Transport.html#b13">consolidate_extra_messages</a> (<a class="elRef" doxygen="ACE.tag:../ace/" href="../ace/classACE__Message__Block.html">ACE_Message_Block</a> &amp;incoming, <a class="el" href="classTAO__Resume__Handle.html">TAO_Resume_Handle</a> &amp;rh)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Called by parse_consolidate_message () if we have more messages in one read. Queue up the messages and try to process one of them, atleast at the head of them.</em> <a href="#b13">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>int&nbsp;</td><td valign=bottom><a class="el" href="classTAO__Transport.html#b14">process_parsed_messages</a> (<a class="el" href="classTAO__Queued__Data.html">TAO_Queued_Data</a> *qd, <a class="el" href="classTAO__Resume__Handle.html">TAO_Resume_Handle</a> &amp;rh)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Process the message by sending it to the higher layers of the ORB.</em> <a href="#b14">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top><a class="el" href="classTAO__Queued__Data.html">TAO_Queued_Data</a> *&nbsp;</td><td valign=bottom><a class="el" href="classTAO__Transport.html#b15">make_queued_data</a> (<a class="elRef" doxygen="ACE.tag:../ace/" href="../ace/classACE__Message__Block.html">ACE_Message_Block</a> &amp;incoming)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Make a queued data from the &lt;incoming&gt; message block.</em> <a href="#b15">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>int&nbsp;</td><td valign=bottom><a class="el" href="classTAO__Transport.html#b16">send_message_shared_i</a> (<a class="el" href="classTAO__Stub.html">TAO_Stub</a> *stub, int message_semantics, const <a class="elRef" doxygen="ACE.tag:../ace/" href="../ace/classACE__Message__Block.html">ACE_Message_Block</a> *message_block, <a class="elRef" doxygen="ACE.tag:../ace/" href="../ace/classACE__Time__Value.html">ACE_Time_Value</a> *max_wait_time)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Implement <a class="el" href="classTAO__Transport.html#a29">send_message_shared</a>() assuming the handler_lock_ is held.</em> <a href="#b16">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>int&nbsp;</td><td valign=bottom><a class="el" href="classTAO__Transport.html#b17">check_event_handler_i</a> (const char *caller)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Check if the underlying event handler is still valid.</em> <a href="#b17">More...</a><em></em></font><br><br></td></tr>
<tr><td colspan=2><br><h2>Protected Attributes</h2></td></tr>
<tr><td nowrap align=right valign=top><a class="el" href="namespaceCORBA.html#a11">CORBA::ULong</a>&nbsp;</td><td valign=bottom><a class="el" href="classTAO__Transport.html#n0">tag_</a></td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em><a class="el" href="namespaceIOP.html">IOP</a> protocol tag.</em> <a href="#n0">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top><a class="el" href="classTAO__ORB__Core.html">TAO_ORB_Core</a> *&nbsp;</td><td valign=bottom><a class="el" href="classTAO__Transport.html#n1">orb_core_</a></td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Global orbcore resource.</em> <a href="#n1">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top><a class="el" href="classTAO__Transport__Cache__Manager.html#s2">TAO_Transport_Cache_Manager::HASH_MAP_ENTRY</a> *&nbsp;</td><td valign=bottom><a class="el" href="classTAO__Transport.html#n2">cache_map_entry_</a></td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Our entry in the cache. We dont own this. It is here for our convinience. We cannot just change things around.</em> <a href="#n2">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top><a class="el" href="classTAO__Transport__Mux__Strategy.html">TAO_Transport_Mux_Strategy</a> *&nbsp;</td><td valign=bottom><a class="el" href="classTAO__Transport.html#n3">tms_</a></td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Strategy to decide whether multiple requests can be sent over the same connection or the connection is exclusive for a request.</em> <a href="#n3">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top><a class="el" href="classTAO__Wait__Strategy.html">TAO_Wait_Strategy</a> *&nbsp;</td><td valign=bottom><a class="el" href="classTAO__Transport.html#n4">ws_</a></td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Strategy for waiting for the reply after sending the request.</em> <a href="#n4">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>int&nbsp;</td><td valign=bottom><a class="el" href="classTAO__Transport.html#n5">bidirectional_flag_</a></td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Use to check if bidirectional info has been synchronized with the peer.</em> <a href="#n5">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top><a class="el" href="classTAO__Queued__Message.html">TAO_Queued_Message</a> *&nbsp;</td><td valign=bottom><a class="el" href="classTAO__Transport.html#n6">head_</a></td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Implement the outgoing data queue.</em> <a href="#n6">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top><a class="el" href="classTAO__Queued__Message.html">TAO_Queued_Message</a> *&nbsp;</td><td valign=bottom><a class="el" href="classTAO__Transport.html#n7">tail_</a></td></tr>
<tr><td nowrap align=right valign=top><a class="el" href="classTAO__Incoming__Message__Queue.html">TAO_Incoming_Message_Queue</a>&nbsp;</td><td valign=bottom><a class="el" href="classTAO__Transport.html#n8">incoming_message_queue_</a></td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Queue of the incoming messages..</em> <a href="#n8">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top><a class="elRef" doxygen="ACE.tag:../ace/" href="../ace/classACE__Time__Value.html">ACE_Time_Value</a>&nbsp;</td><td valign=bottom><a class="el" href="classTAO__Transport.html#n9">current_deadline_</a></td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>The queue will start draining no later than &lt;queing_deadline_&gt; *if* the deadline is.</em> <a href="#n9">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>long&nbsp;</td><td valign=bottom><a class="el" href="classTAO__Transport.html#n10">flush_timer_id_</a></td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>The timer ID.</em> <a href="#n10">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top><a class="el" href="classTAO__Transport__Timer.html">TAO_Transport_Timer</a>&nbsp;</td><td valign=bottom><a class="el" href="classTAO__Transport.html#n11">transport_timer_</a></td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>The adapter used to receive timeout callbacks from the Reactor.</em> <a href="#n11">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top><a class="elRef" doxygen="ACE.tag:../ace/" href="../ace/classACE__Lock.html">ACE_Lock</a> *&nbsp;</td><td valign=bottom><a class="el" href="classTAO__Transport.html#n12">handler_lock_</a></td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Lock that insures that activities that *might* use handler-related resources (such as a connection handler) get serialized.</em> <a href="#n12">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>int&nbsp;</td><td valign=bottom><a class="el" href="classTAO__Transport.html#n13">id_</a></td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>A unique identifier for the transport.</em> <a href="#n13">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>unsigned long&nbsp;</td><td valign=bottom><a class="el" href="classTAO__Transport.html#n14">purging_order_</a></td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Used by the LRU, LFU and FIFO Connection Purging Strategies.</em> <a href="#n14">More...</a><em></em></font><br><br></td></tr>
<tr><td colspan=2><br><h2>Private Methods</h2></td></tr>
<tr><td nowrap align=right valign=top><a class="el" href="classTAO__Transport__Cache__Manager.html">TAO_Transport_Cache_Manager</a> &amp;&nbsp;</td><td valign=bottom><a class="el" href="classTAO__Transport.html#c0">transport_cache_manager</a> (void)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Helper method that returns the Transport Cache Manager.</em> <a href="#c0">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>int&nbsp;</td><td valign=bottom><a class="el" href="classTAO__Transport.html#c1">drain_queue</a> (void)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Send some of the data in the queue.</em> <a href="#c1">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>int&nbsp;</td><td valign=bottom><a class="el" href="classTAO__Transport.html#c2">drain_queue_i</a> (void)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Implement <a class="el" href="classTAO__Transport.html#c1">drain_queue</a>() assuming the lock is held.</em> <a href="#c2">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>int&nbsp;</td><td valign=bottom><a class="el" href="classTAO__Transport.html#c3">queue_is_empty_i</a> (void)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Check if there are messages pending in the queue.</em> <a href="#c3">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>int&nbsp;</td><td valign=bottom><a class="el" href="classTAO__Transport.html#c4">drain_queue_helper</a> (int &amp;iovcnt, <a class="elRef" doxygen="ACE.tag:../ace/" href="../ace/structiovec.html">iovec</a> iov[])</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>A helper routine used in <a class="el" href="classTAO__Transport.html#c2">drain_queue_i</a>().</em> <a href="#c4">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>int&nbsp;</td><td valign=bottom><a class="el" href="classTAO__Transport.html#c5">schedule_output_i</a> (void)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Schedule <a class="el" href="classTAO__Transport.html#a6">handle_output</a>() callbacks.</em> <a href="#c5">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>int&nbsp;</td><td valign=bottom><a class="el" href="classTAO__Transport.html#c6">cancel_output_i</a> (void)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Cancel <a class="el" href="classTAO__Transport.html#a6">handle_output</a>() callbacks.</em> <a href="#c6">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classTAO__Transport.html#c7">cleanup_queue</a> (size_t byte_count)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Cleanup the queue.</em> <a href="#c7">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>int&nbsp;</td><td valign=bottom><a class="el" href="classTAO__Transport.html#c8">check_buffering_constraints_i</a> (<a class="el" href="classTAO__Stub.html">TAO_Stub</a> *stub, int &amp;must_flush)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Copy the contents of a message block into a Queued_Message <a class="el" href="classTAO__Queued__Message.html">TAO_Queued_Message</a> *copy_message_block (const <a class="elRef" doxygen="ACE.tag:../ace/" href="../ace/classACE__Message__Block.html">ACE_Message_Block</a> *mb); Check if the buffering constraints have been reached.</em> <a href="#c8">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>int&nbsp;</td><td valign=bottom><a class="el" href="classTAO__Transport.html#c9">send_synchronous_message_i</a> (const <a class="elRef" doxygen="ACE.tag:../ace/" href="../ace/classACE__Message__Block.html">ACE_Message_Block</a> *message_block, <a class="elRef" doxygen="ACE.tag:../ace/" href="../ace/classACE__Time__Value.html">ACE_Time_Value</a> *max_wait_time)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Send a synchronous message, i.e. block until the message is on the wire.</em> <a href="#c9">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>int&nbsp;</td><td valign=bottom><a class="el" href="classTAO__Transport.html#c10">send_reply_message_i</a> (const <a class="elRef" doxygen="ACE.tag:../ace/" href="../ace/classACE__Message__Block.html">ACE_Message_Block</a> *message_block, <a class="elRef" doxygen="ACE.tag:../ace/" href="../ace/classACE__Time__Value.html">ACE_Time_Value</a> *max_wait_time)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Send a reply message, i.e. do not block until the message is on the wire, but just return after adding them to the queue.</em> <a href="#c10">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>int&nbsp;</td><td valign=bottom><a class="el" href="classTAO__Transport.html#c11">send_synch_message_helper_i</a> (<a class="el" href="classTAO__Synch__Queued__Message.html">TAO_Synch_Queued_Message</a> &amp;s, <a class="elRef" doxygen="ACE.tag:../ace/" href="../ace/classACE__Time__Value.html">ACE_Time_Value</a> *max_wait_time)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>A helper method used by &lt;send_synchronous_message_i&gt; and &lt;send_reply_message_i&gt;. Reusable code that could be used by both the methods.</em> <a href="#c11">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>int&nbsp;</td><td valign=bottom><a class="el" href="classTAO__Transport.html#c12">flush_timer_pending</a> (void) const</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Check if the flush timer is still pending.</em> <a href="#c12">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classTAO__Transport.html#c13">reset_flush_timer</a> (void)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>The flush timer expired or was explicitly cancelled, mark it as not pending.</em> <a href="#c13">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classTAO__Transport.html#c14">report_invalid_event_handler</a> (const char *caller)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Print out error messages if the event handler is not valid.</em> <a href="#c14">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>int&nbsp;</td><td valign=bottom><a class="el" href="classTAO__Transport.html#c15">process_queue_head</a> (<a class="el" href="classTAO__Resume__Handle.html">TAO_Resume_Handle</a> &amp;rh)</td></tr>
<tr><td nowrap align=right valign=top>int&nbsp;</td><td valign=bottom><a class="el" href="classTAO__Transport.html#c16">notify_reactor</a> (void)</td></tr>
<tr><td nowrap align=right valign=top><a class="el" href="classTAO__Connection__Handler.html">TAO_Connection_Handler</a> *&nbsp;</td><td valign=bottom><a class="el" href="classTAO__Transport.html#c17">invalidate_event_handler</a> (void)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Grab the mutex and then call <a class="el" href="classTAO__Transport.html#b2">invalidate_event_handler_i</a>().</em> <a href="#c17">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classTAO__Transport.html#c18">send_connection_closed_notifications</a> (void)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Notify all the components inside a Transport when the underlying connection is closed.</em> <a href="#c18">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classTAO__Transport.html#c19">send_connection_closed_notifications_i</a> (void)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Assume the lock is held.</em> <a href="#c19">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classTAO__Transport.html#c20">close_connection_i</a> (void)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Implement <a class="el" href="classTAO__Transport.html#z69_2">close_connection</a>() assuming the handler_lock_ is held.</em> <a href="#c20">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classTAO__Transport.html#c21">close_connection_no_purge</a> (void)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Close the underlying connection, do not purge the entry from the map (supposedly it was purged already, trust the caller, yuck!).</em> <a href="#c21">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classTAO__Transport.html#c22">close_connection_shared</a> (int purge, <a class="el" href="classTAO__Connection__Handler.html">TAO_Connection_Handler</a> *eh)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Close the underlying connection, implements the code shared by all the close_connection_* variants.</em> <a href="#c22">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>&nbsp;</td><td valign=bottom><a class="el" href="classTAO__Transport.html#c23">TAO_Transport</a> (const TAO_Transport &amp;)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Prohibited.</em> <a href="#c23">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classTAO__Transport.html#c24">operator=</a> (const TAO_Transport &amp;)</td></tr>
<tr><td colspan=2><br><h2>Friends</h2></td></tr>
<tr><td nowrap align=right valign=top>class&nbsp;</td><td valign=bottom><a class="el" href="classTAO__Transport.html#l0">TAO_Block_Flushing_Strategy</a></td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>This class needs priviledged access to - <a class="el" href="classTAO__Transport.html#c3">queue_is_empty_i</a>() - <a class="el" href="classTAO__Transport.html#c2">drain_queue_i</a>().</em> <a href="#l0">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>class&nbsp;</td><td valign=bottom><a class="el" href="classTAO__Transport.html#l1">TAO_Reactive_Flushing_Strategy</a></td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>These classes need privileged access to: - <a class="el" href="classTAO__Transport.html#c5">schedule_output_i</a>() - <a class="el" href="classTAO__Transport.html#c6">cancel_output_i</a>().</em> <a href="#l1">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>class&nbsp;</td><td valign=bottom><a class="el" href="classTAO__Transport.html#l2">TAO_Leader_Follower_Flushing_Strategy</a></td></tr>
<tr><td nowrap align=right valign=top>class&nbsp;</td><td valign=bottom><a class="el" href="classTAO__Transport.html#l3">TAO_Transport_Cache_Manager</a></td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>This class needs priviledged access to: close_connection_no_purge ().</em> <a href="#l3">More...</a><em></em></font><br><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Generic definitions for the Transport class.
<p>

<p>
 The transport object is created in the Service handler constructor and deleted in the Service Handler's destructor!!
<p>
The main responsability of a Transport object is to encapsulate a connection, and provide a transport independent way to send and receive data. Since <a class="el" href="namespaceTAO.html">TAO</a> is heavily based on the Reactor for all if not all its I/O the Transport class is usually implemented with a helper Connection Handler that adapts the generic Transport interface to the Reactor types.
<p>
<h3>The outgoing data path:</h3>

<p>
One of the responsibilities of the TAO_Transport class is to send out <a class="el" href="namespaceGIOP.html">GIOP</a> messages as efficiently as possible. In most cases messages are put out in FIFO order, the transport object will put out the message using a single system call and return control to the application. However, for oneways and AMI requests it may be more efficient (or required if the SYNC_NONE policy is in effect) to queue the messages until a large enough data set is available. Another reason to queue is that some applications cannot block for I/O, yet they want to send messages so large that a single write() operation would not be able to cope with them. In such cases we need to queue the data and use the Reactor to drain the queue.
<p>
Therefore, the Transport class may need to use a queue to temporarily hold the messages, and, in some configurations, it may need to use the Reactor to concurrently drain such queues.
<p>
<h3>Out of order messages:</h3>
 <a class="el" href="namespaceTAO.html">TAO</a> provides explicit policies to send 'urgent' messages. Such messages may put at the head of the queue. However, they cannot be sent immediately because the transport may already be sending another message in a reactive fashion.
<p>
Consequently, the Transport must also know if the head of the queue has been partially sent. In that case new messages can only follow the head. Only once the head is completely sent we can start sending new messages.
<p>
<h3>Waiting threads:</h3>
 One or more threads can be blocked waiting for the connection to completely send the message. The thread should return as soon as its message has been sent, so a per-thread condition is required. This suggest that simply using a <a class="elRef" doxygen="ACE.tag:../ace/" href="../ace/classACE__Message__Queue.html">ACE_Message_Queue</a> would not be enough: there is a significant amount of ancillary information, to keep on each message that the Message_Block class does not provide room for.
<p>
Blocking I/O is still attractive for some applications. First, my eliminating the Reactor overhead performance is improved when sending large blocks of data. Second, using the Reactor to send out data opens the door for nested upcalls, yet some applications cannot deal with the reentrancy issues in this case.
<p>
<h3>Timeouts:</h3>
 Some or all messages could have a timeout period attached to them. The timeout source could either be some high-level policy or maybe some strategy to prevent denial of service attacks. In any case the timeouts are per-message, and later messages could have shorter timeouts. In fact, some kind of scheduling (such as EDF) could be required in a few applications.
<p>
<h3>Conclusions:</h3>
 The outgoing data path consist in several components:
<p>
<ul>
<li>A queue of pending messages<li>A message currently being transmitted<li>A per-transport 'send strategy' to choose between blocking on write, blocking on the reactor or blockin on leader/follower.<li>A per-message 'waiting object'<li>A per-message timeout</ul>
The Transport object provides a single method to send request messages (send_request_message ()).
<p>
<h3>The incoming data path:</h3>

<p>
One of the main responsibilities of the transport is to read and process the incoming <a class="el" href="namespaceGIOP.html">GIOP</a> message as quickly and efficiently as possible. There are other forces that needs to be given due consideration. They are<ul>
<li>Multiple threads should be able to tarverse along the same data path but should not be able to read from the same handle at the same time ie. the handle should not be shared between threads at any instant.<li>Reads on the handle could give one or more messages.<li>Minimise locking and copying overhead when trying to attack the above.</ul>
<h3> Parsing messages (<a class="el" href="namespaceGIOP.html">GIOP</a>) &amp; processing the message:</h3>

<p>
The messages should be checked for validity and the right information should be sent to the higher layer for processing. The process of doing a sanity check and preparing the messages for the higher layers of the ORB are done by the messaging protocol.
<p>
<h3> Design forces and Challenges </h3>

<p>
To keep things as efficient as possible for medium sized requests, it would be good to minimise data copying and locking along the incoming path ie. from the time of reading the data from the handle to the application. We achieve this by creating a buffer on stack and reading the data from the handle into the buffer. We then pass the same data block (the buffer is encapsulated into a data block) to the higher layers of the ORB. The problems stem from the following (a) Data is bigger than the buffer that we have on stack (b) Transports like TCP do not guarantee availability of the whole chunk of data in one shot. Data could trickle in byte by byte. (c) Single read gives multiple messages
<p>
We solve the problems as follows
<p>
(a) First do a read with the buffer on stack. Query the underlying messaging object whether the message has any incomplete portion. If so, we just grow the buffer for the missing size and read the rest of the message. We free the handle and then send the message to the higher layers of the ORB for processing.
<p>
(b) If we block (ie. if we receive a EWOULDBLOCK) while trying to do the above (ie. trying to read after growing the buffer size) we put the message in a queue and return back to the reactor. The reactor would call us back when the handle becomes read ready.
<p>
(c) If we get multiple messages (possible if the client connected to the server sends oneways or AMI requests), we parse and split the messages. Every message is put in the queue. Once the messages are queued, the thread picks up one message to send to the higher layers of the ORB. Before doing that, if it finds more messages, it sends a notify to the reactor without resuming the handle. The next thread picks up a message from the queue and processes that. Once the queue is drained the last thread resumes the handle.
<p>
<h3> Sending Replies </h3>

<p>
We could use the outgoing path of the ORB to send replies. This would allow us to reuse most of the code in the outgoing data path. We were doing this till TAO-1.2.3. We run in to problems. When writing the reply the ORB gets flow controlled, and the ORB tries to flush the message by going into the reactor. This resulted in unnecessary nesting. The thread that gets into the Reactor could potentially handle other messages (incoming or outgoing) and the stack starts growing leading to crashes.
<p>
<h3> Solution to the nesting problem </h3>

<p>
The solution that we (plan to) adopt is pretty straight forward. The thread sending replies will not block to send the replies but queue the replies and return to the Reactor. (Note the careful usages of the terms "blocking in the Reactor" as opposed to "return back to the Reactor".
<p>
<b>See Also:</b>
<p>
<a href="http://deuce.doc.wustl.edu/cvsweb/ace-latest.cgi/ACE_wrappers/TAO/docs/pluggable_protocols/index.html">http://deuce.doc.wustl.edu/cvsweb/ace-latest.cgi/ACE_wrappers/TAO/docs/pluggable_protocols/index.html</a> 
<p>
<hr><h2>Member Enumeration Documentation</h2>
<a name="s3" doxytag="TAO_Transport::@10"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> anonymous enum
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<dl compact><dt><b>
Enumeration values:</b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em><a name="s3s0" doxytag="TAO_ONEWAY_REQUEST"></a><em>TAO_ONEWAY_REQUEST</em></em>&nbsp;</td><td>
</td></tr>
<tr><td valign=top><em><a name="s3s1" doxytag="TAO_TWOWAY_REQUEST"></a><em>TAO_TWOWAY_REQUEST</em></em>&nbsp;</td><td>
</td></tr>
<tr><td valign=top><em><a name="s3s2" doxytag="TAO_REPLY"></a><em>TAO_REPLY</em></em>&nbsp;</td><td>
</td></tr>
</table>
</dl>
    </td>
  </tr>
</table>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a name="a0" doxytag="TAO_Transport::TAO_Transport"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> TAO_Transport::TAO_Transport </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="namespaceCORBA.html#a11">CORBA::ULong</a>&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>tag</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="classTAO__ORB__Core.html">TAO_ORB_Core</a> *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>orb_core</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
default creator, requres the tag value be supplied.
<p>
    </td>
  </tr>
</table>
<a name="a1" doxytag="TAO_Transport::~TAO_Transport"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> TAO_Transport::~TAO_Transport </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
destructor.
<p>
    </td>
  </tr>
</table>
<a name="c23" doxytag="TAO_Transport::TAO_Transport"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> TAO_Transport::TAO_Transport </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const TAO_Transport &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [private]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Prohibited.
<p>
    </td>
  </tr>
</table>
<hr><h2>Member Function Documentation</h2>
<a name="d0" doxytag="TAO_Transport::_duplicate"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> TAO_Transport * TAO_Transport::_duplicate </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">TAO_Transport *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>transport</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [static]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a name="a8" doxytag="TAO_Transport::bidirectional_flag"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="elRef" doxygen="ACE.tag:../ace/" href="../ace/OS_8i.html#a0">ACE_INLINE</a> void TAO_Transport::bidirectional_flag </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>flag</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a name="a7" doxytag="TAO_Transport::bidirectional_flag"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="elRef" doxygen="ACE.tag:../ace/" href="../ace/OS_8i.html#a0">ACE_INLINE</a> int TAO_Transport::bidirectional_flag </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap> const</td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get/Set the bidirectional flag.
<p>
    </td>
  </tr>
</table>
<a name="a10" doxytag="TAO_Transport::cache_map_entry"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="elRef" doxygen="ACE.tag:../ace/" href="../ace/OS_8i.html#a0">ACE_INLINE</a> <a class="el" href="classTAO__Transport__Cache__Manager.html#s2">TAO_Transport_Cache_Manager::HASH_MAP_ENTRY</a> * TAO_Transport::cache_map_entry </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a name="a9" doxytag="TAO_Transport::cache_map_entry"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="elRef" doxygen="ACE.tag:../ace/" href="../ace/OS_8i.html#a0">ACE_INLINE</a> void TAO_Transport::cache_map_entry </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classTAO__Transport__Cache__Manager.html#s2">TAO_Transport_Cache_Manager::HASH_MAP_ENTRY</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>entry</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Set/Get the Cache Map entry.
<p>
    </td>
  </tr>
</table>
<a name="c6" doxytag="TAO_Transport::cancel_output_i"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int TAO_Transport::cancel_output_i </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [private]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Cancel <a class="el" href="classTAO__Transport.html#a6">handle_output</a>() callbacks.
<p>
    </td>
  </tr>
</table>
<a name="c8" doxytag="TAO_Transport::check_buffering_constraints_i"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int TAO_Transport::check_buffering_constraints_i </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classTAO__Stub.html">TAO_Stub</a> *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>stub</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>must_flush</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [private]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Copy the contents of a message block into a Queued_Message <a class="el" href="classTAO__Queued__Message.html">TAO_Queued_Message</a> *copy_message_block (const <a class="elRef" doxygen="ACE.tag:../ace/" href="../ace/classACE__Message__Block.html">ACE_Message_Block</a> *mb); Check if the buffering constraints have been reached.
<p>
    </td>
  </tr>
</table>
<a name="b17" doxytag="TAO_Transport::check_event_handler_i"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="elRef" doxygen="ACE.tag:../ace/" href="../ace/OS_8i.html#a0">ACE_INLINE</a> int TAO_Transport::check_event_handler_i </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const char *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>caller</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [protected]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Check if the underlying event handler is still valid.
<p>
<dl compact><dt><b>
Returns: </b><dd>
Returns -1 if not, 0 if it is. </dl>    </td>
  </tr>
</table>
<a name="c7" doxytag="TAO_Transport::cleanup_queue"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void TAO_Transport::cleanup_queue </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">size_t&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>byte_count</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [private]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Cleanup the queue.
<p>
Exactly &lt;byte_count&gt; bytes have been sent, the queue must be cleaned up as potentially several messages have been completely sent out. It leaves on head_ the next message to send out.     </td>
  </tr>
</table>
<a name="z69_2" doxytag="TAO_Transport::close_connection"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void TAO_Transport::close_connection </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Call the implementation method after obtaining the lock.
<p>
    </td>
  </tr>
</table>
<a name="c20" doxytag="TAO_Transport::close_connection_i"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void TAO_Transport::close_connection_i </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [private]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Implement <a class="el" href="classTAO__Transport.html#z69_2">close_connection</a>() assuming the handler_lock_ is held.
<p>
    </td>
  </tr>
</table>
<a name="c21" doxytag="TAO_Transport::close_connection_no_purge"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void TAO_Transport::close_connection_no_purge </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [private]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Close the underlying connection, do not purge the entry from the map (supposedly it was purged already, trust the caller, yuck!).
<p>
    </td>
  </tr>
</table>
<a name="c22" doxytag="TAO_Transport::close_connection_shared"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void TAO_Transport::close_connection_shared </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>purge</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="classTAO__Connection__Handler.html">TAO_Connection_Handler</a> *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>eh</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [private]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Close the underlying connection, implements the code shared by all the close_connection_* variants.
<p>
    </td>
  </tr>
</table>
<a name="a25" doxytag="TAO_Transport::connection_handler_closing"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void TAO_Transport::connection_handler_closing </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Method for the connection handler to signify that it is being closed and destroyed.
<p>
    </td>
  </tr>
</table>
<a name="b1" doxytag="TAO_Transport::connection_handler_i"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> virtual <a class="el" href="classTAO__Connection__Handler.html">TAO_Connection_Handler</a>* TAO_Transport::connection_handler_i </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [protected, pure virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Reimplemented in <a class="el" href="classTAO__IIOP__Transport.html#z16_5">TAO_IIOP_Transport</a>.    </td>
  </tr>
</table>
<a name="b13" doxytag="TAO_Transport::consolidate_extra_messages"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int TAO_Transport::consolidate_extra_messages </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="elRef" doxygen="ACE.tag:../ace/" href="../ace/classACE__Message__Block.html">ACE_Message_Block</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>incoming</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="classTAO__Resume__Handle.html">TAO_Resume_Handle</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>rh</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [protected]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Called by parse_consolidate_message () if we have more messages in one read. Queue up the messages and try to process one of them, atleast at the head of them.
<p>
    </td>
  </tr>
</table>
<a name="b11" doxytag="TAO_Transport::consolidate_fragments"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int TAO_Transport::consolidate_fragments </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classTAO__Queued__Data.html">TAO_Queued_Data</a> *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>qd</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="classTAO__Resume__Handle.html">TAO_Resume_Handle</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>rh</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [protected]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Bala: Docu???
<p>
@     </td>
  </tr>
</table>
<a name="b10" doxytag="TAO_Transport::consolidate_message"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int TAO_Transport::consolidate_message </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="elRef" doxygen="ACE.tag:../ace/" href="../ace/classACE__Message__Block.html">ACE_Message_Block</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>incoming</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="elRef" doxygen="ACE.tag:../ace/" href="../ace/Basic__Types_8h.html#a38">ssize_t</a>&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>missing_data</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="classTAO__Resume__Handle.html">TAO_Resume_Handle</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>rh</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="elRef" doxygen="ACE.tag:../ace/" href="../ace/classACE__Time__Value.html">ACE_Time_Value</a> *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>max_wait_time</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [protected, virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Consolidate the currently read message or consolidate the last message in the queue. The consolidation of the last message in the queue is done by calling consolidate_message_queue ().
<p>
    </td>
  </tr>
</table>
<a name="b12" doxytag="TAO_Transport::consolidate_message_queue"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int TAO_Transport::consolidate_message_queue </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="elRef" doxygen="ACE.tag:../ace/" href="../ace/classACE__Message__Block.html">ACE_Message_Block</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>incoming</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="elRef" doxygen="ACE.tag:../ace/" href="../ace/Basic__Types_8h.html#a38">ssize_t</a>&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>missing_data</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="classTAO__Resume__Handle.html">TAO_Resume_Handle</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>rh</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="elRef" doxygen="ACE.tag:../ace/" href="../ace/classACE__Time__Value.html">ACE_Time_Value</a> *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>max_wait_time</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [protected]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
First consolidate the message queue. If the message is still not complete, try to read from the handle again to make it complete. If these dont help put the message back in the queue and try to check the queue if we have message to process. (the thread needs to do some work anyway :-)).
<p>
    </td>
  </tr>
</table>
<a name="c1" doxytag="TAO_Transport::drain_queue"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int TAO_Transport::drain_queue </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [private]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Send some of the data in the queue.
<p>
As the outgoing data is drained this method is invoked to send as much of the current message as possible.
<p>
Returns 0 if there is more data to send, -1 if there was an error and 1 if the message was completely sent.     </td>
  </tr>
</table>
<a name="c4" doxytag="TAO_Transport::drain_queue_helper"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int TAO_Transport::drain_queue_helper </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>iovcnt</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="elRef" doxygen="ACE.tag:../ace/" href="../ace/structiovec.html">iovec</a>&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>iov</em>[]</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [private]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
A helper routine used in <a class="el" href="classTAO__Transport.html#c2">drain_queue_i</a>().
<p>
    </td>
  </tr>
</table>
<a name="c2" doxytag="TAO_Transport::drain_queue_i"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int TAO_Transport::drain_queue_i </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [private]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Implement <a class="el" href="classTAO__Transport.html#c1">drain_queue</a>() assuming the lock is held.
<p>
    </td>
  </tr>
</table>
<a name="b0" doxytag="TAO_Transport::event_handler_i"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> virtual <a class="elRef" doxygen="ACE.tag:../ace/" href="../ace/classACE__Event__Handler.html">ACE_Event_Handler</a>* TAO_Transport::event_handler_i </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [protected, pure virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Return the event handler used to receive notifications from the Reactor.
<p>
Normally a concrete TAO_Transport object has-a <a class="elRef" doxygen="ACE.tag:../ace/" href="../ace/classACE__Event__Handler.html">ACE_Event_Handler</a> member that function as an adapter between the <a class="elRef" doxygen="ACE.tag:../ace/" href="../ace/classACE__Reactor.html">ACE_Reactor</a> framework and the <a class="el" href="namespaceTAO.html">TAO</a> pluggable protocol framework. In all the protocols implemented so far this role is fullfilled by an instance of <a class="elRef" doxygen="ACE.tag:../ace/" href="../ace/classACE__Svc__Handler.html">ACE_Svc_Handler</a>.
<p>
<dl compact><dt><b>
<a class="el" href="todo.html#_todo000019">Todo: </a></b><dd>
 Since we only use a limited functionality of <a class="elRef" doxygen="ACE.tag:../ace/" href="../ace/classACE__Svc__Handler.html">ACE_Svc_Handler</a> we could probably implement a generic adapter class (TAO_Transport_Event_Handler or something), this will reduce footprint and simplify the process of implementing a pluggable protocol. </dl> 
<p>
Reimplemented in <a class="el" href="classTAO__IIOP__Transport.html#z16_6">TAO_IIOP_Transport</a>.    </td>
  </tr>
</table>
<a name="c12" doxytag="TAO_Transport::flush_timer_pending"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="elRef" doxygen="ACE.tag:../ace/" href="../ace/OS_8i.html#a0">ACE_INLINE</a> int TAO_Transport::flush_timer_pending </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap> const<code> [private]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Check if the flush timer is still pending.
<p>
    </td>
  </tr>
</table>
<a name="a22" doxytag="TAO_Transport::generate_locate_request"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int TAO_Transport::generate_locate_request </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classTAO__Target__Specification.html">TAO_Target_Specification</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>spec</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="classTAO__Operation__Details.html">TAO_Operation_Details</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>opdetails</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="classTAO__OutputCDR.html">TAO_OutputCDR</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>output</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This is a request for the transport object to write a LocateRequest header before it is sent out.
<p>
    </td>
  </tr>
</table>
<a name="a23" doxytag="TAO_Transport::generate_request_header"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int TAO_Transport::generate_request_header </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classTAO__Operation__Details.html">TAO_Operation_Details</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>opdetails</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="classTAO__Target__Specification.html">TAO_Target_Specification</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>spec</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="classTAO__OutputCDR.html">TAO_OutputCDR</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>msg</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This is a request for the transport object to write a request header before it sends out the request.
<p>

<p>
Reimplemented in <a class="el" href="classTAO__IIOP__Transport.html#z16_2">TAO_IIOP_Transport</a>.    </td>
  </tr>
</table>
<a name="a26" doxytag="TAO_Transport::handle_input_i"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int TAO_Transport::handle_input_i </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classTAO__Resume__Handle.html">TAO_Resume_Handle</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>rh</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="elRef" doxygen="ACE.tag:../ace/" href="../ace/classACE__Time__Value.html">ACE_Time_Value</a> *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>max_wait_time</em> = 0, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>block</em> = 0</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Callback to read incoming data.
<p>
The <a class="elRef" doxygen="ACE.tag:../ace/" href="../ace/classACE__Event__Handler.html">ACE_Event_Handler</a> adapter invokes this method as part of its handle_input() operation.
<p>

<p>
<dl compact><dt><b>
<a class="el" href="todo.html#_todo000020">Todo: </a></b><dd>
: the method name is confusing! Calling it handle_input() would probably make things easier to understand and follow!</dl>
<p>
Once a complete message is read the Transport class delegates on the <a class="el" href="namespaceMessaging.html">Messaging</a> layer to invoke the right upcall (on the server) or the <a class="el" href="classTAO__Reply__Dispatcher.html">TAO_Reply_Dispatcher</a> (on the client side).<dl compact><dt><b>
Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>max_wait_time</em>&nbsp;</td><td>
In some cases the I/O is synchronous, e.g. a thread-per-connection server or when Wait_On_Read is enabled. In those cases a maximum read time can be specified.</td></tr>
<tr><td valign=top><em>block</em>&nbsp;</td><td>
Is deprecated and ignored. </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<a name="a6" doxytag="TAO_Transport::handle_output"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int TAO_Transport::handle_output </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Callback method to reactively drain the outgoing data queue.
<p>
    </td>
  </tr>
</table>
<a name="a35" doxytag="TAO_Transport::handle_timeout"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int TAO_Transport::handle_timeout </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="elRef" doxygen="ACE.tag:../ace/" href="../ace/classACE__Time__Value.html">ACE_Time_Value</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>current_time</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const void *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>act</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
The timeout callback, invoked when any of the timers related to this transport expire.
<p>
<dl compact><dt><b>
Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>current_time</em>&nbsp;</td><td>
The current time as reported from the Reactor </td></tr>
<tr><td valign=top><em>act</em>&nbsp;</td><td>
The Asynchronous Completion Token. Currently it is interpreted as follows:<ul>
<li>If the ACT is the address of this-&gt;current_deadline_ the queueing timeout has expired and the queue should start flushing.</ul>
</td></tr>
</table>
</dl><dl compact><dt><b>
Returns: </b><dd>
Returns 0 if there are no problems, -1 if there is an error</dl><dl compact><dt><b>
<a class="el" href="todo.html#_todo000023">Todo: </a></b><dd>
 In the future this function could be used to expire messages (oneways) that have been sitting for too long on the queue. </dl>     </td>
  </tr>
</table>
<a name="a12" doxytag="TAO_Transport::id"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="elRef" doxygen="ACE.tag:../ace/" href="../ace/OS_8i.html#a0">ACE_INLINE</a> void TAO_Transport::id </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>id</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a name="a11" doxytag="TAO_Transport::id"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="elRef" doxygen="ACE.tag:../ace/" href="../ace/OS_8i.html#a0">ACE_INLINE</a> int TAO_Transport::id </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap> const</td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Set and Get the identifier for this transport instance.
<p>
If not set, this will return an integer representation of the <code>this</code> pointer for the instance on which it's called.     </td>
  </tr>
</table>
<a name="z69_1" doxytag="TAO_Transport::idle_after_reply"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int TAO_Transport::idle_after_reply </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Request is sent and the reply is received. Idle the transport now.
<p>
    </td>
  </tr>
</table>
<a name="z69_0" doxytag="TAO_Transport::idle_after_send"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int TAO_Transport::idle_after_send </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Request has been just sent, but the reply is not received. Idle the transport now.
<p>
    </td>
  </tr>
</table>
<a name="c17" doxytag="TAO_Transport::invalidate_event_handler"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="classTAO__Connection__Handler.html">TAO_Connection_Handler</a> * TAO_Transport::invalidate_event_handler </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [private]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Grab the mutex and then call <a class="el" href="classTAO__Transport.html#b2">invalidate_event_handler_i</a>().
<p>
    </td>
  </tr>
</table>
<a name="b2" doxytag="TAO_Transport::invalidate_event_handler_i"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> virtual <a class="el" href="classTAO__Connection__Handler.html">TAO_Connection_Handler</a>* TAO_Transport::invalidate_event_handler_i </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [protected, pure virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Called by <code><a class="el" href="classTAO__Transport.html#a25">connection_handler_closing</a>()</code> to signal that the protocol-specific transport should dissociate itself with the protocol-specific connection handler.
<p>
Typically, this just sets the pointer to the associated connection handler to zero, although it could also clear out any additional resources associated with the handler association.
<p>
<dl compact><dt><b>
Returns: </b><dd>
The old event handler </dl>
<p>
Reimplemented in <a class="el" href="classTAO__IIOP__Transport.html#z16_7">TAO_IIOP_Transport</a>.    </td>
  </tr>
</table>
<a name="a33" doxytag="TAO_Transport::make_idle"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int TAO_Transport::make_idle </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Cache management.
<p>
    </td>
  </tr>
</table>
<a name="b15" doxytag="TAO_Transport::make_queued_data"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="classTAO__Queued__Data.html">TAO_Queued_Data</a> * TAO_Transport::make_queued_data </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="elRef" doxygen="ACE.tag:../ace/" href="../ace/classACE__Message__Block.html">ACE_Message_Block</a> &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>incoming</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [protected]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Make a queued data from the &lt;incoming&gt; message block.
<p>
    </td>
  </tr>
</table>
<a name="a20" doxytag="TAO_Transport::messaging_init"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> virtual int TAO_Transport::messaging_init </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="namespaceCORBA.html#a3">CORBA::Octet</a>&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>major</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="namespaceCORBA.html#a3">CORBA::Octet</a>&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>minor</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Initialising the messaging object. This would be used by the connector side. On the acceptor side the connection handler would take care of the messaging objects. 
<p>
Reimplemented in <a class="el" href="classTAO__IIOP__Transport.html#z16_3">TAO_IIOP_Transport</a>.    </td>
  </tr>
</table>
<a name="b3" doxytag="TAO_Transport::messaging_object"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> virtual <a class="el" href="classTAO__Pluggable__Messaging.html">TAO_Pluggable_Messaging</a>* TAO_Transport::messaging_object </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [protected, pure virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Return the messaging object that is used to format the data that needs to be sent.
<p>

<p>
Reimplemented in <a class="el" href="classTAO__IIOP__Transport.html#z16_8">TAO_IIOP_Transport</a>.    </td>
  </tr>
</table>
<a name="b9" doxytag="TAO_Transport::missing_data"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> size_t TAO_Transport::missing_data </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="elRef" doxygen="ACE.tag:../ace/" href="../ace/classACE__Message__Block.html">ACE_Message_Block</a> &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>incoming</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [protected]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Return if we have any missing data in the queue of messages or determine if we have more information left out in the presently read message to make it complete.
<p>
    </td>
  </tr>
</table>
<a name="c16" doxytag="TAO_Transport::notify_reactor"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int TAO_Transport::notify_reactor </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [private]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a name="c24" doxytag="TAO_Transport::operator="></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void TAO_Transport::operator= </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const TAO_Transport &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [private]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a name="a3" doxytag="TAO_Transport::orb_core"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="elRef" doxygen="ACE.tag:../ace/" href="../ace/OS_8i.html#a0">ACE_INLINE</a> <a class="el" href="classTAO__ORB__Core.html">TAO_ORB_Core</a> * TAO_Transport::orb_core </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap> const</td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Access the ORB that owns this connection.
<p>
    </td>
  </tr>
</table>
<a name="b7" doxytag="TAO_Transport::parse_consolidate_messages"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int TAO_Transport::parse_consolidate_messages </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="elRef" doxygen="ACE.tag:../ace/" href="../ace/classACE__Message__Block.html">ACE_Message_Block</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>block</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="classTAO__Resume__Handle.html">TAO_Resume_Handle</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>rh</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="elRef" doxygen="ACE.tag:../ace/" href="../ace/classACE__Time__Value.html">ACE_Time_Value</a> *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>max_wait_time</em> = 0</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [protected]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Called by the handle_input_i (). This method is used to parse message read by the handle_input_i () call. It also decides whether the message needs consolidation before processing.
<p>
    </td>
  </tr>
</table>
<a name="b8" doxytag="TAO_Transport::parse_incoming_messages"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int TAO_Transport::parse_incoming_messages </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="elRef" doxygen="ACE.tag:../ace/" href="../ace/classACE__Message__Block.html">ACE_Message_Block</a> &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>block</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [protected]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Method does parsing of the message if we have a fresh message in the &lt;message_block&gt; or just returns if we have read part of the previously stored message.
<p>
    </td>
  </tr>
</table>
<a name="b14" doxytag="TAO_Transport::process_parsed_messages"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int TAO_Transport::process_parsed_messages </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classTAO__Queued__Data.html">TAO_Queued_Data</a> *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>qd</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="classTAO__Resume__Handle.html">TAO_Resume_Handle</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>rh</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [protected]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Process the message by sending it to the higher layers of the ORB.
<p>
    </td>
  </tr>
</table>
<a name="c15" doxytag="TAO_Transport::process_queue_head"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int TAO_Transport::process_queue_head </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classTAO__Resume__Handle.html">TAO_Resume_Handle</a> &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>rh</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [private]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a name="a16" doxytag="TAO_Transport::provide_handle"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void TAO_Transport::provide_handle </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="elRef" doxygen="ACE.tag:../ace/" href="../ace/classACE__Handle__Set.html">ACE_Handle_Set</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>reactor_registered</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="Transport__Cache__Manager_8h.html#a1">TAO_EventHandlerSet</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>unregistered</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Fill in a handle_set with any associated handler's reactor handle.
<p>
Called by the cache when the cache is closing in order to fill in a handle_set in a thread-safe manner.<dl compact><dt><b>
Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>reactor_registered</em>&nbsp;</td><td>
the <a class="elRef" doxygen="ACE.tag:../ace/" href="../ace/classACE__Handle__Set.html">ACE_Handle_Set</a> into which the transport should place any handle registered with the reactor</td></tr>
<tr><td valign=top><em>unregistered</em>&nbsp;</td><td>
the TAO_EventHandlerSet into which the transport should place any event handler that is not registered with anyone </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<a name="a32" doxytag="TAO_Transport::purge_entry"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void TAO_Transport::purge_entry </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Cache management.
<p>
    </td>
  </tr>
</table>
<a name="a14" doxytag="TAO_Transport::purging_order"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="elRef" doxygen="ACE.tag:../ace/" href="../ace/OS_8i.html#a0">ACE_INLINE</a> void TAO_Transport::purging_order </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">unsigned long&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>value</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a name="a13" doxytag="TAO_Transport::purging_order"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="elRef" doxygen="ACE.tag:../ace/" href="../ace/OS_8i.html#a0">ACE_INLINE</a> unsigned long TAO_Transport::purging_order </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap> const</td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get and Set the purging order. The purging strategy uses the set version to set the purging order.
<p>
    </td>
  </tr>
</table>
<a name="a15" doxytag="TAO_Transport::queue_is_empty"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="elRef" doxygen="ACE.tag:../ace/" href="../ace/OS_8i.html#a0">ACE_INLINE</a> int TAO_Transport::queue_is_empty </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Check if there are messages pending in the queue.
<p>
<dl compact><dt><b>
Returns: </b><dd>
1 if the queue is empty </dl>    </td>
  </tr>
</table>
<a name="c3" doxytag="TAO_Transport::queue_is_empty_i"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int TAO_Transport::queue_is_empty_i </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [private]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Check if there are messages pending in the queue.
<p>
This version assumes that the lock is already held. Use with care!
<p>
<dl compact><dt><b>
Returns: </b><dd>
1 if the queue is empty </dl>    </td>
  </tr>
</table>
<a name="a24" doxytag="TAO_Transport::recache_transport"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int TAO_Transport::recache_transport </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classTAO__Transport__Descriptor__Interface.html">TAO_Transport_Descriptor_Interface</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>desc</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
recache ourselves in the cache.
<p>
    </td>
  </tr>
</table>
<a name="a19" doxytag="TAO_Transport::recv"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="elRef" doxygen="ACE.tag:../ace/" href="../ace/Basic__Types_8h.html#a38">ssize_t</a> TAO_Transport::recv </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">char *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>buffer</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>size_t&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>len</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const <a class="elRef" doxygen="ACE.tag:../ace/" href="../ace/classACE__Time__Value.html">ACE_Time_Value</a> *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>timeout</em> = 0</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Read len bytes from into buf.
<p>
This method serializes on handler_lock_, guaranteeing that only thread can execute it on the same instance concurrently.<dl compact><dt><b>
Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>buffer</em>&nbsp;</td><td>
ORB allocated buffer where the data should be @ The <a class="elRef" doxygen="ACE.tag:../ace/" href="../ace/classACE__Time__Value.html">ACE_Time_Value</a> *s is just a place holder for now. It is not clear this this is the best place to specify this. The actual timeout values will be kept in the Policies. </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<a name="b5" doxytag="TAO_Transport::recv_i"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> virtual <a class="elRef" doxygen="ACE.tag:../ace/" href="../ace/Basic__Types_8h.html#a38">ssize_t</a> TAO_Transport::recv_i </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">char *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>buf</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>size_t&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>len</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const <a class="elRef" doxygen="ACE.tag:../ace/" href="../ace/classACE__Time__Value.html">ACE_Time_Value</a> *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>max_wait_time</em> = 0</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [protected, pure virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<dl compact><dt><b>
Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>buffer</em>&nbsp;</td><td>
ORB allocated buffer where the data should be @ The <a class="elRef" doxygen="ACE.tag:../ace/" href="../ace/classACE__Time__Value.html">ACE_Time_Value</a> *s is just a place holder for now. It is not clear this this is the best place to specify this. The actual timeout values will be kept in the Policies. </td></tr>
</table>
</dl>
<p>
Reimplemented in <a class="el" href="classTAO__IIOP__Transport.html#z16_10">TAO_IIOP_Transport</a>.    </td>
  </tr>
</table>
<a name="a17" doxytag="TAO_Transport::register_handler"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int TAO_Transport::register_handler </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Remove all messages from the outgoing queue.
<p>
Register the handler with the reactor. This method is used by the Wait_On_Reactor strategy. The transport must register its event handler with the ORB's Reactor.     </td>
  </tr>
</table>
<a name="b6" doxytag="TAO_Transport::register_handler_i"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> virtual int TAO_Transport::register_handler_i </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [protected, pure virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Register the handler with the reactor.
<p>
This method is used by the Wait_On_Reactor strategy. The transport must register its event handler with the ORB's Reactor.
<p>
<dl compact><dt><b>
<a class="el" href="todo.html#_todo000022">Todo: </a></b><dd>
: I think this method is pretty much useless, the connections are *always* registered with the Reactor, except in thread-per-connection mode. In that case putting the connection in the Reactor would produce unpredictable results anyway. </dl> 
<p>
Reimplemented in <a class="el" href="classTAO__IIOP__Transport.html#z16_11">TAO_IIOP_Transport</a>.    </td>
  </tr>
</table>
<a name="d1" doxytag="TAO_Transport::release"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void TAO_Transport::release </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">TAO_Transport *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>transport</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [static]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a name="c14" doxytag="TAO_Transport::report_invalid_event_handler"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void TAO_Transport::report_invalid_event_handler </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const char *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>caller</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [private]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Print out error messages if the event handler is not valid.
<p>
    </td>
  </tr>
</table>
<a name="c13" doxytag="TAO_Transport::reset_flush_timer"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="elRef" doxygen="ACE.tag:../ace/" href="../ace/OS_8i.html#a0">ACE_INLINE</a> void TAO_Transport::reset_flush_timer </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [private]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
The flush timer expired or was explicitly cancelled, mark it as not pending.
<p>
    </td>
  </tr>
</table>
<a name="c5" doxytag="TAO_Transport::schedule_output_i"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int TAO_Transport::schedule_output_i </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [private]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Schedule <a class="el" href="classTAO__Transport.html#a6">handle_output</a>() callbacks.
<p>
    </td>
  </tr>
</table>
<a name="a18" doxytag="TAO_Transport::send"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="elRef" doxygen="ACE.tag:../ace/" href="../ace/Basic__Types_8h.html#a38">ssize_t</a> TAO_Transport::send </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="elRef" doxygen="ACE.tag:../ace/" href="../ace/structiovec.html">iovec</a> *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>iov</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>iovcnt</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>size_t &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>bytes_transferred</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const <a class="elRef" doxygen="ACE.tag:../ace/" href="../ace/classACE__Time__Value.html">ACE_Time_Value</a> *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>timeout</em> = 0</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Write the complete Message_Block chain to the connection.
<p>
This method serializes on handler_lock_, guaranteeing that only thread can execute it on the same instance concurrently.
<p>
Often the implementation simply forwards the arguments to the underlying <a class="elRef" doxygen="ACE.tag:../ace/" href="../ace/classACE__Svc__Handler.html">ACE_Svc_Handler</a> class. Using the code factored out into <a class="elRef" doxygen="ACE.tag:../ace/" href="../ace/classACE.html">ACE</a>.
<p>
Be careful with protocols that perform non-trivial transformations of the data, such as SSLIOP or protocols that compress the stream.<dl compact><dt><b>
Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>mblk</em>&nbsp;</td><td>
contains the data that must be sent. For each message block in the cont() chain all the data between rd_ptr() and wr_ptr() should be delivered to the remote peer.</td></tr>
<tr><td valign=top><em>timeout</em>&nbsp;</td><td>
is the maximum time that the application is willing to wait for the data to be sent, useful in platforms that implement timed writes. The timeout value is obtained from the policies set by the application.</td></tr>
<tr><td valign=top><em>bytes_transferred</em>&nbsp;</td><td>
should return the total number of bytes successfully transferred before the connection blocked. This is required because in some platforms and/or protocols multiple system calls may be required to send the chain of message blocks. The first few calls can work successfully, but the final one can fail or signal a flow control situation (via EAGAIN). In this case the ORB expects the function to return -1, errno to be appropriately set and this argument to return the number of bytes already on the OS I/O subsystem.</td></tr>
</table>
</dl>This call can also fail if the transport instance is no longer associated with a connection (e.g., the connection handler closed down). In that case, it returns -1 and sets errno to <code>ENOENT</code>.     </td>
  </tr>
</table>
<a name="c18" doxytag="TAO_Transport::send_connection_closed_notifications"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void TAO_Transport::send_connection_closed_notifications </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [private]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Notify all the components inside a Transport when the underlying connection is closed.
<p>
    </td>
  </tr>
</table>
<a name="c19" doxytag="TAO_Transport::send_connection_closed_notifications_i"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void TAO_Transport::send_connection_closed_notifications_i </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [private]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Assume the lock is held.
<p>
    </td>
  </tr>
</table>
<a name="b4" doxytag="TAO_Transport::send_i"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> virtual <a class="elRef" doxygen="ACE.tag:../ace/" href="../ace/Basic__Types_8h.html#a38">ssize_t</a> TAO_Transport::send_i </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="elRef" doxygen="ACE.tag:../ace/" href="../ace/structiovec.html">iovec</a> *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>iov</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>iovcnt</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>size_t &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>bytes_transferred</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const <a class="elRef" doxygen="ACE.tag:../ace/" href="../ace/classACE__Time__Value.html">ACE_Time_Value</a> *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>max_wait_time</em> = 0</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [protected, pure virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Write the complete <a class="elRef" doxygen="ACE.tag:../ace/" href="../ace/structiovec.html">iovec</a> chain to the connection.
<p>
Often the implementation simply forwards the arguments to the underlying <a class="elRef" doxygen="ACE.tag:../ace/" href="../ace/classACE__Svc__Handler.html">ACE_Svc_Handler</a> class. Using the code factored out into <a class="elRef" doxygen="ACE.tag:../ace/" href="../ace/classACE.html">ACE</a>.
<p>
Be careful with protocols that perform non-trivial transformations of the data, such as SSLIOP or protocols that compress the stream.<dl compact><dt><b>
Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>iov</em>&nbsp;</td><td>
contains the data that must be sent.</td></tr>
<tr><td valign=top><em>iovcnt</em>&nbsp;</td><td>
is the number of <a class="elRef" doxygen="ACE.tag:../ace/" href="../ace/structiovec.html">iovec</a> structures in the list where iov points.</td></tr>
<tr><td valign=top><em>bytes_transferred</em>&nbsp;</td><td>
should return the total number of bytes successfully transferred before the connection blocked. This is required because in some platforms and/or protocols multiple system calls may be required to send the chain of message blocks. The first few calls can work successfully, but the final one can fail or signal a flow control situation (via EAGAIN). In this case the ORB expects the function to return -1, errno to be appropriately set and this argument to return the number of bytes already on the OS I/O subsystem.</td></tr>
<tr><td valign=top><em>timeout</em>&nbsp;</td><td>
is the maximum time that the application is willing to wait for the data to be sent, useful in platforms that implement timed writes. The timeout value is obtained from the policies set by the application. </td></tr>
</table>
</dl>
<p>
Reimplemented in <a class="el" href="classTAO__IIOP__Transport.html#z16_9">TAO_IIOP_Transport</a>.    </td>
  </tr>
</table>
<a name="a28" doxytag="TAO_Transport::send_message"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> virtual int TAO_Transport::send_message </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classTAO__OutputCDR.html">TAO_OutputCDR</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>stream</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="classTAO__Stub.html">TAO_Stub</a> *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>stub</em> = 0, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>message_semantics</em> = TAO_Transport::TAO_TWOWAY_REQUEST, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="elRef" doxygen="ACE.tag:../ace/" href="../ace/classACE__Time__Value.html">ACE_Time_Value</a> *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>max_wait_time</em> = 0</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This method formats the stream and then sends the message on the transport.
<p>
Once the ORB is prepared to receive a reply (see <a class="el" href="classTAO__Transport.html#a27">send_request</a>() above), and all the arguments have been marshaled the CDR stream must be 'formatted', i.e. the message_size field in the <a class="el" href="namespaceGIOP.html">GIOP</a> header can finally be set to the proper value. 
<p>
Reimplemented in <a class="el" href="classTAO__IIOP__Transport.html#z16_1">TAO_IIOP_Transport</a>.    </td>
  </tr>
</table>
<a name="a30" doxytag="TAO_Transport::send_message_block_chain"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int TAO_Transport::send_message_block_chain </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="elRef" doxygen="ACE.tag:../ace/" href="../ace/classACE__Message__Block.html">ACE_Message_Block</a> *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>mb</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>size_t &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>bytes_transferred</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="elRef" doxygen="ACE.tag:../ace/" href="../ace/classACE__Time__Value.html">ACE_Time_Value</a> *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>max_wait_time</em> = 0</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Send a message block chain,.
<p>
    </td>
  </tr>
</table>
<a name="a31" doxytag="TAO_Transport::send_message_block_chain_i"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int TAO_Transport::send_message_block_chain_i </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="elRef" doxygen="ACE.tag:../ace/" href="../ace/classACE__Message__Block.html">ACE_Message_Block</a> *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>mb</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>size_t &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>bytes_transferred</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="elRef" doxygen="ACE.tag:../ace/" href="../ace/classACE__Time__Value.html">ACE_Time_Value</a> *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>max_wait_time</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Send a message block chain, assuming the lock is held.
<p>
    </td>
  </tr>
</table>
<a name="a29" doxytag="TAO_Transport::send_message_shared"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int TAO_Transport::send_message_shared </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classTAO__Stub.html">TAO_Stub</a> *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>stub</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>message_semantics</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const <a class="elRef" doxygen="ACE.tag:../ace/" href="../ace/classACE__Message__Block.html">ACE_Message_Block</a> *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>message_block</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="elRef" doxygen="ACE.tag:../ace/" href="../ace/classACE__Time__Value.html">ACE_Time_Value</a> *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>max_wait_time</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Sent the contents of &lt;message_block&gt;.
<p>
<dl compact><dt><b>
Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>stub</em>&nbsp;</td><td>
The object reference used for this operation, useful to obtain the current policies. </td></tr>
<tr><td valign=top><em>message_semantics</em>&nbsp;</td><td>
If this is set to TAO_TWO_REQUEST this method will block until the operation is completely written on the wire. If it is set to other values this operation could return. </td></tr>
<tr><td valign=top><em>message_block</em>&nbsp;</td><td>
The CDR encapsulation of the <a class="el" href="namespaceGIOP.html">GIOP</a> message that must be sent. The message may consist of multiple Message Blocks chained through the cont() field. </td></tr>
<tr><td valign=top><em>max_wait_time</em>&nbsp;</td><td>
The maximum time that the operation can block, used in the implementation of timeouts. </td></tr>
</table>
</dl>
<p>
Reimplemented in <a class="el" href="classTAO__IIOP__Transport.html#z16_12">TAO_IIOP_Transport</a>.    </td>
  </tr>
</table>
<a name="b16" doxytag="TAO_Transport::send_message_shared_i"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int TAO_Transport::send_message_shared_i </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classTAO__Stub.html">TAO_Stub</a> *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>stub</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>message_semantics</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const <a class="elRef" doxygen="ACE.tag:../ace/" href="../ace/classACE__Message__Block.html">ACE_Message_Block</a> *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>message_block</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="elRef" doxygen="ACE.tag:../ace/" href="../ace/classACE__Time__Value.html">ACE_Time_Value</a> *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>max_wait_time</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [protected]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Implement <a class="el" href="classTAO__Transport.html#a29">send_message_shared</a>() assuming the handler_lock_ is held.
<p>
    </td>
  </tr>
</table>
<a name="c10" doxytag="TAO_Transport::send_reply_message_i"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int TAO_Transport::send_reply_message_i </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="elRef" doxygen="ACE.tag:../ace/" href="../ace/classACE__Message__Block.html">ACE_Message_Block</a> *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>mb</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="elRef" doxygen="ACE.tag:../ace/" href="../ace/classACE__Time__Value.html">ACE_Time_Value</a> *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>max_wait_time</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [private]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Send a reply message, i.e. do not block until the message is on the wire, but just return after adding them to the queue.
<p>
    </td>
  </tr>
</table>
<a name="a27" doxytag="TAO_Transport::send_request"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> virtual int TAO_Transport::send_request </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classTAO__Stub.html">TAO_Stub</a> *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>stub</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="classTAO__ORB__Core.html">TAO_ORB_Core</a> *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>orb_core</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="classTAO__OutputCDR.html">TAO_OutputCDR</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>stream</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>message_semantics</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="elRef" doxygen="ACE.tag:../ace/" href="../ace/classACE__Time__Value.html">ACE_Time_Value</a> *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>max_wait_time</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Prepare the waiting and demuxing strategy to receive a reply for a new request.
<p>
Preparing the ORB to receive the reply only once the request is completely sent opens the system to some subtle race conditions: suppose the ORB is running in a multi-threaded configuration, thread A makes a request while thread B is using the Reactor to process all incoming requests. Thread A could be implemented as follows: 1) send the request 2) setup the ORB to receive the reply 3) wait for the request
<p>
but in this case thread B may receive the reply between step (1) and (2), and drop it as an invalid or unexpected message. Consequently the correct implementation is: 1) setup the ORB to receive the reply 2) send the request 3) wait for the reply
<p>
The following method encapsulates this idiom.
<p>
<dl compact><dt><b>
<a class="el" href="todo.html#_todo000021">Todo: </a></b><dd>
 This is generic code, it should be factored out into the Transport class. </dl> 
<p>
Reimplemented in <a class="el" href="classTAO__IIOP__Transport.html#z16_0">TAO_IIOP_Transport</a>.    </td>
  </tr>
</table>
<a name="c11" doxytag="TAO_Transport::send_synch_message_helper_i"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int TAO_Transport::send_synch_message_helper_i </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classTAO__Synch__Queued__Message.html">TAO_Synch_Queued_Message</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>synch_message</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="elRef" doxygen="ACE.tag:../ace/" href="../ace/classACE__Time__Value.html">ACE_Time_Value</a> *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>max_wait_time</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [private]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
A helper method used by &lt;send_synchronous_message_i&gt; and &lt;send_reply_message_i&gt;. Reusable code that could be used by both the methods.
<p>
    </td>
  </tr>
</table>
<a name="c9" doxytag="TAO_Transport::send_synchronous_message_i"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int TAO_Transport::send_synchronous_message_i </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="elRef" doxygen="ACE.tag:../ace/" href="../ace/classACE__Message__Block.html">ACE_Message_Block</a> *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>mb</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="elRef" doxygen="ACE.tag:../ace/" href="../ace/classACE__Time__Value.html">ACE_Time_Value</a> *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>max_wait_time</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [private]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Send a synchronous message, i.e. block until the message is on the wire.
<p>
    </td>
  </tr>
</table>
<a name="a2" doxytag="TAO_Transport::tag"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="elRef" doxygen="ACE.tag:../ace/" href="../ace/OS_8i.html#a0">ACE_INLINE</a> <a class="el" href="namespaceCORBA.html#a11">CORBA::ULong</a> TAO_Transport::tag </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap> const</td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Return the protocol tag.
<p>
The OMG assigns unique tags (a 32-bit unsigned number) to each protocol. New protocol tags can be obtained free of charge from the OMG, check the documents in <a class="el" href="corbafwd_8h.html">corbafwd.h</a> for more details.     </td>
  </tr>
</table>
<a name="a21" doxytag="TAO_Transport::tear_listen_point_list"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int TAO_Transport::tear_listen_point_list </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classTAO__InputCDR.html">TAO_InputCDR</a> &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>cdr</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Extracts the list of listen points from the &lt;cdr&gt; stream. The list would have the protocol specific details of the ListenPoints.
<p>

<p>
Reimplemented in <a class="el" href="classTAO__IIOP__Transport.html#z16_4">TAO_IIOP_Transport</a>.    </td>
  </tr>
</table>
<a name="a4" doxytag="TAO_Transport::tms"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="elRef" doxygen="ACE.tag:../ace/" href="../ace/OS_8i.html#a0">ACE_INLINE</a> <a class="el" href="classTAO__Transport__Mux__Strategy.html">TAO_Transport_Mux_Strategy</a> * TAO_Transport::tms </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap> const</td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get the TAO_Tranport_Mux_Strategy used by this object.
<p>
The role of the <a class="el" href="classTAO__Transport__Mux__Strategy.html">TAO_Transport_Mux_Strategy</a> is described in more detail in that class' documentation. Enough is to say that the class is used to control how many threads can have pending requests over the same connection. Multiplexing multiple threads over the same connection conserves resources and is almost required for AMI, but having only one pending request per connection is more efficient and reduces the possibilities of priority inversions.     </td>
  </tr>
</table>
<a name="c0" doxytag="TAO_Transport::transport_cache_manager"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="classTAO__Transport__Cache__Manager.html">TAO_Transport_Cache_Manager</a> &amp; TAO_Transport::transport_cache_manager </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [private]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Helper method that returns the Transport Cache Manager.
<p>
    </td>
  </tr>
</table>
<a name="a34" doxytag="TAO_Transport::update_transport"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int TAO_Transport::update_transport </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Cache management.
<p>
    </td>
  </tr>
</table>
<a name="a5" doxytag="TAO_Transport::wait_strategy"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="elRef" doxygen="ACE.tag:../ace/" href="../ace/OS_8i.html#a0">ACE_INLINE</a> <a class="el" href="classTAO__Wait__Strategy.html">TAO_Wait_Strategy</a> * TAO_Transport::wait_strategy </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap> const</td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Return the <a class="el" href="classTAO__Wait__Strategy.html">TAO_Wait_Strategy</a> used by this object.
<p>
The role of the <a class="el" href="classTAO__Wait__Strategy.html">TAO_Wait_Strategy</a> is described in more detail in that class' documentation. Enough is to say that the ORB can wait for a reply blocking on read(), using the Reactor to wait for multiple events concurrently or using the Leader/Followers protocol.     </td>
  </tr>
</table>
<hr><h2>Friends And Related Function Documentation</h2>
<a name="l0" doxytag="TAO_Transport::TAO_Block_Flushing_Strategy"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> friend class TAO_Block_Flushing_Strategy<code> [friend]</code>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This class needs priviledged access to - <a class="el" href="classTAO__Transport.html#c3">queue_is_empty_i</a>() - <a class="el" href="classTAO__Transport.html#c2">drain_queue_i</a>().
<p>
    </td>
  </tr>
</table>
<a name="l2" doxytag="TAO_Transport::TAO_Leader_Follower_Flushing_Strategy"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> friend class TAO_Leader_Follower_Flushing_Strategy<code> [friend]</code>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a name="l1" doxytag="TAO_Transport::TAO_Reactive_Flushing_Strategy"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> friend class TAO_Reactive_Flushing_Strategy<code> [friend]</code>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
These classes need privileged access to: - <a class="el" href="classTAO__Transport.html#c5">schedule_output_i</a>() - <a class="el" href="classTAO__Transport.html#c6">cancel_output_i</a>().
<p>
    </td>
  </tr>
</table>
<a name="l3" doxytag="TAO_Transport::TAO_Transport_Cache_Manager"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> friend class TAO_Transport_Cache_Manager<code> [friend]</code>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This class needs priviledged access to: close_connection_no_purge ().
<p>
    </td>
  </tr>
</table>
<hr><h2>Member Data Documentation</h2>
<a name="n5" doxytag="TAO_Transport::bidirectional_flag_"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int TAO_Transport::bidirectional_flag_<code> [protected]</code>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Use to check if bidirectional info has been synchronized with the peer.
<p>
Have we sent any info on bidirectional information or have we received any info regarding making the connection served by this transport bidirectional. The flag is used as follows: + We dont want to send the bidirectional context info more than once on the connection. Why? Waste of marshalling and demarshalling time on the client. + On the server side -- once a client that has established the connection asks the server to use the connection both ways, we *dont* want the server to pack service info to the client. That is not allowed. We need a flag to prevent such a things from happening.
<p>
The value of this flag will be 0 if the client sends info and 1 if the server receives the info.     </td>
  </tr>
</table>
<a name="n2" doxytag="TAO_Transport::cache_map_entry_"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="classTAO__Transport__Cache__Manager.html#s2">TAO_Transport_Cache_Manager::HASH_MAP_ENTRY</a>* TAO_Transport::cache_map_entry_<code> [protected]</code>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Our entry in the cache. We dont own this. It is here for our convinience. We cannot just change things around.
<p>
    </td>
  </tr>
</table>
<a name="n9" doxytag="TAO_Transport::current_deadline_"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="elRef" doxygen="ACE.tag:../ace/" href="../ace/classACE__Time__Value.html">ACE_Time_Value</a> TAO_Transport::current_deadline_<code> [protected]</code>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
The queue will start draining no later than &lt;queing_deadline_&gt; *if* the deadline is.
<p>
    </td>
  </tr>
</table>
<a name="n10" doxytag="TAO_Transport::flush_timer_id_"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> long TAO_Transport::flush_timer_id_<code> [protected]</code>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
The timer ID.
<p>
    </td>
  </tr>
</table>
<a name="n12" doxytag="TAO_Transport::handler_lock_"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="elRef" doxygen="ACE.tag:../ace/" href="../ace/classACE__Lock.html">ACE_Lock</a>* TAO_Transport::handler_lock_<code> [protected]</code>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Lock that insures that activities that *might* use handler-related resources (such as a connection handler) get serialized.
<p>
This is an <code><a class="elRef" doxygen="ACE.tag:../ace/" href="../ace/classACE__Lock.html">ACE_Lock</a></code> that gets initialized from <code><a class="el" href="classTAO__ORB__Core.html#z34_0">TAO_ORB_Core::resource_factory</a>()-&gt;create_cached_connection_lock ()</code>. This way, one can use a lock appropriate for the type of system, i.e., a null lock for single-threaded systems, and a real lock for multi-threaded systems.     </td>
  </tr>
</table>
<a name="n6" doxytag="TAO_Transport::head_"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="classTAO__Queued__Message.html">TAO_Queued_Message</a>* TAO_Transport::head_<code> [protected]</code>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Implement the outgoing data queue.
<p>
    </td>
  </tr>
</table>
<a name="n13" doxytag="TAO_Transport::id_"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int TAO_Transport::id_<code> [protected]</code>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
A unique identifier for the transport.
<p>
This never *never* changes over the lifespan, so we don't have to worry about locking it.
<p>
HINT: Protocol-specific transports that use connection handler might choose to set this to the handle for their connection.     </td>
  </tr>
</table>
<a name="n8" doxytag="TAO_Transport::incoming_message_queue_"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="classTAO__Incoming__Message__Queue.html">TAO_Incoming_Message_Queue</a> TAO_Transport::incoming_message_queue_<code> [protected]</code>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Queue of the incoming messages..
<p>
    </td>
  </tr>
</table>
<a name="n1" doxytag="TAO_Transport::orb_core_"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="classTAO__ORB__Core.html">TAO_ORB_Core</a>* TAO_Transport::orb_core_<code> [protected]</code>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Global orbcore resource.
<p>
    </td>
  </tr>
</table>
<a name="n14" doxytag="TAO_Transport::purging_order_"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> unsigned long TAO_Transport::purging_order_<code> [protected]</code>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Used by the LRU, LFU and FIFO Connection Purging Strategies.
<p>
    </td>
  </tr>
</table>
<a name="n0" doxytag="TAO_Transport::tag_"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="namespaceCORBA.html#a11">CORBA::ULong</a> TAO_Transport::tag_<code> [protected]</code>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<a class="el" href="namespaceIOP.html">IOP</a> protocol tag.
<p>
    </td>
  </tr>
</table>
<a name="n7" doxytag="TAO_Transport::tail_"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="classTAO__Queued__Message.html">TAO_Queued_Message</a>* TAO_Transport::tail_<code> [protected]</code>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a name="n3" doxytag="TAO_Transport::tms_"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="classTAO__Transport__Mux__Strategy.html">TAO_Transport_Mux_Strategy</a>* TAO_Transport::tms_<code> [protected]</code>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Strategy to decide whether multiple requests can be sent over the same connection or the connection is exclusive for a request.
<p>
    </td>
  </tr>
</table>
<a name="n11" doxytag="TAO_Transport::transport_timer_"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="classTAO__Transport__Timer.html">TAO_Transport_Timer</a> TAO_Transport::transport_timer_<code> [protected]</code>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
The adapter used to receive timeout callbacks from the Reactor.
<p>
    </td>
  </tr>
</table>
<a name="n4" doxytag="TAO_Transport::ws_"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="classTAO__Wait__Strategy.html">TAO_Wait_Strategy</a>* TAO_Transport::ws_<code> [protected]</code>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Strategy for waiting for the reply after sending the request.
<p>
    </td>
  </tr>
</table>
<hr>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="Transport_8h.html">Transport.h</a><li><a class="el" href="Transport_8cpp.html">Transport.cpp</a><li><a class="el" href="Transport_8inl.html">Transport.inl</a></ul>
<hr><address><small>Generated on Wed Jan 15 20:58:19 2003 for TAO by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.gif" alt="doxygen" align="middle" border=0 
width=110 height=53></a>1.2.13.1 written by <a href="mailto:dimitri@stack.nl">Dimitri van Heesch</a>,
 &copy;&nbsp;1997-2001</small></address>
</body>
</html>
