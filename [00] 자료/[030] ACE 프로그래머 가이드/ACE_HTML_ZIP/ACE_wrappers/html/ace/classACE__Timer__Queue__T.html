<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title> TemplateACE_Timer_Queue_T class Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body bgcolor="#ffffff">
<!-- Generated by Doxygen 1.2.13.1 -->
<center>
<a class="qindex" href="index.html">Main Page</a> &nbsp; <a class="qindex" href="hierarchy.html">Class Hierarchy</a> &nbsp; <a class="qindex" href="classes.html">Alphabetical List</a> &nbsp; <a class="qindex" href="annotated.html">Compound List</a> &nbsp; <a class="qindex" href="files.html">File List</a> &nbsp; <a class="qindex" href="functions.html">Compound Members</a> &nbsp; <a class="qindex" href="globals.html">File Members</a> &nbsp; <a class="qindex" href="pages.html">Related Pages</a> &nbsp; </center>
<hr><h1>ACE_Timer_Queue_T  Class Template Reference</h1>Provides an interface to timers. 
<a href="#_details">More...</a>
<p>
<code>#include &lt;Timer_Queue_T.h&gt;</code>
<p>
Inheritance diagram for ACE_Timer_Queue_T:<p><center><img src="classACE__Timer__Queue__T__inherit__graph.gif" border="0" usemap="#ACE__Timer__Queue__T_3_01TYPE_00_01FUNCTOR_00_01ACE__LOCK_01_4__inherit__map" alt="Inheritance graph"></center>
<map name="ACE__Timer__Queue__T_3_01TYPE_00_01FUNCTOR_00_01ACE__LOCK_01_4__inherit__map">
<area href="classACE__Timer__Hash__T.html" shape="rect" coords="1667,7,2009,26" alt="">
<area href="classACE__Timer__Heap__T.html" shape="rect" coords="1666,58,2010,77" alt="">
<area href="classACE__Timer__List__T.html" shape="rect" coords="1673,109,2003,127" alt="">
<area href="classACE__Timer__Wheel__T.html" shape="rect" coords="1663,159,2013,178" alt="">
<area href="classACE__Timer__Queue__T.html" shape="rect" coords="1482,217,2194,235" alt="">
<area href="classACE__Timer__Queue__T.html" shape="rect" coords="1323,285,2353,303" alt="">
</map>
<center><font size="2">[<a href="graph_legend.html">legend</a>]</font></center>Collaboration diagram for ACE_Timer_Queue_T:<p><center><img src="classACE__Timer__Queue__T__coll__graph.gif" border="0" usemap="#ACE__Timer__Queue__T_3_01TYPE_00_01FUNCTOR_00_01ACE__LOCK_01_4__coll__map" alt="Collaboration graph"></center>
<map name="ACE__Timer__Queue__T_3_01TYPE_00_01FUNCTOR_00_01ACE__LOCK_01_4__coll__map">
<area href="classACE__Time__Value.html" shape="rect" coords="14,105,129,124" alt="">
<area href="classACE__Free__List.html" shape="rect" coords="242,105,543,124" alt="">
<area href="classACE__Free__List.html" shape="rect" coords="327,15,458,33" alt="">
</map>
<center><font size="2">[<a href="graph_legend.html">legend</a>]</font></center><a href="classACE__Timer__Queue__T-members.html">List of all members.</a><table border=0 cellpadding=0 cellspacing=0>
<tr><td colspan=2><br><h2>Public Types</h2></td></tr>
<tr><td nowrap align=right valign=top>typedef <a class="el" href="classACE__Timer__Queue__Iterator__T.html">ACE_Timer_Queue_Iterator_T</a>&lt;<br>
 TYPE, FUNCTOR, ACE_LOCK &gt;&nbsp;</td><td valign=bottom><a class="el" href="classACE__Timer__Queue__T.html#s0">ITERATOR</a></td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Type of Iterator.</em> <a href="#s0">More...</a><em></em></font><br><br></td></tr>
<tr><td colspan=2><br><h2>Public Methods</h2></td></tr>
<tr><td nowrap align=right valign=top>&nbsp;</td><td valign=bottom><a class="el" href="classACE__Timer__Queue__T.html#a0">ACE_Timer_Queue_T</a> (FUNCTOR *upcall_functor=0, <a class="el" href="classACE__Free__List.html">ACE_Free_List</a>&lt; <a class="el" href="classACE__Timer__Node__T.html">ACE_Timer_Node_T</a>&lt; TYPE &gt; &gt; *freelist=0)</td></tr>
<tr><td nowrap align=right valign=top>virtual&nbsp;</td><td valign=bottom><a class="el" href="classACE__Timer__Queue__T.html#a1">~ACE_Timer_Queue_T</a> (void)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Destructor - make virtual for proper destruction of inherited classes.</em> <a href="#a1">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>virtual int&nbsp;</td><td valign=bottom><a class="el" href="classACE__Timer__Queue__T.html#a2">is_empty</a> (void) const=0</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>True if queue is empty, else false.</em> <a href="#a2">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>virtual const <a class="el" href="classACE__Time__Value.html">ACE_Time_Value</a> &amp;&nbsp;</td><td valign=bottom><a class="el" href="classACE__Timer__Queue__T.html#a3">earliest_time</a> (void) const=0</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Returns the time of the earlier node in the Timer_Queue. Must be called on a non-empty queue.</em> <a href="#a3">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>virtual long&nbsp;</td><td valign=bottom><a class="el" href="classACE__Timer__Queue__T.html#a4">schedule</a> (const TYPE &amp;type, const void *act, const <a class="el" href="classACE__Time__Value.html">ACE_Time_Value</a> &amp;future_time, const <a class="el" href="classACE__Time__Value.html">ACE_Time_Value</a> &amp;interval=<a class="el" href="classACE__Time__Value.html#p0">ACE_Time_Value::zero</a>)=0</td></tr>
<tr><td nowrap align=right valign=top>virtual int&nbsp;</td><td valign=bottom><a class="el" href="classACE__Timer__Queue__T.html#a5">reset_interval</a> (long timer_id, const <a class="el" href="classACE__Time__Value.html">ACE_Time_Value</a> &amp;interval)=0</td></tr>
<tr><td nowrap align=right valign=top>virtual int&nbsp;</td><td valign=bottom><a class="el" href="classACE__Timer__Queue__T.html#a6">cancel</a> (const TYPE &amp;type, int dont_call_handle_close=1)=0</td></tr>
<tr><td nowrap align=right valign=top>virtual int&nbsp;</td><td valign=bottom><a class="el" href="classACE__Timer__Queue__T.html#a7">cancel</a> (long timer_id, const void **act=0, int dont_call_handle_close=1)=0</td></tr>
<tr><td nowrap align=right valign=top>virtual int&nbsp;</td><td valign=bottom><a class="el" href="classACE__Timer__Queue__T.html#a8">expire</a> (const <a class="el" href="classACE__Time__Value.html">ACE_Time_Value</a> &amp;current_time)</td></tr>
<tr><td nowrap align=right valign=top>int&nbsp;</td><td valign=bottom><a class="el" href="classACE__Timer__Queue__T.html#a9">dispatch_info</a> (const <a class="el" href="classACE__Time__Value.html">ACE_Time_Value</a> &amp;current_time, <a class="el" href="classACE__Timer__Node__Dispatch__Info__T.html">ACE_Timer_Node_Dispatch_Info_T</a>&lt; TYPE &gt; &amp;info)</td></tr>
<tr><td nowrap align=right valign=top>int&nbsp;</td><td valign=bottom><a class="el" href="classACE__Timer__Queue__T.html#a10">expire</a> (void)</td></tr>
<tr><td nowrap align=right valign=top><a class="el" href="classACE__Time__Value.html">ACE_Time_Value</a>&nbsp;</td><td valign=bottom><a class="el" href="classACE__Timer__Queue__T.html#a11">gettimeofday</a> (void)</td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classACE__Timer__Queue__T.html#a12">gettimeofday</a> (<a class="el" href="classACE__Time__Value.html">ACE_Time_Value</a>(*gettimeofday)(void))</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Allows applications to control how the timer queue gets the time of day.</em> <a href="#a12">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>virtual <a class="el" href="classACE__Time__Value.html">ACE_Time_Value</a> *&nbsp;</td><td valign=bottom><a class="el" href="classACE__Timer__Queue__T.html#a13">calculate_timeout</a> (<a class="el" href="classACE__Time__Value.html">ACE_Time_Value</a> *max)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Determine the next event to timeout. Returns &lt;max&gt; if there are no pending timers or if all pending timers are longer than max. This method acquires a lock internally since it modifies internal state.</em> <a href="#a13">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>virtual <a class="el" href="classACE__Time__Value.html">ACE_Time_Value</a> *&nbsp;</td><td valign=bottom><a class="el" href="classACE__Timer__Queue__T.html#a14">calculate_timeout</a> (<a class="el" href="classACE__Time__Value.html">ACE_Time_Value</a> *max, <a class="el" href="classACE__Time__Value.html">ACE_Time_Value</a> *the_timeout)</td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classACE__Timer__Queue__T.html#a15">timer_skew</a> (const <a class="el" href="classACE__Time__Value.html">ACE_Time_Value</a> &amp;skew)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Set the timer skew for the Timer_Queue.</em> <a href="#a15">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>const <a class="el" href="classACE__Time__Value.html">ACE_Time_Value</a> &amp;&nbsp;</td><td valign=bottom><a class="el" href="classACE__Timer__Queue__T.html#a16">timer_skew</a> (void) const</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Get the timer skew for the Timer_Queue.</em> <a href="#a16">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>ACE_LOCK &amp;&nbsp;</td><td valign=bottom><a class="el" href="classACE__Timer__Queue__T.html#a17">mutex</a> (void)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Synchronization variable used by the queue.</em> <a href="#a17">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>FUNCTOR &amp;&nbsp;</td><td valign=bottom><a class="el" href="classACE__Timer__Queue__T.html#a18">upcall_functor</a> (void)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Accessor to the upcall functor.</em> <a href="#a18">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>virtual <a class="el" href="classACE__Timer__Queue__T.html#s0">ITERATOR</a> &amp;&nbsp;</td><td valign=bottom><a class="el" href="classACE__Timer__Queue__T.html#a19">iter</a> (void)=0</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Returns a pointer to this &lt;ACE_Timer_Queue&gt;'s iterator.</em> <a href="#a19">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>virtual <a class="el" href="classACE__Timer__Node__T.html">ACE_Timer_Node_T</a>&lt;<br>
 TYPE &gt; *&nbsp;</td><td valign=bottom><a class="el" href="classACE__Timer__Queue__T.html#a20">remove_first</a> (void)=0</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Removes the earliest node from the queue and returns it.</em> <a href="#a20">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>virtual void&nbsp;</td><td valign=bottom><a class="el" href="classACE__Timer__Queue__T.html#a21">dump</a> (void) const</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Dump the state of a object.</em> <a href="#a21">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>virtual <a class="el" href="classACE__Timer__Node__T.html">ACE_Timer_Node_T</a>&lt;<br>
 TYPE &gt; *&nbsp;</td><td valign=bottom><a class="el" href="classACE__Timer__Queue__T.html#a22">get_first</a> (void)=0</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Reads the earliest node from the queue and returns it.</em> <a href="#a22">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>virtual void&nbsp;</td><td valign=bottom><a class="el" href="classACE__Timer__Queue__T.html#a23">return_node</a> (<a class="el" href="classACE__Timer__Node__T.html">ACE_Timer_Node_T</a>&lt; TYPE &gt; *)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Method used to return a timer node to the queue's ownership after it is returned by a method like &lt;remove_first&gt;.</em> <a href="#a23">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classACE__Timer__Queue__T.html#a24">upcall</a> (TYPE &amp;type, const void *act, const <a class="el" href="classACE__Time__Value.html">ACE_Time_Value</a> &amp;cur_time)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>This method will call the &lt;functor&gt; with the &lt;type&gt;, &lt;act&gt; and &lt;cur_time&gt;.</em> <a href="#a24">More...</a><em></em></font><br><br></td></tr>
<tr><td colspan=2><br><h2>Protected Methods</h2></td></tr>
<tr><td nowrap align=right valign=top>virtual void&nbsp;</td><td valign=bottom><a class="el" href="classACE__Timer__Queue__T.html#b0">reschedule</a> (<a class="el" href="classACE__Timer__Node__T.html">ACE_Timer_Node_T</a>&lt; TYPE &gt; *)=0</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Reschedule an "interval" &lt;ACE_Timer_Node&gt;.</em> <a href="#b0">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>virtual <a class="el" href="classACE__Timer__Node__T.html">ACE_Timer_Node_T</a>&lt;<br>
 TYPE &gt; *&nbsp;</td><td valign=bottom><a class="el" href="classACE__Timer__Queue__T.html#b1">alloc_node</a> (void)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Factory method that allocates a new node.</em> <a href="#b1">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>virtual void&nbsp;</td><td valign=bottom><a class="el" href="classACE__Timer__Queue__T.html#b2">free_node</a> (<a class="el" href="classACE__Timer__Node__T.html">ACE_Timer_Node_T</a>&lt; TYPE &gt; *)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Factory method that frees a previously allocated node.</em> <a href="#b2">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>int&nbsp;</td><td valign=bottom><a class="el" href="classACE__Timer__Queue__T.html#b3">dispatch_info_i</a> (const <a class="el" href="classACE__Time__Value.html">ACE_Time_Value</a> &amp;current_time, <a class="el" href="classACE__Timer__Node__Dispatch__Info__T.html">ACE_Timer_Node_Dispatch_Info_T</a>&lt; TYPE &gt; &amp;info)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Non-locking version of dispatch_info ().</em> <a href="#b3">More...</a><em></em></font><br><br></td></tr>
<tr><td colspan=2><br><h2>Protected Attributes</h2></td></tr>
<tr><td nowrap align=right valign=top>ACE_LOCK&nbsp;</td><td valign=bottom><a class="el" href="classACE__Timer__Queue__T.html#n0">mutex_</a></td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Synchronization variable for &lt;ACE_Timer_Queue&gt;. NOTE: the right name would be lock_, but HP/C++ will choke on that!</em> <a href="#n0">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top><a class="el" href="classACE__Free__List.html">ACE_Free_List</a>&lt; <a class="el" href="classACE__Timer__Node__T.html">ACE_Timer_Node_T</a>&lt;<br>
 TYPE &gt; &gt; *&nbsp;</td><td valign=bottom><a class="el" href="classACE__Timer__Queue__T.html#n1">free_list_</a></td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Class that implements a free list.</em> <a href="#n1">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top><a class="el" href="classACE__Time__Value.html">ACE_Time_Value</a>(*&nbsp;</td><td valign=bottom><a class="el" href="classACE__Timer__Queue__T.html#n2">gettimeofday_</a> )(void)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Pointer to function that returns the current time of day.</em> <a href="#n2">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>FUNCTOR *&nbsp;</td><td valign=bottom><a class="el" href="classACE__Timer__Queue__T.html#n3">upcall_functor_</a></td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Upcall functor.</em> <a href="#n3">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>int&nbsp;</td><td valign=bottom><a class="el" href="classACE__Timer__Queue__T.html#n4">delete_upcall_functor_</a></td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>To delete or not to delete is the question?</em> <a href="#n4">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>int&nbsp;</td><td valign=bottom><a class="el" href="classACE__Timer__Queue__T.html#n5">delete_free_list_</a></td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Flag to delete only if the class created the &lt;free_list_&gt;.</em> <a href="#n5">More...</a><em></em></font><br><br></td></tr>
<tr><td colspan=2><br><h2>Private Methods</h2></td></tr>
<tr><td nowrap align=right valign=top>&nbsp;</td><td valign=bottom><a class="el" href="classACE__Timer__Queue__T.html#c0">ACE_Timer_Queue_T</a> (const ACE_Timer_Queue_T&lt; TYPE, FUNCTOR, ACE_LOCK &gt; &amp;)</td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classACE__Timer__Queue__T.html#c1">operator=</a> (const ACE_Timer_Queue_T&lt; TYPE, FUNCTOR, ACE_LOCK &gt; &amp;)</td></tr>
<tr><td colspan=2><br><h2>Private Attributes</h2></td></tr>
<tr><td nowrap align=right valign=top><a class="el" href="classACE__Time__Value.html">ACE_Time_Value</a>&nbsp;</td><td valign=bottom><a class="el" href="classACE__Timer__Queue__T.html#o0">timeout_</a></td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Returned by &lt;calculate_timeout&gt;.</em> <a href="#o0">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top><a class="el" href="classACE__Time__Value.html">ACE_Time_Value</a>&nbsp;</td><td valign=bottom><a class="el" href="classACE__Timer__Queue__T.html#o1">timer_skew_</a></td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Adjusts for timer skew in various clocks.</em> <a href="#o1">More...</a><em></em></font><br><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
<h3>template&lt;class TYPE, class FUNCTOR, class ACE_LOCK&gt;<br>
 class ACE_Timer_Queue_T&lt; TYPE, FUNCTOR, ACE_LOCK &gt;</h3>

Provides an interface to timers.
<p>

<p>
 This is an abstract base class that provides hook for implementing specialized policies such as &lt;ACE_Timer_List&gt; and &lt;ACE_Timer_Heap&gt;. 
<p>
<hr><h2>Member Typedef Documentation</h2>
<a name="s0" doxytag="ACE_Timer_Queue_T::ITERATOR"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class TYPE, class FUNCTOR, class ACE_LOCK&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> typedef <a class="el" href="classACE__Timer__Queue__Iterator__T.html">ACE_Timer_Queue_Iterator_T</a>&lt;TYPE, FUNCTOR, ACE_LOCK&gt; ACE_Timer_Queue_T::ITERATOR
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Type of Iterator.
<p>
    </td>
  </tr>
</table>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a name="a0" doxytag="ACE_Timer_Queue_T::ACE_Timer_Queue_T"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class TYPE, class FUNCTOR, class ACE_LOCK&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> ACE_Timer_Queue_T&lt; TYPE, FUNCTOR, ACE_LOCK &gt;::ACE_Timer_Queue_T </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">FUNCTOR *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>upcall_functor</em> = 0, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="classACE__Free__List.html">ACE_Free_List</a>&lt; <a class="el" href="classACE__Timer__Node__T.html">ACE_Timer_Node_T</a>&lt; TYPE &gt; &gt; *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>freelist</em> = 0</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Default constructor. &lt;upcall_functor&gt; is the instance of the FUNCTOR to be used by the queue. If &lt;upcall_functor&gt; is 0, Timer Queue will create a default FUNCTOR. &lt;freelist&gt; the freelist of timer nodes. If 0, then a default freelist will be created.     </td>
  </tr>
</table>
<a name="a1" doxytag="ACE_Timer_Queue_T::~ACE_Timer_Queue_T"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class TYPE, class FUNCTOR, class ACE_LOCK&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> ACE_Timer_Queue_T&lt; TYPE, FUNCTOR, ACE_LOCK &gt;::~ACE_Timer_Queue_T </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Destructor - make virtual for proper destruction of inherited classes.
<p>
    </td>
  </tr>
</table>
<a name="c0" doxytag="ACE_Timer_Queue_T::ACE_Timer_Queue_T"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class TYPE, class FUNCTOR, class ACE_LOCK&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> ACE_Timer_Queue_T&lt; TYPE, FUNCTOR, ACE_LOCK &gt;::ACE_Timer_Queue_T </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const ACE_Timer_Queue_T&lt; TYPE, FUNCTOR, ACE_LOCK &gt; &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [private]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<hr><h2>Member Function Documentation</h2>
<a name="b1" doxytag="ACE_Timer_Queue_T::alloc_node"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class TYPE, class FUNCTOR, class ACE_LOCK&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="classACE__Timer__Node__T.html">ACE_Timer_Node_T</a>&lt; TYPE &gt; * ACE_Timer_Queue_T&lt; TYPE, FUNCTOR, ACE_LOCK &gt;::alloc_node </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [protected, virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Factory method that allocates a new node.
<p>

<p>
Reimplemented in <a class="el" href="classACE__Timer__Heap__T.html#b1">ACE_Timer_Heap_T</a>.    </td>
  </tr>
</table>
<a name="a14" doxytag="ACE_Timer_Queue_T::calculate_timeout"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class TYPE, class FUNCTOR, class ACE_LOCK&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="classACE__Time__Value.html">ACE_Time_Value</a> * ACE_Timer_Queue_T&lt; TYPE, FUNCTOR, ACE_LOCK &gt;::calculate_timeout </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classACE__Time__Value.html">ACE_Time_Value</a> *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>max_wait_time</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="classACE__Time__Value.html">ACE_Time_Value</a> *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>the_timeout</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Determine the next event to timeout. Returns &lt;max&gt; if there are no pending timers or if all pending timers are longer than max. &lt;the_timeout&gt; should be a pointer to storage for the timeout value, and this value is also returned. This method does not acquire a lock internally since it doesn't modify internal state. If you  need to call this method when the queue is being modified concurrently, however, you should make sure to acquire the &lt;<a class="el" href="classACE__Timer__Queue__T.html#a17">mutex</a>()&gt; externally before making the call.     </td>
  </tr>
</table>
<a name="a13" doxytag="ACE_Timer_Queue_T::calculate_timeout"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class TYPE, class FUNCTOR, class ACE_LOCK&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="classACE__Time__Value.html">ACE_Time_Value</a> * ACE_Timer_Queue_T&lt; TYPE, FUNCTOR, ACE_LOCK &gt;::calculate_timeout </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classACE__Time__Value.html">ACE_Time_Value</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>max_wait_time</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Determine the next event to timeout. Returns &lt;max&gt; if there are no pending timers or if all pending timers are longer than max. This method acquires a lock internally since it modifies internal state.
<p>
    </td>
  </tr>
</table>
<a name="a7" doxytag="ACE_Timer_Queue_T::cancel"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class TYPE, class FUNCTOR, class ACE_LOCK&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> virtual int ACE_Timer_Queue_T&lt; TYPE, FUNCTOR, ACE_LOCK &gt;::cancel </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">long&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>timer_id</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const void **&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>act</em> = 0, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>skip_close</em> = 1</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Cancel the single timer that matches the &lt;timer_id&gt; value (which was returned from the &lt;schedule&gt; method). If act is non-NULL then it will be set to point to the ``magic cookie'' argument passed in when the timer was registered. This makes it possible to free up the memory and avoid memory leaks. If &lt;dont_call_handle_close&gt; is 0 then the &lt;functor&gt; will be invoked, which typically calls the &lt;handle_close&gt; hook. Returns 1 if cancellation succeeded and 0 if the &lt;timer_id&gt; wasn't found. 
<p>
Reimplemented in <a class="el" href="classACE__Timer__Hash__T.html#a8">ACE_Timer_Hash_T</a>, <a class="el" href="classACE__Timer__Heap__T.html#a8">ACE_Timer_Heap_T</a>, <a class="el" href="classACE__Timer__List__T.html#a7">ACE_Timer_List_T</a>, and <a class="el" href="classACE__Timer__Wheel__T.html#a8">ACE_Timer_Wheel_T</a>.    </td>
  </tr>
</table>
<a name="a6" doxytag="ACE_Timer_Queue_T::cancel"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class TYPE, class FUNCTOR, class ACE_LOCK&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> virtual int ACE_Timer_Queue_T&lt; TYPE, FUNCTOR, ACE_LOCK &gt;::cancel </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const TYPE &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>type</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>skip_close</em> = 1</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Cancel all timer associated with &lt;type&gt;. If &lt;dont_call_handle_close&gt; is 0 then the &lt;functor&gt; will be invoked, which typically invokes the &lt;handle_close&gt; hook. Returns number of timers cancelled. 
<p>
Reimplemented in <a class="el" href="classACE__Timer__Hash__T.html#a7">ACE_Timer_Hash_T</a>, <a class="el" href="classACE__Timer__Heap__T.html#a7">ACE_Timer_Heap_T</a>, <a class="el" href="classACE__Timer__List__T.html#a6">ACE_Timer_List_T</a>, and <a class="el" href="classACE__Timer__Wheel__T.html#a7">ACE_Timer_Wheel_T</a>.    </td>
  </tr>
</table>
<a name="a9" doxytag="ACE_Timer_Queue_T::dispatch_info"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class TYPE, class FUNCTOR, class ACE_LOCK&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> int ACE_Timer_Queue_T&lt; TYPE, FUNCTOR, ACE_LOCK &gt;::dispatch_info </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classACE__Time__Value.html">ACE_Time_Value</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>cur_time</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="classACE__Timer__Node__Dispatch__Info__T.html">ACE_Timer_Node_Dispatch_Info_T</a>&lt; TYPE &gt; &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>info</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get the dispatch information for a timer whose value is &lt;= &lt;cur_time&gt;. This does not account for &lt;timer_skew&gt;. Returns 1 if there is a node whose value &lt;= &lt;cur_time&gt; else returns a 0.     </td>
  </tr>
</table>
<a name="b3" doxytag="ACE_Timer_Queue_T::dispatch_info_i"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class TYPE, class FUNCTOR, class ACE_LOCK&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> int ACE_Timer_Queue_T&lt; TYPE, FUNCTOR, ACE_LOCK &gt;::dispatch_info_i </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classACE__Time__Value.html">ACE_Time_Value</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>cur_time</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="classACE__Timer__Node__Dispatch__Info__T.html">ACE_Timer_Node_Dispatch_Info_T</a>&lt; TYPE &gt; &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>info</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [protected]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Non-locking version of dispatch_info ().
<p>
    </td>
  </tr>
</table>
<a name="a21" doxytag="ACE_Timer_Queue_T::dump"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class TYPE, class FUNCTOR, class ACE_LOCK&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> void ACE_Timer_Queue_T&lt; TYPE, FUNCTOR, ACE_LOCK &gt;::dump </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap> const<code> [virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Dump the state of a object.
<p>

<p>
Reimplemented in <a class="el" href="classACE__Timer__Hash__T.html#a13">ACE_Timer_Hash_T</a>, <a class="el" href="classACE__Timer__Heap__T.html#a11">ACE_Timer_Heap_T</a>, <a class="el" href="classACE__Timer__List__T.html#a10">ACE_Timer_List_T</a>, and <a class="el" href="classACE__Timer__Wheel__T.html#a13">ACE_Timer_Wheel_T</a>.    </td>
  </tr>
</table>
<a name="a3" doxytag="ACE_Timer_Queue_T::earliest_time"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class TYPE, class FUNCTOR, class ACE_LOCK&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> virtual const <a class="el" href="classACE__Time__Value.html">ACE_Time_Value</a>&amp; ACE_Timer_Queue_T&lt; TYPE, FUNCTOR, ACE_LOCK &gt;::earliest_time </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap> const<code> [pure virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns the time of the earlier node in the Timer_Queue. Must be called on a non-empty queue.
<p>

<p>
Reimplemented in <a class="el" href="classACE__Timer__Hash__T.html#a4">ACE_Timer_Hash_T</a>, <a class="el" href="classACE__Timer__Heap__T.html#a4">ACE_Timer_Heap_T</a>, <a class="el" href="classACE__Timer__List__T.html#a3">ACE_Timer_List_T</a>, and <a class="el" href="classACE__Timer__Wheel__T.html#a4">ACE_Timer_Wheel_T</a>.    </td>
  </tr>
</table>
<a name="a10" doxytag="ACE_Timer_Queue_T::expire"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class TYPE, class FUNCTOR, class ACE_LOCK&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> ACE_INLINE int ACE_Timer_Queue_T&lt; TYPE, FUNCTOR, ACE_LOCK &gt;::expire </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Run the &lt;functor&gt; for all timers whose values are &lt;= &lt;<a class="el" href="classACE__OS.html#z32_5">ACE_OS::gettimeofday</a>&gt;. Also accounts for &lt;timer_skew&gt;.
<p>
Depending on the resolution of the underlying OS the system calls like select()/poll() might return at time different than that is specified in the timeout. Suppose the OS guarantees a resolution of t ms. The timeline will look like
<p>
A B | | V V |-------------|-------------|-------------|-------------| t t t t t
<p>
If you specify a timeout value of A, then the timeout will not occur at A but at the next interval of the timer, which is later than that is expected. Similarly, if your timeout value is equal to B, then the timeout will occur at interval after B. Now depending upon the resolution of your timeouts and the accuracy of the timeouts needed for your application, you should set the value of &lt;timer_skew&gt;. In the above case, if you want the timeout A to fire no later than A, then you should specify your &lt;timer_skew&gt; to be A % t.
<p>
The timeout value should be specified via the macro ACE_TIMER_SKEW in your config.h file. The default value is zero.
<p>
Things get interesting if the t before the timeout value B is zero i.e your timeout is less than the interval. In that case, you are almost sure of not getting the desired timeout behaviour. Maybe you should look for a better OS :-)
<p>
Returns the number of timers canceled. 
<p>
Reimplemented in <a class="el" href="classACE__Timer__Hash__T.html#a9">ACE_Timer_Hash_T</a>, and <a class="el" href="classACE__Timer__Wheel__T.html#a9">ACE_Timer_Wheel_T</a>.    </td>
  </tr>
</table>
<a name="a8" doxytag="ACE_Timer_Queue_T::expire"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class TYPE, class FUNCTOR, class ACE_LOCK&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> int ACE_Timer_Queue_T&lt; TYPE, FUNCTOR, ACE_LOCK &gt;::expire </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classACE__Time__Value.html">ACE_Time_Value</a> &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>cur_time</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Run the &lt;functor&gt; for all timers whose values are &lt;= &lt;cur_time&gt;. This does not account for &lt;timer_skew&gt;. Returns the number of timers canceled. 
<p>
Reimplemented in <a class="el" href="classACE__Timer__Hash__T.html#a10">ACE_Timer_Hash_T</a>, and <a class="el" href="classACE__Timer__Wheel__T.html#a10">ACE_Timer_Wheel_T</a>.    </td>
  </tr>
</table>
<a name="b2" doxytag="ACE_Timer_Queue_T::free_node"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class TYPE, class FUNCTOR, class ACE_LOCK&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> void ACE_Timer_Queue_T&lt; TYPE, FUNCTOR, ACE_LOCK &gt;::free_node </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classACE__Timer__Node__T.html">ACE_Timer_Node_T</a>&lt; TYPE &gt; *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>node</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [protected, virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Factory method that frees a previously allocated node.
<p>

<p>
Reimplemented in <a class="el" href="classACE__Timer__Heap__T.html#b2">ACE_Timer_Heap_T</a>.    </td>
  </tr>
</table>
<a name="a22" doxytag="ACE_Timer_Queue_T::get_first"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class TYPE, class FUNCTOR, class ACE_LOCK&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> virtual <a class="el" href="classACE__Timer__Node__T.html">ACE_Timer_Node_T</a>&lt;TYPE&gt;* ACE_Timer_Queue_T&lt; TYPE, FUNCTOR, ACE_LOCK &gt;::get_first </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Reads the earliest node from the queue and returns it.
<p>

<p>
Reimplemented in <a class="el" href="classACE__Timer__Hash__T.html#a14">ACE_Timer_Hash_T</a>, <a class="el" href="classACE__Timer__Heap__T.html#a12">ACE_Timer_Heap_T</a>, <a class="el" href="classACE__Timer__List__T.html#a12">ACE_Timer_List_T</a>, and <a class="el" href="classACE__Timer__Wheel__T.html#a14">ACE_Timer_Wheel_T</a>.    </td>
  </tr>
</table>
<a name="a12" doxytag="ACE_Timer_Queue_T::gettimeofday"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class TYPE, class FUNCTOR, class ACE_LOCK&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> ACE_INLINE void ACE_Timer_Queue_T&lt; TYPE, FUNCTOR, ACE_LOCK &gt;::gettimeofday </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classACE__Time__Value.html">ACE_Time_Value</a>(*&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>gettimeofday</em>)(void)          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Allows applications to control how the timer queue gets the time of day.
<p>
    </td>
  </tr>
</table>
<a name="a11" doxytag="ACE_Timer_Queue_T::gettimeofday"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class TYPE, class FUNCTOR, class ACE_LOCK&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> ACE_INLINE <a class="el" href="classACE__Time__Value.html">ACE_Time_Value</a> ACE_Timer_Queue_T&lt; TYPE, FUNCTOR, ACE_LOCK &gt;::gettimeofday </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns the current time of day. This method allows different implementations of the timer queue to use special high resolution timers.     </td>
  </tr>
</table>
<a name="a2" doxytag="ACE_Timer_Queue_T::is_empty"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class TYPE, class FUNCTOR, class ACE_LOCK&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> virtual int ACE_Timer_Queue_T&lt; TYPE, FUNCTOR, ACE_LOCK &gt;::is_empty </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap> const<code> [pure virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
True if queue is empty, else false.
<p>

<p>
Reimplemented in <a class="el" href="classACE__Timer__Hash__T.html#a3">ACE_Timer_Hash_T</a>, <a class="el" href="classACE__Timer__Heap__T.html#a3">ACE_Timer_Heap_T</a>, <a class="el" href="classACE__Timer__List__T.html#a2">ACE_Timer_List_T</a>, and <a class="el" href="classACE__Timer__Wheel__T.html#a3">ACE_Timer_Wheel_T</a>.    </td>
  </tr>
</table>
<a name="a19" doxytag="ACE_Timer_Queue_T::iter"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class TYPE, class FUNCTOR, class ACE_LOCK&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> virtual <a class="el" href="classACE__Timer__Queue__T.html#s0">ITERATOR</a>&amp; ACE_Timer_Queue_T&lt; TYPE, FUNCTOR, ACE_LOCK &gt;::iter </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns a pointer to this &lt;ACE_Timer_Queue&gt;'s iterator.
<p>

<p>
Reimplemented in <a class="el" href="classACE__Timer__Hash__T.html#a11">ACE_Timer_Hash_T</a>, <a class="el" href="classACE__Timer__Heap__T.html#a9">ACE_Timer_Heap_T</a>, <a class="el" href="classACE__Timer__List__T.html#a8">ACE_Timer_List_T</a>, and <a class="el" href="classACE__Timer__Wheel__T.html#a11">ACE_Timer_Wheel_T</a>.    </td>
  </tr>
</table>
<a name="a17" doxytag="ACE_Timer_Queue_T::mutex"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class TYPE, class FUNCTOR, class ACE_LOCK&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> ACE_LOCK &amp; ACE_Timer_Queue_T&lt; TYPE, FUNCTOR, ACE_LOCK &gt;::mutex </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Synchronization variable used by the queue.
<p>
    </td>
  </tr>
</table>
<a name="c1" doxytag="ACE_Timer_Queue_T::operator="></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class TYPE, class FUNCTOR, class ACE_LOCK&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> void ACE_Timer_Queue_T&lt; TYPE, FUNCTOR, ACE_LOCK &gt;::operator= </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const ACE_Timer_Queue_T&lt; TYPE, FUNCTOR, ACE_LOCK &gt; &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [private]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a name="a20" doxytag="ACE_Timer_Queue_T::remove_first"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class TYPE, class FUNCTOR, class ACE_LOCK&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> virtual <a class="el" href="classACE__Timer__Node__T.html">ACE_Timer_Node_T</a>&lt;TYPE&gt;* ACE_Timer_Queue_T&lt; TYPE, FUNCTOR, ACE_LOCK &gt;::remove_first </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Removes the earliest node from the queue and returns it.
<p>

<p>
Reimplemented in <a class="el" href="classACE__Timer__Hash__T.html#a12">ACE_Timer_Hash_T</a>, <a class="el" href="classACE__Timer__Heap__T.html#a10">ACE_Timer_Heap_T</a>, <a class="el" href="classACE__Timer__List__T.html#a9">ACE_Timer_List_T</a>, and <a class="el" href="classACE__Timer__Wheel__T.html#a12">ACE_Timer_Wheel_T</a>.    </td>
  </tr>
</table>
<a name="b0" doxytag="ACE_Timer_Queue_T::reschedule"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class TYPE, class FUNCTOR, class ACE_LOCK&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> virtual void ACE_Timer_Queue_T&lt; TYPE, FUNCTOR, ACE_LOCK &gt;::reschedule </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classACE__Timer__Node__T.html">ACE_Timer_Node_T</a>&lt; TYPE &gt; *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>n</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [protected, pure virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Reschedule an "interval" &lt;ACE_Timer_Node&gt;.
<p>

<p>
Reimplemented in <a class="el" href="classACE__Timer__Hash__T.html#c0">ACE_Timer_Hash_T</a>, <a class="el" href="classACE__Timer__Heap__T.html#b0">ACE_Timer_Heap_T</a>, <a class="el" href="classACE__Timer__List__T.html#a11">ACE_Timer_List_T</a>, and <a class="el" href="classACE__Timer__Wheel__T.html#c3">ACE_Timer_Wheel_T</a>.    </td>
  </tr>
</table>
<a name="a5" doxytag="ACE_Timer_Queue_T::reset_interval"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class TYPE, class FUNCTOR, class ACE_LOCK&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> virtual int ACE_Timer_Queue_T&lt; TYPE, FUNCTOR, ACE_LOCK &gt;::reset_interval </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">long&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>timer_id</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const <a class="el" href="classACE__Time__Value.html">ACE_Time_Value</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>interval</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Resets the interval of the timer represented by &lt;timer_id&gt; to &lt;interval&gt;, which is specified in relative time to the current &lt;gettimeofday&gt;. If &lt;interval&gt; is equal to &lt;<a class="el" href="classACE__Time__Value.html#p0">ACE_Time_Value::zero</a>&gt;, the timer will become a non-rescheduling timer. Returns 0 if successful, -1 if not. 
<p>
Reimplemented in <a class="el" href="classACE__Timer__Hash__T.html#a6">ACE_Timer_Hash_T</a>, <a class="el" href="classACE__Timer__Heap__T.html#a6">ACE_Timer_Heap_T</a>, <a class="el" href="classACE__Timer__List__T.html#a5">ACE_Timer_List_T</a>, and <a class="el" href="classACE__Timer__Wheel__T.html#a6">ACE_Timer_Wheel_T</a>.    </td>
  </tr>
</table>
<a name="a23" doxytag="ACE_Timer_Queue_T::return_node"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class TYPE, class FUNCTOR, class ACE_LOCK&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> void ACE_Timer_Queue_T&lt; TYPE, FUNCTOR, ACE_LOCK &gt;::return_node </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classACE__Timer__Node__T.html">ACE_Timer_Node_T</a>&lt; TYPE &gt; *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>node</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Method used to return a timer node to the queue's ownership after it is returned by a method like &lt;remove_first&gt;.
<p>
    </td>
  </tr>
</table>
<a name="a4" doxytag="ACE_Timer_Queue_T::schedule"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class TYPE, class FUNCTOR, class ACE_LOCK&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> virtual long ACE_Timer_Queue_T&lt; TYPE, FUNCTOR, ACE_LOCK &gt;::schedule </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const TYPE &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>type</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const void *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>act</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const <a class="el" href="classACE__Time__Value.html">ACE_Time_Value</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>future_time</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const <a class="el" href="classACE__Time__Value.html">ACE_Time_Value</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>interval</em> = <a class="el" href="classACE__Time__Value.html#p0">ACE_Time_Value::zero</a></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Schedule &lt;type&gt; that will expire at &lt;future_time&gt;, which is specified in absolute time. If it expires then &lt;act&gt; is passed in as the value to the &lt;functor&gt;. If &lt;interval&gt; is != to &lt;<a class="el" href="classACE__Time__Value.html#p0">ACE_Time_Value::zero</a>&gt; then it is used to reschedule the &lt;type&gt; automatically, using relative time to the current &lt;gettimeofday&gt;. This method returns a &lt;timer_id&gt; that uniquely identifies the the &lt;type&gt; entry in an internal list. This &lt;timer_id&gt; can be used to cancel the timer before it expires. The cancellation ensures that &lt;timer_ids&gt; are unique up to values of greater than 2 billion timers. As long as timers don't stay around longer than this there should be no problems with accidentally deleting the wrong timer. Returns -1 on failure (which is guaranteed never to be a valid &lt;timer_id&gt;). 
<p>
Reimplemented in <a class="el" href="classACE__Timer__Hash__T.html#a5">ACE_Timer_Hash_T</a>, <a class="el" href="classACE__Timer__Heap__T.html#a5">ACE_Timer_Heap_T</a>, <a class="el" href="classACE__Timer__List__T.html#a4">ACE_Timer_List_T</a>, and <a class="el" href="classACE__Timer__Wheel__T.html#a5">ACE_Timer_Wheel_T</a>.    </td>
  </tr>
</table>
<a name="a16" doxytag="ACE_Timer_Queue_T::timer_skew"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class TYPE, class FUNCTOR, class ACE_LOCK&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> ACE_INLINE const <a class="el" href="classACE__Time__Value.html">ACE_Time_Value</a> &amp; ACE_Timer_Queue_T&lt; TYPE, FUNCTOR, ACE_LOCK &gt;::timer_skew </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap> const</td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get the timer skew for the Timer_Queue.
<p>
    </td>
  </tr>
</table>
<a name="a15" doxytag="ACE_Timer_Queue_T::timer_skew"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class TYPE, class FUNCTOR, class ACE_LOCK&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> ACE_INLINE void ACE_Timer_Queue_T&lt; TYPE, FUNCTOR, ACE_LOCK &gt;::timer_skew </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classACE__Time__Value.html">ACE_Time_Value</a> &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>skew</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Set the timer skew for the Timer_Queue.
<p>
    </td>
  </tr>
</table>
<a name="a24" doxytag="ACE_Timer_Queue_T::upcall"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class TYPE, class FUNCTOR, class ACE_LOCK&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> ACE_INLINE void ACE_Timer_Queue_T&lt; TYPE, FUNCTOR, ACE_LOCK &gt;::upcall </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">TYPE &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>type</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const void *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>act</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const <a class="el" href="classACE__Time__Value.html">ACE_Time_Value</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>cur_time</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This method will call the &lt;functor&gt; with the &lt;type&gt;, &lt;act&gt; and &lt;cur_time&gt;.
<p>
    </td>
  </tr>
</table>
<a name="a18" doxytag="ACE_Timer_Queue_T::upcall_functor"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class TYPE, class FUNCTOR, class ACE_LOCK&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> ACE_INLINE FUNCTOR &amp; ACE_Timer_Queue_T&lt; TYPE, FUNCTOR, ACE_LOCK &gt;::upcall_functor </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Accessor to the upcall functor.
<p>
    </td>
  </tr>
</table>
<hr><h2>Member Data Documentation</h2>
<a name="n5" doxytag="ACE_Timer_Queue_T::delete_free_list_"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class TYPE, class FUNCTOR, class ACE_LOCK&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> int ACE_Timer_Queue_T::delete_free_list_<code> [protected]</code>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Flag to delete only if the class created the &lt;free_list_&gt;.
<p>
    </td>
  </tr>
</table>
<a name="n4" doxytag="ACE_Timer_Queue_T::delete_upcall_functor_"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class TYPE, class FUNCTOR, class ACE_LOCK&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> int ACE_Timer_Queue_T::delete_upcall_functor_<code> [protected]</code>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
To delete or not to delete is the question?
<p>
    </td>
  </tr>
</table>
<a name="n1" doxytag="ACE_Timer_Queue_T::free_list_"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class TYPE, class FUNCTOR, class ACE_LOCK&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="classACE__Free__List.html">ACE_Free_List</a>&lt;<a class="el" href="classACE__Timer__Node__T.html">ACE_Timer_Node_T</a>&lt;TYPE&gt; &gt;* ACE_Timer_Queue_T::free_list_<code> [protected]</code>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Class that implements a free list.
<p>
    </td>
  </tr>
</table>
<a name="n2" doxytag="ACE_Timer_Queue_T::gettimeofday_"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class TYPE, class FUNCTOR, class ACE_LOCK&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="classACE__Time__Value.html">ACE_Time_Value</a>(* ACE_Timer_Queue_T::gettimeofday_)(void)<code> [protected]</code>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Pointer to function that returns the current time of day.
<p>
    </td>
  </tr>
</table>
<a name="n0" doxytag="ACE_Timer_Queue_T::mutex_"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class TYPE, class FUNCTOR, class ACE_LOCK&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> ACE_LOCK ACE_Timer_Queue_T::mutex_<code> [protected]</code>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Synchronization variable for &lt;ACE_Timer_Queue&gt;. NOTE: the right name would be lock_, but HP/C++ will choke on that!
<p>
    </td>
  </tr>
</table>
<a name="o0" doxytag="ACE_Timer_Queue_T::timeout_"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class TYPE, class FUNCTOR, class ACE_LOCK&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="classACE__Time__Value.html">ACE_Time_Value</a> ACE_Timer_Queue_T::timeout_<code> [private]</code>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returned by &lt;calculate_timeout&gt;.
<p>
    </td>
  </tr>
</table>
<a name="o1" doxytag="ACE_Timer_Queue_T::timer_skew_"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class TYPE, class FUNCTOR, class ACE_LOCK&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="classACE__Time__Value.html">ACE_Time_Value</a> ACE_Timer_Queue_T::timer_skew_<code> [private]</code>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Adjusts for timer skew in various clocks.
<p>
    </td>
  </tr>
</table>
<a name="n3" doxytag="ACE_Timer_Queue_T::upcall_functor_"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class TYPE, class FUNCTOR, class ACE_LOCK&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> FUNCTOR* ACE_Timer_Queue_T::upcall_functor_<code> [protected]</code>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Upcall functor.
<p>
    </td>
  </tr>
</table>
<hr>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="Timer__Queue__T_8h.html">Timer_Queue_T.h</a><li><a class="el" href="Timer__Queue__T_8cpp.html">Timer_Queue_T.cpp</a><li><a class="el" href="Timer__Queue__T_8i.html">Timer_Queue_T.i</a></ul>
<hr><address><small>Generated on Wed Jan 15 19:15:17 2003 for ACE by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.gif" alt="doxygen" align="middle" border=0 
width=110 height=53></a>1.2.13.1 written by <a href="mailto:dimitri@stack.nl">Dimitri van Heesch</a>,
 &copy;&nbsp;1997-2001</small></address>
</body>
</html>
