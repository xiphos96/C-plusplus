<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title> TemplateACE_RB_Tree class Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body bgcolor="#ffffff">
<!-- Generated by Doxygen 1.2.13.1 -->
<center>
<a class="qindex" href="index.html">Main Page</a> &nbsp; <a class="qindex" href="hierarchy.html">Class Hierarchy</a> &nbsp; <a class="qindex" href="classes.html">Alphabetical List</a> &nbsp; <a class="qindex" href="annotated.html">Compound List</a> &nbsp; <a class="qindex" href="files.html">File List</a> &nbsp; <a class="qindex" href="functions.html">Compound Members</a> &nbsp; <a class="qindex" href="globals.html">File Members</a> &nbsp; <a class="qindex" href="pages.html">Related Pages</a> &nbsp; </center>
<hr><h1>ACE_RB_Tree  Class Template Reference</h1>Implements a Red-Black Tree ADT, according to T. H. Corman, C. E. Leiserson, and R. L. Rivest, "Introduction to Algorithms" 1990, MIT, chapter 14. 
<a href="#_details">More...</a>
<p>
<code>#include &lt;RB_Tree.h&gt;</code>
<p>
Inheritance diagram for ACE_RB_Tree:<p><center><img src="classACE__RB__Tree__inherit__graph.gif" border="0" usemap="#ACE__RB__Tree_3_01EXT__ID_00_01INT__ID_00_01COMPARE__KEYS_00_01ACE__LOCK_01_4__inherit__map" alt="Inheritance graph"></center>
<map name="ACE__RB__Tree_3_01EXT__ID_00_01INT__ID_00_01COMPARE__KEYS_00_01ACE__LOCK_01_4__inherit__map">
<area href="classACE__RB__Tree__Base.html" shape="rect" coords="154,15,287,34" alt="">
</map>
<center><font size="2">[<a href="graph_legend.html">legend</a>]</font></center>Collaboration diagram for ACE_RB_Tree:<p><center><img src="classACE__RB__Tree__coll__graph.gif" border="0" usemap="#ACE__RB__Tree_3_01EXT__ID_00_01INT__ID_00_01COMPARE__KEYS_00_01ACE__LOCK_01_4__coll__map" alt="Collaboration graph"></center>
<map name="ACE__RB__Tree_3_01EXT__ID_00_01INT__ID_00_01COMPARE__KEYS_00_01ACE__LOCK_01_4__coll__map">
<area href="classACE__RB__Tree__Base.html" shape="rect" coords="83,7,217,25" alt="">
<area href="classACE__Allocator.html" shape="rect" coords="102,93,198,112" alt="">
<area href="classACE__RB__Tree__Node.html" shape="rect" coords="25,264,275,283" alt="">
</map>
<center><font size="2">[<a href="graph_legend.html">legend</a>]</font></center><a href="classACE__RB__Tree-members.html">List of all members.</a><table border=0 cellpadding=0 cellspacing=0>
<tr><td colspan=2><br><h2>Public Types</h2></td></tr>
<tr><td nowrap align=right valign=top>typedef EXT_ID&nbsp;</td><td valign=bottom><a class="el" href="classACE__RB__Tree.html#s0">KEY</a></td></tr>
<tr><td nowrap align=right valign=top>typedef INT_ID&nbsp;</td><td valign=bottom><a class="el" href="classACE__RB__Tree.html#s1">VALUE</a></td></tr>
<tr><td nowrap align=right valign=top>typedef <a class="el" href="classACE__RB__Tree__Node.html">ACE_RB_Tree_Node</a>&lt;<br>
 EXT_ID, INT_ID &gt;&nbsp;</td><td valign=bottom><a class="el" href="classACE__RB__Tree.html#s2">ENTRY</a></td></tr>
<tr><td nowrap align=right valign=top>typedef <a class="el" href="classACE__RB__Tree__Iterator.html">ACE_RB_Tree_Iterator</a>&lt;<br>
 EXT_ID, INT_ID, COMPARE_KEYS,<br>
 ACE_LOCK &gt;&nbsp;</td><td valign=bottom><a class="el" href="classACE__RB__Tree.html#s3">ITERATOR</a></td></tr>
<tr><td nowrap align=right valign=top>typedef <a class="el" href="classACE__RB__Tree__Reverse__Iterator.html">ACE_RB_Tree_Reverse_Iterator</a>&lt;<br>
 EXT_ID, INT_ID, COMPARE_KEYS,<br>
 ACE_LOCK &gt;&nbsp;</td><td valign=bottom><a class="el" href="classACE__RB__Tree.html#s4">REVERSE_ITERATOR</a></td></tr>
<tr><td nowrap align=right valign=top>typedef <a class="el" href="classACE__RB__Tree__Iterator.html">ACE_RB_Tree_Iterator</a>&lt;<br>
 EXT_ID, INT_ID, COMPARE_KEYS,<br>
 ACE_LOCK &gt;&nbsp;</td><td valign=bottom><a class="el" href="classACE__RB__Tree.html#s5">iterator</a></td></tr>
<tr><td nowrap align=right valign=top>typedef <a class="el" href="classACE__RB__Tree__Reverse__Iterator.html">ACE_RB_Tree_Reverse_Iterator</a>&lt;<br>
 EXT_ID, INT_ID, COMPARE_KEYS,<br>
 ACE_LOCK &gt;&nbsp;</td><td valign=bottom><a class="el" href="classACE__RB__Tree.html#s6">reverse_iterator</a></td></tr>
<tr><td colspan=2><br><h2>Public Methods</h2></td></tr>
<tr><td nowrap align=right valign=top>&nbsp;</td><td valign=bottom><a class="el" href="classACE__RB__Tree.html#a0">ACE_RB_Tree</a> (<a class="el" href="classACE__Allocator.html">ACE_Allocator</a> *alloc=0)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Constructor.</em> <a href="#a0">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>&nbsp;</td><td valign=bottom><a class="el" href="classACE__RB__Tree.html#a1">ACE_RB_Tree</a> (const ACE_RB_Tree&lt; EXT_ID, INT_ID, COMPARE_KEYS, ACE_LOCK &gt; &amp;rbt)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Copy constructor.</em> <a href="#a1">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>int&nbsp;</td><td valign=bottom><a class="el" href="classACE__RB__Tree.html#a2">open</a> (<a class="el" href="classACE__Allocator.html">ACE_Allocator</a> *alloc=0)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Initialize an RB Tree.</em> <a href="#a2">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>int&nbsp;</td><td valign=bottom><a class="el" href="classACE__RB__Tree.html#a3">close</a> (void)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Close down an RB_Tree and release dynamically allocated resources.</em> <a href="#a3">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>virtual&nbsp;</td><td valign=bottom><a class="el" href="classACE__RB__Tree.html#a4">~ACE_RB_Tree</a> (void)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Destructor.</em> <a href="#a4">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>int&nbsp;</td><td valign=bottom><a class="el" href="classACE__RB__Tree.html#a5">bind</a> (const EXT_ID &amp;item, const INT_ID &amp;int_id)</td></tr>
<tr><td nowrap align=right valign=top>int&nbsp;</td><td valign=bottom><a class="el" href="classACE__RB__Tree.html#a6">bind</a> (const EXT_ID &amp;ext_id, const INT_ID &amp;int_id, <a class="el" href="classACE__RB__Tree__Node.html">ACE_RB_Tree_Node</a>&lt; EXT_ID, INT_ID &gt; *&amp;entry)</td></tr>
<tr><td nowrap align=right valign=top>int&nbsp;</td><td valign=bottom><a class="el" href="classACE__RB__Tree.html#a7">trybind</a> (const EXT_ID &amp;ext_id, INT_ID &amp;int_id)</td></tr>
<tr><td nowrap align=right valign=top>int&nbsp;</td><td valign=bottom><a class="el" href="classACE__RB__Tree.html#a8">trybind</a> (const EXT_ID &amp;ext_id, INT_ID &amp;int_id, <a class="el" href="classACE__RB__Tree__Node.html">ACE_RB_Tree_Node</a>&lt; EXT_ID, INT_ID &gt; *&amp;entry)</td></tr>
<tr><td nowrap align=right valign=top>int&nbsp;</td><td valign=bottom><a class="el" href="classACE__RB__Tree.html#a9">rebind</a> (const EXT_ID &amp;ext_id, const INT_ID &amp;int_id)</td></tr>
<tr><td nowrap align=right valign=top>int&nbsp;</td><td valign=bottom><a class="el" href="classACE__RB__Tree.html#a10">rebind</a> (const EXT_ID &amp;ext_id, const INT_ID &amp;int_id, <a class="el" href="classACE__RB__Tree__Node.html">ACE_RB_Tree_Node</a>&lt; EXT_ID, INT_ID &gt; *&amp;entry)</td></tr>
<tr><td nowrap align=right valign=top>int&nbsp;</td><td valign=bottom><a class="el" href="classACE__RB__Tree.html#a11">rebind</a> (const EXT_ID &amp;ext_id, const INT_ID &amp;int_id, INT_ID &amp;old_int_id)</td></tr>
<tr><td nowrap align=right valign=top>int&nbsp;</td><td valign=bottom><a class="el" href="classACE__RB__Tree.html#a12">rebind</a> (const EXT_ID &amp;ext_id, const INT_ID &amp;int_id, INT_ID &amp;old_int_id, <a class="el" href="classACE__RB__Tree__Node.html">ACE_RB_Tree_Node</a>&lt; EXT_ID, INT_ID &gt; *&amp;entry)</td></tr>
<tr><td nowrap align=right valign=top>int&nbsp;</td><td valign=bottom><a class="el" href="classACE__RB__Tree.html#a13">rebind</a> (const EXT_ID &amp;ext_id, const INT_ID &amp;int_id, EXT_ID &amp;old_ext_id, INT_ID &amp;old_int_id)</td></tr>
<tr><td nowrap align=right valign=top>int&nbsp;</td><td valign=bottom><a class="el" href="classACE__RB__Tree.html#a14">rebind</a> (const EXT_ID &amp;ext_id, const INT_ID &amp;int_id, EXT_ID &amp;old_ext_id, INT_ID &amp;old_int_id, <a class="el" href="classACE__RB__Tree__Node.html">ACE_RB_Tree_Node</a>&lt; EXT_ID, INT_ID &gt; *&amp;entry)</td></tr>
<tr><td nowrap align=right valign=top>int&nbsp;</td><td valign=bottom><a class="el" href="classACE__RB__Tree.html#a15">find</a> (const EXT_ID &amp;ext_id, INT_ID &amp;int_id)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Locate &lt;ext_id&gt; and pass out parameter via &lt;int_id&gt;. If found, return 0, returns -1 if not found.</em> <a href="#a15">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>int&nbsp;</td><td valign=bottom><a class="el" href="classACE__RB__Tree.html#a16">find</a> (const EXT_ID &amp;ext_id, <a class="el" href="classACE__RB__Tree__Node.html">ACE_RB_Tree_Node</a>&lt; EXT_ID, INT_ID &gt; *&amp;entry)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Locate &lt;ext_id&gt; and pass out parameter via &lt;entry&gt;. If found, return 0, returns -1 if not found.</em> <a href="#a16">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>int&nbsp;</td><td valign=bottom><a class="el" href="classACE__RB__Tree.html#a17">unbind</a> (const EXT_ID &amp;ext_id)</td></tr>
<tr><td nowrap align=right valign=top>int&nbsp;</td><td valign=bottom><a class="el" href="classACE__RB__Tree.html#a18">unbind</a> (const EXT_ID &amp;ext_id, INT_ID &amp;int_id)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Break any association of &lt;ext_id&gt;. Returns the value of &lt;int_id&gt; in case the caller needs to deallocate memory.</em> <a href="#a18">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>int&nbsp;</td><td valign=bottom><a class="el" href="classACE__RB__Tree.html#a19">unbind</a> (<a class="el" href="classACE__RB__Tree__Node.html">ACE_RB_Tree_Node</a>&lt; EXT_ID, INT_ID &gt; *entry)</td></tr>
<tr><td nowrap align=right valign=top>size_t&nbsp;</td><td valign=bottom><a class="el" href="classACE__RB__Tree.html#a20">current_size</a> (void) const</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Returns the current number of nodes in the tree.</em> <a href="#a20">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classACE__RB__Tree.html#a21">operator=</a> (const ACE_RB_Tree&lt; EXT_ID, INT_ID, COMPARE_KEYS, ACE_LOCK &gt; &amp;rbt)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Assignment operator.</em> <a href="#a21">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>virtual int&nbsp;</td><td valign=bottom><a class="el" href="classACE__RB__Tree.html#a22">lessthan</a> (const EXT_ID &amp;k1, const EXT_ID &amp;k2)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Less than comparison function for keys, using comparison functor.</em> <a href="#a22">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>ACE_LOCK &amp;&nbsp;</td><td valign=bottom><a class="el" href="classACE__RB__Tree.html#a23">mutex</a> (void)</td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classACE__RB__Tree.html#a24">dump</a> (void) const</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Dump the state of an object.</em> <a href="#a24">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top><a class="el" href="classACE__RB__Tree__Iterator.html">ACE_RB_Tree_Iterator</a>&lt; EXT_ID,<br>
 INT_ID, COMPARE_KEYS, ACE_LOCK &gt;&nbsp;</td><td valign=bottom><a class="el" href="classACE__RB__Tree.html#a25">begin</a> (void)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Return forward iterator positioned at first node in tree.</em> <a href="#a25">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top><a class="el" href="classACE__RB__Tree__Iterator.html">ACE_RB_Tree_Iterator</a>&lt; EXT_ID,<br>
 INT_ID, COMPARE_KEYS, ACE_LOCK &gt;&nbsp;</td><td valign=bottom><a class="el" href="classACE__RB__Tree.html#a26">end</a> (void)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Return forward iterator positioned at last node in tree.</em> <a href="#a26">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top><a class="el" href="classACE__RB__Tree__Reverse__Iterator.html">ACE_RB_Tree_Reverse_Iterator</a>&lt;<br>
 EXT_ID, INT_ID, COMPARE_KEYS,<br>
 ACE_LOCK &gt;&nbsp;</td><td valign=bottom><a class="el" href="classACE__RB__Tree.html#a27">rbegin</a> (void)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Return reverse iterator positioned at last node in tree.</em> <a href="#a27">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top><a class="el" href="classACE__RB__Tree__Reverse__Iterator.html">ACE_RB_Tree_Reverse_Iterator</a>&lt;<br>
 EXT_ID, INT_ID, COMPARE_KEYS,<br>
 ACE_LOCK &gt;&nbsp;</td><td valign=bottom><a class="el" href="classACE__RB__Tree.html#a28">rend</a> (void)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Return reverse iterator positioned at first node in tree.</em> <a href="#a28">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>int&nbsp;</td><td valign=bottom><a class="el" href="classACE__RB__Tree.html#a29">test_invariant</a> (void)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Recursively tests the invariant red-black properties at each node of the tree. Returns 0 if invariant holds, else -1. This method is computationally expensive, and should only be called for testing purposes, and not in code that depends on the algorithmic complexity bounds provided by the other methods.</em> <a href="#a29">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>INT_ID *&nbsp;</td><td valign=bottom><a class="el" href="classACE__RB__Tree.html#a30">find</a> (const EXT_ID &amp;k)</td></tr>
<tr><td nowrap align=right valign=top>INT_ID *&nbsp;</td><td valign=bottom><a class="el" href="classACE__RB__Tree.html#a31">insert</a> (const EXT_ID &amp;k, const INT_ID &amp;t)</td></tr>
<tr><td nowrap align=right valign=top>int&nbsp;</td><td valign=bottom><a class="el" href="classACE__RB__Tree.html#a32">remove</a> (const EXT_ID &amp;k)</td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classACE__RB__Tree.html#a33">clear</a> (void)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em><dl compact><dt><b>
Deprecated: </b><dd>
Destroys all nodes and sets the root pointer null.</dl></em> <a href="#a33">More...</a><em></em></font><br><br></td></tr>
<tr><td colspan=2><br><h2>Protected Methods</h2></td></tr>
<tr><td nowrap align=right valign=top>int&nbsp;</td><td valign=bottom><a class="el" href="classACE__RB__Tree.html#b0">test_invariant_recurse</a> (<a class="el" href="classACE__RB__Tree__Node.html">ACE_RB_Tree_Node</a>&lt; EXT_ID, INT_ID &gt; *x, int &amp;expected_black_height, int measured_black_height)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Recursively tests the invariant red-black properties at each node of the tree. Returns 0 if invariant holds, else -1.</em> <a href="#b0">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classACE__RB__Tree.html#b1">RB_rotate_right</a> (<a class="el" href="classACE__RB__Tree__Node.html">ACE_RB_Tree_Node</a>&lt; EXT_ID, INT_ID &gt; *x)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Method for right rotation of the tree about a given node.</em> <a href="#b1">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classACE__RB__Tree.html#b2">RB_rotate_left</a> (<a class="el" href="classACE__RB__Tree__Node.html">ACE_RB_Tree_Node</a>&lt; EXT_ID, INT_ID &gt; *x)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Method for left rotation of the tree about a given node.</em> <a href="#b2">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classACE__RB__Tree.html#b3">RB_delete_fixup</a> (<a class="el" href="classACE__RB__Tree__Node.html">ACE_RB_Tree_Node</a>&lt; EXT_ID, INT_ID &gt; *x, <a class="el" href="classACE__RB__Tree__Node.html">ACE_RB_Tree_Node</a>&lt; EXT_ID, INT_ID &gt; *parent)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Method for restoring Red-Black properties after deletion.</em> <a href="#b3">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top><a class="el" href="classACE__RB__Tree__Node.html">ACE_RB_Tree_Node</a>&lt; EXT_ID,<br>
 INT_ID &gt; *&nbsp;</td><td valign=bottom><a class="el" href="classACE__RB__Tree.html#b4">RB_tree_successor</a> (<a class="el" href="classACE__RB__Tree__Node.html">ACE_RB_Tree_Node</a>&lt; EXT_ID, INT_ID &gt; *x) const</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Method to find the successor node of the given node in the tree.</em> <a href="#b4">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top><a class="el" href="classACE__RB__Tree__Node.html">ACE_RB_Tree_Node</a>&lt; EXT_ID,<br>
 INT_ID &gt; *&nbsp;</td><td valign=bottom><a class="el" href="classACE__RB__Tree.html#b5">RB_tree_predecessor</a> (<a class="el" href="classACE__RB__Tree__Node.html">ACE_RB_Tree_Node</a>&lt; EXT_ID, INT_ID &gt; *x) const</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Method to find the predecessor node of the given node in the tree.</em> <a href="#b5">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top><a class="el" href="classACE__RB__Tree__Node.html">ACE_RB_Tree_Node</a>&lt; EXT_ID,<br>
 INT_ID &gt; *&nbsp;</td><td valign=bottom><a class="el" href="classACE__RB__Tree.html#b6">RB_tree_minimum</a> (<a class="el" href="classACE__RB__Tree__Node.html">ACE_RB_Tree_Node</a>&lt; EXT_ID, INT_ID &gt; *x) const</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Method to find the minimum node of the subtree rooted at the given node.</em> <a href="#b6">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top><a class="el" href="classACE__RB__Tree__Node.html">ACE_RB_Tree_Node</a>&lt; EXT_ID,<br>
 INT_ID &gt; *&nbsp;</td><td valign=bottom><a class="el" href="classACE__RB__Tree.html#b7">RB_tree_maximum</a> (<a class="el" href="classACE__RB__Tree__Node.html">ACE_RB_Tree_Node</a>&lt; EXT_ID, INT_ID &gt; *x) const</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Method to find the maximum node of the subtree rooted at the given node.</em> <a href="#b7">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top><a class="el" href="classACE__RB__Tree__Node.html">ACE_RB_Tree_Node</a>&lt; EXT_ID,<br>
 INT_ID &gt; *&nbsp;</td><td valign=bottom><a class="el" href="classACE__RB__Tree.html#b8">find_node</a> (const EXT_ID &amp;k, <a class="el" href="classACE__RB__Tree__Base.html#s3">ACE_RB_Tree_Base::RB_SearchResult</a> &amp;result)</td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classACE__RB__Tree.html#b9">RB_rebalance</a> (<a class="el" href="classACE__RB__Tree__Node.html">ACE_RB_Tree_Node</a>&lt; EXT_ID, INT_ID &gt; *x)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Rebalance the tree after insertion of a node.</em> <a href="#b9">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>int&nbsp;</td><td valign=bottom><a class="el" href="classACE__RB__Tree.html#b10">close_i</a> (void)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Close down an RB_Tree. this method should only be called with locks already held.</em> <a href="#b10">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>int&nbsp;</td><td valign=bottom><a class="el" href="classACE__RB__Tree.html#b11">find_i</a> (const EXT_ID &amp;ext_id, <a class="el" href="classACE__RB__Tree__Node.html">ACE_RB_Tree_Node</a>&lt; EXT_ID, INT_ID &gt; *&amp;entry, int find_exact=1)</td></tr>
<tr><td nowrap align=right valign=top>INT_ID *&nbsp;</td><td valign=bottom><a class="el" href="classACE__RB__Tree.html#b12">insert_i</a> (const EXT_ID &amp;k, const INT_ID &amp;t)</td></tr>
<tr><td nowrap align=right valign=top>int&nbsp;</td><td valign=bottom><a class="el" href="classACE__RB__Tree.html#b13">insert_i</a> (const EXT_ID &amp;k, const INT_ID &amp;t, <a class="el" href="classACE__RB__Tree__Node.html">ACE_RB_Tree_Node</a>&lt; EXT_ID, INT_ID &gt; *&amp;entry)</td></tr>
<tr><td nowrap align=right valign=top>int&nbsp;</td><td valign=bottom><a class="el" href="classACE__RB__Tree.html#b14">remove_i</a> (const EXT_ID &amp;k, INT_ID &amp;i)</td></tr>
<tr><td nowrap align=right valign=top>int&nbsp;</td><td valign=bottom><a class="el" href="classACE__RB__Tree.html#b15">remove_i</a> (<a class="el" href="classACE__RB__Tree__Node.html">ACE_RB_Tree_Node</a>&lt; EXT_ID, INT_ID &gt; *z)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Removes the item associated with the given key from the tree and destroys it.</em> <a href="#b15">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classACE__RB__Tree.html#b16">dump_i</a> (<a class="el" href="classACE__RB__Tree__Node.html">ACE_RB_Tree_Node</a>&lt; EXT_ID, INT_ID &gt; *node) const</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Recursive function to dump the state of an object.</em> <a href="#b16">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classACE__RB__Tree.html#b17">dump_node_i</a> (<a class="el" href="classACE__RB__Tree__Node.html">ACE_RB_Tree_Node</a>&lt; EXT_ID, INT_ID &gt; &amp;node) const</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Function to dump node contents. Does nothing in its basic form, but template specialization can be used to provide definitions for various EXT_ID and INT_ID types.</em> <a href="#b17">More...</a><em></em></font><br><br></td></tr>
<tr><td colspan=2><br><h2>Private Attributes</h2></td></tr>
<tr><td nowrap align=right valign=top><a class="el" href="classACE__Allocator.html">ACE_Allocator</a> *&nbsp;</td><td valign=bottom><a class="el" href="classACE__RB__Tree.html#o0">allocator_</a></td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Pointer to a memory allocator.</em> <a href="#o0">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>ACE_LOCK&nbsp;</td><td valign=bottom><a class="el" href="classACE__RB__Tree.html#o1">lock_</a></td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Synchronization variable for the MT_SAFE &lt;ACE_RB_Tree&gt;.</em> <a href="#o1">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top><a class="el" href="classACE__RB__Tree__Node.html">ACE_RB_Tree_Node</a>&lt; EXT_ID,<br>
 INT_ID &gt; *&nbsp;</td><td valign=bottom><a class="el" href="classACE__RB__Tree.html#o2">root_</a></td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>The root of the tree.</em> <a href="#o2">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>COMPARE_KEYS&nbsp;</td><td valign=bottom><a class="el" href="classACE__RB__Tree.html#o3">compare_keys_</a></td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Comparison functor for comparing nodes in the tree.</em> <a href="#o3">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>size_t&nbsp;</td><td valign=bottom><a class="el" href="classACE__RB__Tree.html#o4">current_size_</a></td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>The current number of nodes in the tree.</em> <a href="#o4">More...</a><em></em></font><br><br></td></tr>
<tr><td colspan=2><br><h2>Friends</h2></td></tr>
<tr><td nowrap align=right valign=top>class&nbsp;</td><td valign=bottom><a class="el" href="classACE__RB__Tree.html#l0">ACE_RB_Tree_Iterator_Base&lt; EXT_ID, INT_ID, COMPARE_KEYS, ACE_LOCK &gt;</a></td></tr>
<tr><td nowrap align=right valign=top>class&nbsp;</td><td valign=bottom><a class="el" href="classACE__RB__Tree.html#l1">ACE_RB_Tree_Iterator&lt; EXT_ID, INT_ID, COMPARE_KEYS, ACE_LOCK &gt;</a></td></tr>
<tr><td nowrap align=right valign=top>class&nbsp;</td><td valign=bottom><a class="el" href="classACE__RB__Tree.html#l2">ACE_RB_Tree_Reverse_Iterator&lt; EXT_ID, INT_ID, COMPARE_KEYS, ACE_LOCK &gt;</a></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
<h3>template&lt;class EXT_ID, class INT_ID, class COMPARE_KEYS, class ACE_LOCK&gt;<br>
 class ACE_RB_Tree&lt; EXT_ID, INT_ID, COMPARE_KEYS, ACE_LOCK &gt;</h3>

Implements a Red-Black Tree ADT, according to T. H. Corman, C. E. Leiserson, and R. L. Rivest, "Introduction to Algorithms" 1990, MIT, chapter 14.
<p>

<p>
 A number of Changes have been made to this class template in order to conform to the <a class="el" href="classACE__Hash__Map__Manager__Ex.html">ACE_Hash_Map_Manager_Ex</a> interface. All previously supported public methods are still part of this class. However, these are marked as DEPRECATED and will be removed from this class in a future version of <a class="el" href="classACE.html">ACE</a>. Please migrate your code to the appropriate public methods indicated in the method deprecation comments. This class uses an &lt;<a class="el" href="classACE__Allocator.html">ACE_Allocator</a>&gt; to allocate memory. The user can make this a persistent class by providing an &lt;<a class="el" href="classACE__Allocator.html">ACE_Allocator</a>&gt; with a persistable memory pool.
<p>
<b> Requirements and Performance Characteristics</b><ul>
<li>Internal Structure: Binary tree<li>Duplicates allowed? No<li>Random access allowed? No<li>Search speed: Log(n)<li>Insert/replace speed: Log(n)<li>Iterator still valid after change to container? Yes, except if the iterated-over element is removed.<li>Frees memory for removed elements? Yes<li>Items inserted by: Value<li>Requirements for contained type<ol>
<li>Default constructor<li>Copy constructor<li>operator=<li>operator==<li>operator&lt; </ol>
</ul>

<p>
<hr><h2>Member Typedef Documentation</h2>
<a name="s2" doxytag="ACE_RB_Tree::ENTRY"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class EXT_ID, class INT_ID, class COMPARE_KEYS, class ACE_LOCK&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> typedef <a class="el" href="classACE__RB__Tree__Node.html">ACE_RB_Tree_Node</a>&lt;EXT_ID, INT_ID&gt; ACE_RB_Tree::ENTRY
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a name="s5" doxytag="ACE_RB_Tree::iterator"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class EXT_ID, class INT_ID, class COMPARE_KEYS, class ACE_LOCK&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> typedef <a class="el" href="classACE__RB__Tree__Iterator.html">ACE_RB_Tree_Iterator</a>&lt;EXT_ID, INT_ID, COMPARE_KEYS, ACE_LOCK&gt; ACE_RB_Tree::iterator
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a name="s3" doxytag="ACE_RB_Tree::ITERATOR"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class EXT_ID, class INT_ID, class COMPARE_KEYS, class ACE_LOCK&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> typedef <a class="el" href="classACE__RB__Tree__Iterator.html">ACE_RB_Tree_Iterator</a>&lt;EXT_ID, INT_ID, COMPARE_KEYS, ACE_LOCK&gt; ACE_RB_Tree::ITERATOR
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a name="s0" doxytag="ACE_RB_Tree::KEY"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class EXT_ID, class INT_ID, class COMPARE_KEYS, class ACE_LOCK&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> typedef EXT_ID ACE_RB_Tree::KEY
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a name="s6" doxytag="ACE_RB_Tree::reverse_iterator"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class EXT_ID, class INT_ID, class COMPARE_KEYS, class ACE_LOCK&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> typedef <a class="el" href="classACE__RB__Tree__Reverse__Iterator.html">ACE_RB_Tree_Reverse_Iterator</a>&lt;EXT_ID, INT_ID, COMPARE_KEYS, ACE_LOCK&gt; ACE_RB_Tree::reverse_iterator
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a name="s4" doxytag="ACE_RB_Tree::REVERSE_ITERATOR"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class EXT_ID, class INT_ID, class COMPARE_KEYS, class ACE_LOCK&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> typedef <a class="el" href="classACE__RB__Tree__Reverse__Iterator.html">ACE_RB_Tree_Reverse_Iterator</a>&lt;EXT_ID, INT_ID, COMPARE_KEYS, ACE_LOCK&gt; ACE_RB_Tree::REVERSE_ITERATOR
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a name="s1" doxytag="ACE_RB_Tree::VALUE"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class EXT_ID, class INT_ID, class COMPARE_KEYS, class ACE_LOCK&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> typedef INT_ID ACE_RB_Tree::VALUE
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a name="a0" doxytag="ACE_RB_Tree::ACE_RB_Tree"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class EXT_ID, class INT_ID, class COMPARE_KEYS, class ACE_LOCK&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> ACE_RB_Tree&lt; EXT_ID, INT_ID, COMPARE_KEYS, ACE_LOCK &gt;::ACE_RB_Tree </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classACE__Allocator.html">ACE_Allocator</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>alloc</em> = 0          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Constructor.
<p>
    </td>
  </tr>
</table>
<a name="a1" doxytag="ACE_RB_Tree::ACE_RB_Tree"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class EXT_ID, class INT_ID, class COMPARE_KEYS, class ACE_LOCK&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> ACE_RB_Tree&lt; EXT_ID, INT_ID, COMPARE_KEYS, ACE_LOCK &gt;::ACE_RB_Tree </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const ACE_RB_Tree&lt; EXT_ID, INT_ID, COMPARE_KEYS, ACE_LOCK &gt; &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>rbt</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Copy constructor.
<p>
    </td>
  </tr>
</table>
<a name="a4" doxytag="ACE_RB_Tree::~ACE_RB_Tree"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class EXT_ID, class INT_ID, class COMPARE_KEYS, class ACE_LOCK&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> ACE_RB_Tree&lt; EXT_ID, INT_ID, COMPARE_KEYS, ACE_LOCK &gt;::~ACE_RB_Tree </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Destructor.
<p>
    </td>
  </tr>
</table>
<hr><h2>Member Function Documentation</h2>
<a name="a25" doxytag="ACE_RB_Tree::begin"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class EXT_ID, class INT_ID, class COMPARE_KEYS, class ACE_LOCK&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> ACE_INLINE <a class="el" href="classACE__RB__Tree__Iterator.html">ACE_RB_Tree_Iterator</a>&lt; EXT_ID, INT_ID, COMPARE_KEYS, ACE_LOCK &gt; ACE_RB_Tree&lt; EXT_ID, INT_ID, COMPARE_KEYS, ACE_LOCK &gt;::begin </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Return forward iterator positioned at first node in tree.
<p>
    </td>
  </tr>
</table>
<a name="a6" doxytag="ACE_RB_Tree::bind"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class EXT_ID, class INT_ID, class COMPARE_KEYS, class ACE_LOCK&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> ACE_INLINE int ACE_RB_Tree&lt; EXT_ID, INT_ID, COMPARE_KEYS, ACE_LOCK &gt;::bind </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const EXT_ID &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>ext_id</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const INT_ID &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>int_id</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="classACE__RB__Tree__Node.html">ACE_RB_Tree_Node</a>&lt; EXT_ID, INT_ID &gt; *&amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>entry</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Same as a normal bind, except the tree entry is also passed back to the caller. The entry in this case will either be the newly created entry, or the existing one.     </td>
  </tr>
</table>
<a name="a5" doxytag="ACE_RB_Tree::bind"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class EXT_ID, class INT_ID, class COMPARE_KEYS, class ACE_LOCK&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> ACE_INLINE int ACE_RB_Tree&lt; EXT_ID, INT_ID, COMPARE_KEYS, ACE_LOCK &gt;::bind </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const EXT_ID &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>ext_id</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const INT_ID &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>int_id</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Associate &lt;ext_id&gt; with &lt;int_id&gt;. If &lt;ext_id&gt; is already in the tree then the &lt;<a class="el" href="classACE__RB__Tree__Node.html">ACE_RB_Tree_Node</a>&gt; is not changed. Returns 0 if a new entry is bound successfully, returns 1 if an attempt is made to bind an existing entry, and returns -1 if failures occur.     </td>
  </tr>
</table>
<a name="a33" doxytag="ACE_RB_Tree::clear"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class EXT_ID, class INT_ID, class COMPARE_KEYS, class ACE_LOCK&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> ACE_INLINE void ACE_RB_Tree&lt; EXT_ID, INT_ID, COMPARE_KEYS, ACE_LOCK &gt;::clear </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<dl compact><dt><b>
Deprecated: </b><dd>
Destroys all nodes and sets the root pointer null.</dl>
<p>
    </td>
  </tr>
</table>
<a name="a3" doxytag="ACE_RB_Tree::close"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class EXT_ID, class INT_ID, class COMPARE_KEYS, class ACE_LOCK&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> ACE_INLINE int ACE_RB_Tree&lt; EXT_ID, INT_ID, COMPARE_KEYS, ACE_LOCK &gt;::close </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Close down an RB_Tree and release dynamically allocated resources.
<p>
    </td>
  </tr>
</table>
<a name="b10" doxytag="ACE_RB_Tree::close_i"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class EXT_ID, class INT_ID, class COMPARE_KEYS, class ACE_LOCK&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> int ACE_RB_Tree&lt; EXT_ID, INT_ID, COMPARE_KEYS, ACE_LOCK &gt;::close_i </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [protected]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Close down an RB_Tree. this method should only be called with locks already held.
<p>
    </td>
  </tr>
</table>
<a name="a20" doxytag="ACE_RB_Tree::current_size"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class EXT_ID, class INT_ID, class COMPARE_KEYS, class ACE_LOCK&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> ACE_INLINE size_t ACE_RB_Tree&lt; EXT_ID, INT_ID, COMPARE_KEYS, ACE_LOCK &gt;::current_size </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap> const</td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns the current number of nodes in the tree.
<p>
    </td>
  </tr>
</table>
<a name="a24" doxytag="ACE_RB_Tree::dump"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class EXT_ID, class INT_ID, class COMPARE_KEYS, class ACE_LOCK&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> ACE_INLINE void ACE_RB_Tree&lt; EXT_ID, INT_ID, COMPARE_KEYS, ACE_LOCK &gt;::dump </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap> const</td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Dump the state of an object.
<p>
    </td>
  </tr>
</table>
<a name="b16" doxytag="ACE_RB_Tree::dump_i"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class EXT_ID, class INT_ID, class COMPARE_KEYS, class ACE_LOCK&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> void ACE_RB_Tree&lt; EXT_ID, INT_ID, COMPARE_KEYS, ACE_LOCK &gt;::dump_i </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classACE__RB__Tree__Node.html">ACE_RB_Tree_Node</a>&lt; EXT_ID, INT_ID &gt; *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>node</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap> const<code> [protected]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Recursive function to dump the state of an object.
<p>
    </td>
  </tr>
</table>
<a name="b17" doxytag="ACE_RB_Tree::dump_node_i"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class EXT_ID, class INT_ID, class COMPARE_KEYS, class ACE_LOCK&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> void ACE_RB_Tree&lt; EXT_ID, INT_ID, COMPARE_KEYS, ACE_LOCK &gt;::dump_node_i </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classACE__RB__Tree__Node.html">ACE_RB_Tree_Node</a>&lt; EXT_ID, INT_ID &gt; &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>node</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap> const<code> [protected]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Function to dump node contents. Does nothing in its basic form, but template specialization can be used to provide definitions for various EXT_ID and INT_ID types.
<p>
    </td>
  </tr>
</table>
<a name="a26" doxytag="ACE_RB_Tree::end"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class EXT_ID, class INT_ID, class COMPARE_KEYS, class ACE_LOCK&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> ACE_INLINE <a class="el" href="classACE__RB__Tree__Iterator.html">ACE_RB_Tree_Iterator</a>&lt; EXT_ID, INT_ID, COMPARE_KEYS, ACE_LOCK &gt; ACE_RB_Tree&lt; EXT_ID, INT_ID, COMPARE_KEYS, ACE_LOCK &gt;::end </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Return forward iterator positioned at last node in tree.
<p>
    </td>
  </tr>
</table>
<a name="a30" doxytag="ACE_RB_Tree::find"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class EXT_ID, class INT_ID, class COMPARE_KEYS, class ACE_LOCK&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> ACE_INLINE INT_ID * ACE_RB_Tree&lt; EXT_ID, INT_ID, COMPARE_KEYS, ACE_LOCK &gt;::find </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const EXT_ID &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>k</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns a pointer to the item corresponding to the given key, or 0 if it cannot find the key in the tree.
<p>
<dl compact><dt><b>
Deprecated: </b><dd>
signature will change to become int find (const EXT_ID &amp;ext_id); which will return 0 if the &lt;ext_id&gt; is in the tree, otherwise -1. </dl>    </td>
  </tr>
</table>
<a name="a16" doxytag="ACE_RB_Tree::find"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class EXT_ID, class INT_ID, class COMPARE_KEYS, class ACE_LOCK&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> ACE_INLINE int ACE_RB_Tree&lt; EXT_ID, INT_ID, COMPARE_KEYS, ACE_LOCK &gt;::find </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const EXT_ID &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>ext_id</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="classACE__RB__Tree__Node.html">ACE_RB_Tree_Node</a>&lt; EXT_ID, INT_ID &gt; *&amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>entry</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Locate &lt;ext_id&gt; and pass out parameter via &lt;entry&gt;. If found, return 0, returns -1 if not found.
<p>
    </td>
  </tr>
</table>
<a name="a15" doxytag="ACE_RB_Tree::find"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class EXT_ID, class INT_ID, class COMPARE_KEYS, class ACE_LOCK&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> ACE_INLINE int ACE_RB_Tree&lt; EXT_ID, INT_ID, COMPARE_KEYS, ACE_LOCK &gt;::find </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const EXT_ID &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>ext_id</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>INT_ID &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>int_id</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Locate &lt;ext_id&gt; and pass out parameter via &lt;int_id&gt;. If found, return 0, returns -1 if not found.
<p>
    </td>
  </tr>
</table>
<a name="b11" doxytag="ACE_RB_Tree::find_i"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class EXT_ID, class INT_ID, class COMPARE_KEYS, class ACE_LOCK&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> int ACE_RB_Tree&lt; EXT_ID, INT_ID, COMPARE_KEYS, ACE_LOCK &gt;::find_i </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const EXT_ID &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>k</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="classACE__RB__Tree__Node.html">ACE_RB_Tree_Node</a>&lt; EXT_ID, INT_ID &gt; *&amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>entry</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>find_exact</em> = 1</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [protected]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Retrieves a pointer to the item corresponding to the given key. If find_exact==1, find the exact match node. Otherwise just find a match node returns 0 for success, or -1 if it cannot find the key in the tree.     </td>
  </tr>
</table>
<a name="b8" doxytag="ACE_RB_Tree::find_node"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class EXT_ID, class INT_ID, class COMPARE_KEYS, class ACE_LOCK&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="classACE__RB__Tree__Node.html">ACE_RB_Tree_Node</a>&lt; EXT_ID, INT_ID &gt; * ACE_RB_Tree&lt; EXT_ID, INT_ID, COMPARE_KEYS, ACE_LOCK &gt;::find_node </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const EXT_ID &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>k</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="classACE__RB__Tree__Base.html#s3">ACE_RB_Tree_Base::RB_SearchResult</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>result</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [protected]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns a pointer to a matching node if there is one, a pointer to the node under which to insert the item if the tree is not empty and there is no such match, or 0 if the tree is empty. It stores the result of the search in the result argument: LEFT if the node is to the left of the node to be inserted, RIGHT if the node is to the right of the node to be inserted, or EXACT if an exactly matching node already exists.     </td>
  </tr>
</table>
<a name="a31" doxytag="ACE_RB_Tree::insert"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class EXT_ID, class INT_ID, class COMPARE_KEYS, class ACE_LOCK&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> ACE_INLINE INT_ID * ACE_RB_Tree&lt; EXT_ID, INT_ID, COMPARE_KEYS, ACE_LOCK &gt;::insert </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const EXT_ID &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>k</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const INT_ID &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>t</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Inserts a *copy* of the key and the item into the tree: both the key type EXT_ID and the item type INT_ID must have well defined semantics for copy construction. The default implementation also requires that the key type support well defined &lt; semantics. This method returns a pointer to the inserted item copy, or 0 if an error occurred. NOTE: if an identical key already exists in the tree, no new item is created, and the returned pointer addresses the existing item associated with the existing key. <dl compact><dt><b>
Deprecated: </b><dd>
</dl>    </td>
  </tr>
</table>
<a name="b13" doxytag="ACE_RB_Tree::insert_i"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class EXT_ID, class INT_ID, class COMPARE_KEYS, class ACE_LOCK&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> int ACE_RB_Tree&lt; EXT_ID, INT_ID, COMPARE_KEYS, ACE_LOCK &gt;::insert_i </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const EXT_ID &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>k</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const INT_ID &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>t</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="classACE__RB__Tree__Node.html">ACE_RB_Tree_Node</a>&lt; EXT_ID, INT_ID &gt; *&amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>entry</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [protected]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Inserts a *copy* of the key and the item into the tree: both the key type EXT_ID and the item type INT_ID must have well defined semantics for copy construction. The default implementation also requires that the key type support well defined &lt; semantics. This method passes back a pointer to the inserted (or existing) node, and the search status. If the node already exists, the method returns 1. If the node does not exist, and a new one is successfully created, and the method returns 0. If there was an error, the method returns -1.     </td>
  </tr>
</table>
<a name="b12" doxytag="ACE_RB_Tree::insert_i"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class EXT_ID, class INT_ID, class COMPARE_KEYS, class ACE_LOCK&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> INT_ID * ACE_RB_Tree&lt; EXT_ID, INT_ID, COMPARE_KEYS, ACE_LOCK &gt;::insert_i </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const EXT_ID &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>k</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const INT_ID &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>t</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [protected]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Inserts a *copy* of the key and the item into the tree: both the key type EXT_ID and the item type INT_ID must have well defined semantics for copy construction. The default implementation also requires that the key type support well defined &lt; semantics. This method returns a pointer to the inserted item copy, or 0 if an error occurred. NOTE: if an identical key already exists in the tree, no new item is created, and the returned pointer addresses the existing item associated with the existing key.     </td>
  </tr>
</table>
<a name="a22" doxytag="ACE_RB_Tree::lessthan"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class EXT_ID, class INT_ID, class COMPARE_KEYS, class ACE_LOCK&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> int ACE_RB_Tree&lt; EXT_ID, INT_ID, COMPARE_KEYS, ACE_LOCK &gt;::lessthan </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const EXT_ID &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>k1</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const EXT_ID &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>k2</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Less than comparison function for keys, using comparison functor.
<p>
    </td>
  </tr>
</table>
<a name="a23" doxytag="ACE_RB_Tree::mutex"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class EXT_ID, class INT_ID, class COMPARE_KEYS, class ACE_LOCK&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> ACE_INLINE ACE_LOCK &amp; ACE_RB_Tree&lt; EXT_ID, INT_ID, COMPARE_KEYS, ACE_LOCK &gt;::mutex </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns a reference to the underlying &lt;ACE_LOCK&gt;. This makes it possible to acquire the lock explicitly, which can be useful in some cases if you instantiate the &lt;<a class="el" href="classACE__Atomic__Op.html">ACE_Atomic_Op</a>&gt; with an &lt;ACE_Recursive_Mutex&gt; or &lt;<a class="el" href="classACE__Process__Mutex.html">ACE_Process_Mutex</a>&gt;, or if you need to guard the state of an iterator. NOTE: the right name would be &lt;lock&gt;, but HP/C++ will choke on that!     </td>
  </tr>
</table>
<a name="a2" doxytag="ACE_RB_Tree::open"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class EXT_ID, class INT_ID, class COMPARE_KEYS, class ACE_LOCK&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> ACE_INLINE int ACE_RB_Tree&lt; EXT_ID, INT_ID, COMPARE_KEYS, ACE_LOCK &gt;::open </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classACE__Allocator.html">ACE_Allocator</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>alloc</em> = 0          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Initialize an RB Tree.
<p>
    </td>
  </tr>
</table>
<a name="a21" doxytag="ACE_RB_Tree::operator="></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class EXT_ID, class INT_ID, class COMPARE_KEYS, class ACE_LOCK&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> void ACE_RB_Tree&lt; EXT_ID, INT_ID, COMPARE_KEYS, ACE_LOCK &gt;::operator= </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const ACE_RB_Tree&lt; EXT_ID, INT_ID, COMPARE_KEYS, ACE_LOCK &gt; &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>rbt</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Assignment operator.
<p>
    </td>
  </tr>
</table>
<a name="b3" doxytag="ACE_RB_Tree::RB_delete_fixup"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class EXT_ID, class INT_ID, class COMPARE_KEYS, class ACE_LOCK&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> void ACE_RB_Tree&lt; EXT_ID, INT_ID, COMPARE_KEYS, ACE_LOCK &gt;::RB_delete_fixup </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classACE__RB__Tree__Node.html">ACE_RB_Tree_Node</a>&lt; EXT_ID, INT_ID &gt; *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>x</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="classACE__RB__Tree__Node.html">ACE_RB_Tree_Node</a>&lt; EXT_ID, INT_ID &gt; *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>parent</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [protected]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Method for restoring Red-Black properties after deletion.
<p>
    </td>
  </tr>
</table>
<a name="b9" doxytag="ACE_RB_Tree::RB_rebalance"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class EXT_ID, class INT_ID, class COMPARE_KEYS, class ACE_LOCK&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> void ACE_RB_Tree&lt; EXT_ID, INT_ID, COMPARE_KEYS, ACE_LOCK &gt;::RB_rebalance </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classACE__RB__Tree__Node.html">ACE_RB_Tree_Node</a>&lt; EXT_ID, INT_ID &gt; *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>x</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [protected]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Rebalance the tree after insertion of a node.
<p>
    </td>
  </tr>
</table>
<a name="b2" doxytag="ACE_RB_Tree::RB_rotate_left"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class EXT_ID, class INT_ID, class COMPARE_KEYS, class ACE_LOCK&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> void ACE_RB_Tree&lt; EXT_ID, INT_ID, COMPARE_KEYS, ACE_LOCK &gt;::RB_rotate_left </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classACE__RB__Tree__Node.html">ACE_RB_Tree_Node</a>&lt; EXT_ID, INT_ID &gt; *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>x</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [protected]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Method for left rotation of the tree about a given node.
<p>
    </td>
  </tr>
</table>
<a name="b1" doxytag="ACE_RB_Tree::RB_rotate_right"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class EXT_ID, class INT_ID, class COMPARE_KEYS, class ACE_LOCK&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> void ACE_RB_Tree&lt; EXT_ID, INT_ID, COMPARE_KEYS, ACE_LOCK &gt;::RB_rotate_right </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classACE__RB__Tree__Node.html">ACE_RB_Tree_Node</a>&lt; EXT_ID, INT_ID &gt; *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>x</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [protected]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Method for right rotation of the tree about a given node.
<p>
    </td>
  </tr>
</table>
<a name="b7" doxytag="ACE_RB_Tree::RB_tree_maximum"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class EXT_ID, class INT_ID, class COMPARE_KEYS, class ACE_LOCK&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="classACE__RB__Tree__Node.html">ACE_RB_Tree_Node</a>&lt; EXT_ID, INT_ID &gt; * ACE_RB_Tree&lt; EXT_ID, INT_ID, COMPARE_KEYS, ACE_LOCK &gt;::RB_tree_maximum </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classACE__RB__Tree__Node.html">ACE_RB_Tree_Node</a>&lt; EXT_ID, INT_ID &gt; *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>x</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap> const<code> [protected]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Method to find the maximum node of the subtree rooted at the given node.
<p>
    </td>
  </tr>
</table>
<a name="b6" doxytag="ACE_RB_Tree::RB_tree_minimum"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class EXT_ID, class INT_ID, class COMPARE_KEYS, class ACE_LOCK&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="classACE__RB__Tree__Node.html">ACE_RB_Tree_Node</a>&lt; EXT_ID, INT_ID &gt; * ACE_RB_Tree&lt; EXT_ID, INT_ID, COMPARE_KEYS, ACE_LOCK &gt;::RB_tree_minimum </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classACE__RB__Tree__Node.html">ACE_RB_Tree_Node</a>&lt; EXT_ID, INT_ID &gt; *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>x</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap> const<code> [protected]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Method to find the minimum node of the subtree rooted at the given node.
<p>
    </td>
  </tr>
</table>
<a name="b5" doxytag="ACE_RB_Tree::RB_tree_predecessor"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class EXT_ID, class INT_ID, class COMPARE_KEYS, class ACE_LOCK&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="classACE__RB__Tree__Node.html">ACE_RB_Tree_Node</a>&lt; EXT_ID, INT_ID &gt; * ACE_RB_Tree&lt; EXT_ID, INT_ID, COMPARE_KEYS, ACE_LOCK &gt;::RB_tree_predecessor </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classACE__RB__Tree__Node.html">ACE_RB_Tree_Node</a>&lt; EXT_ID, INT_ID &gt; *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>x</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap> const<code> [protected]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Method to find the predecessor node of the given node in the tree.
<p>
    </td>
  </tr>
</table>
<a name="b4" doxytag="ACE_RB_Tree::RB_tree_successor"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class EXT_ID, class INT_ID, class COMPARE_KEYS, class ACE_LOCK&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="classACE__RB__Tree__Node.html">ACE_RB_Tree_Node</a>&lt; EXT_ID, INT_ID &gt; * ACE_RB_Tree&lt; EXT_ID, INT_ID, COMPARE_KEYS, ACE_LOCK &gt;::RB_tree_successor </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classACE__RB__Tree__Node.html">ACE_RB_Tree_Node</a>&lt; EXT_ID, INT_ID &gt; *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>x</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap> const<code> [protected]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Method to find the successor node of the given node in the tree.
<p>
    </td>
  </tr>
</table>
<a name="a27" doxytag="ACE_RB_Tree::rbegin"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class EXT_ID, class INT_ID, class COMPARE_KEYS, class ACE_LOCK&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> ACE_INLINE <a class="el" href="classACE__RB__Tree__Reverse__Iterator.html">ACE_RB_Tree_Reverse_Iterator</a>&lt; EXT_ID, INT_ID, COMPARE_KEYS, ACE_LOCK &gt; ACE_RB_Tree&lt; EXT_ID, INT_ID, COMPARE_KEYS, ACE_LOCK &gt;::rbegin </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Return reverse iterator positioned at last node in tree.
<p>
    </td>
  </tr>
</table>
<a name="a14" doxytag="ACE_RB_Tree::rebind"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class EXT_ID, class INT_ID, class COMPARE_KEYS, class ACE_LOCK&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> ACE_INLINE int ACE_RB_Tree&lt; EXT_ID, INT_ID, COMPARE_KEYS, ACE_LOCK &gt;::rebind </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const EXT_ID &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>ext_id</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const INT_ID &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>int_id</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>EXT_ID &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>old_ext_id</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>INT_ID &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>old_int_id</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="classACE__RB__Tree__Node.html">ACE_RB_Tree_Node</a>&lt; EXT_ID, INT_ID &gt; *&amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>entry</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Same as a normal rebind, except the tree entry is also passed back to the caller. The entry in this case will either be the newly created entry, or the existing one.     </td>
  </tr>
</table>
<a name="a13" doxytag="ACE_RB_Tree::rebind"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class EXT_ID, class INT_ID, class COMPARE_KEYS, class ACE_LOCK&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> ACE_INLINE int ACE_RB_Tree&lt; EXT_ID, INT_ID, COMPARE_KEYS, ACE_LOCK &gt;::rebind </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const EXT_ID &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>ext_id</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const INT_ID &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>int_id</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>EXT_ID &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>old_ext_id</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>INT_ID &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>old_int_id</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Associate &lt;ext_id&gt; with &lt;int_id&gt;. If &lt;ext_id&gt; is not in the tree then behaves just like &lt;bind&gt;. Otherwise, store the old values of &lt;ext_id&gt; and &lt;int_id&gt; into the "out" parameters and rebind the new parameters. This is very useful if you need to have an atomic way of updating &lt;ACE_RB_Tree_Nodes&gt; and you also need full control over memory allocation. Returns 0 if a new entry is bound successfully, returns 1 if an existing entry was rebound, and returns -1 if failures occur.     </td>
  </tr>
</table>
<a name="a12" doxytag="ACE_RB_Tree::rebind"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class EXT_ID, class INT_ID, class COMPARE_KEYS, class ACE_LOCK&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> ACE_INLINE int ACE_RB_Tree&lt; EXT_ID, INT_ID, COMPARE_KEYS, ACE_LOCK &gt;::rebind </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const EXT_ID &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>ext_id</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const INT_ID &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>int_id</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>INT_ID &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>old_int_id</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="classACE__RB__Tree__Node.html">ACE_RB_Tree_Node</a>&lt; EXT_ID, INT_ID &gt; *&amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>entry</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Same as a normal rebind, except the tree entry is also passed back to the caller. The entry in this case will either be the newly created entry, or the existing one.     </td>
  </tr>
</table>
<a name="a11" doxytag="ACE_RB_Tree::rebind"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class EXT_ID, class INT_ID, class COMPARE_KEYS, class ACE_LOCK&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> ACE_INLINE int ACE_RB_Tree&lt; EXT_ID, INT_ID, COMPARE_KEYS, ACE_LOCK &gt;::rebind </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const EXT_ID &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>ext_id</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const INT_ID &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>int_id</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>INT_ID &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>old_int_id</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Associate &lt;ext_id&gt; with &lt;int_id&gt;. If &lt;ext_id&gt; is not in the tree then behaves just like &lt;bind&gt;. Otherwise, store the old value of &lt;int_id&gt; into the "out" parameter and rebind the new parameters. Returns 0 if a new entry is bound successfully, returns 1 if an existing entry was rebound, and returns -1 if failures occur.     </td>
  </tr>
</table>
<a name="a10" doxytag="ACE_RB_Tree::rebind"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class EXT_ID, class INT_ID, class COMPARE_KEYS, class ACE_LOCK&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> ACE_INLINE int ACE_RB_Tree&lt; EXT_ID, INT_ID, COMPARE_KEYS, ACE_LOCK &gt;::rebind </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const EXT_ID &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>ext_id</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const INT_ID &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>int_id</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="classACE__RB__Tree__Node.html">ACE_RB_Tree_Node</a>&lt; EXT_ID, INT_ID &gt; *&amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>entry</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Same as a normal rebind, except the tree entry is also passed back to the caller. The entry in this case will either be the newly created entry, or the existing one.     </td>
  </tr>
</table>
<a name="a9" doxytag="ACE_RB_Tree::rebind"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class EXT_ID, class INT_ID, class COMPARE_KEYS, class ACE_LOCK&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> ACE_INLINE int ACE_RB_Tree&lt; EXT_ID, INT_ID, COMPARE_KEYS, ACE_LOCK &gt;::rebind </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const EXT_ID &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>ext_id</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const INT_ID &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>int_id</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Reassociate &lt;ext_id&gt; with &lt;int_id&gt;. If &lt;ext_id&gt; is not in the tree then behaves just like &lt;bind&gt;. Returns 0 if a new entry is bound successfully, returns 1 if an existing entry was rebound, and returns -1 if failures occur.     </td>
  </tr>
</table>
<a name="a32" doxytag="ACE_RB_Tree::remove"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class EXT_ID, class INT_ID, class COMPARE_KEYS, class ACE_LOCK&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> ACE_INLINE int ACE_RB_Tree&lt; EXT_ID, INT_ID, COMPARE_KEYS, ACE_LOCK &gt;::remove </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const EXT_ID &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>k</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Removes the item associated with the given key from the tree and destroys it. Returns 1 if it found the item and successfully destroyed it, 0 if it did not find the item, or -1 if an error occurred. <dl compact><dt><b>
Deprecated: </b><dd>
</dl>    </td>
  </tr>
</table>
<a name="b15" doxytag="ACE_RB_Tree::remove_i"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class EXT_ID, class INT_ID, class COMPARE_KEYS, class ACE_LOCK&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> int ACE_RB_Tree&lt; EXT_ID, INT_ID, COMPARE_KEYS, ACE_LOCK &gt;::remove_i </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classACE__RB__Tree__Node.html">ACE_RB_Tree_Node</a>&lt; EXT_ID, INT_ID &gt; *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>z</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [protected]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Removes the item associated with the given key from the tree and destroys it.
<p>
    </td>
  </tr>
</table>
<a name="b14" doxytag="ACE_RB_Tree::remove_i"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class EXT_ID, class INT_ID, class COMPARE_KEYS, class ACE_LOCK&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> int ACE_RB_Tree&lt; EXT_ID, INT_ID, COMPARE_KEYS, ACE_LOCK &gt;::remove_i </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const EXT_ID &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>k</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>INT_ID &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>i</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [protected]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Removes the item associated with the given key from the tree and destroys it. Returns 1 if it found the item and successfully destroyed it, 0 if it did not find the item, or -1 if an error occurred. Returns the stored internal id in the second argument.     </td>
  </tr>
</table>
<a name="a28" doxytag="ACE_RB_Tree::rend"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class EXT_ID, class INT_ID, class COMPARE_KEYS, class ACE_LOCK&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> ACE_INLINE <a class="el" href="classACE__RB__Tree__Reverse__Iterator.html">ACE_RB_Tree_Reverse_Iterator</a>&lt; EXT_ID, INT_ID, COMPARE_KEYS, ACE_LOCK &gt; ACE_RB_Tree&lt; EXT_ID, INT_ID, COMPARE_KEYS, ACE_LOCK &gt;::rend </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Return reverse iterator positioned at first node in tree.
<p>
    </td>
  </tr>
</table>
<a name="a29" doxytag="ACE_RB_Tree::test_invariant"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class EXT_ID, class INT_ID, class COMPARE_KEYS, class ACE_LOCK&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> int ACE_RB_Tree&lt; EXT_ID, INT_ID, COMPARE_KEYS, ACE_LOCK &gt;::test_invariant </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Recursively tests the invariant red-black properties at each node of the tree. Returns 0 if invariant holds, else -1. This method is computationally expensive, and should only be called for testing purposes, and not in code that depends on the algorithmic complexity bounds provided by the other methods.
<p>
    </td>
  </tr>
</table>
<a name="b0" doxytag="ACE_RB_Tree::test_invariant_recurse"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class EXT_ID, class INT_ID, class COMPARE_KEYS, class ACE_LOCK&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> int ACE_RB_Tree&lt; EXT_ID, INT_ID, COMPARE_KEYS, ACE_LOCK &gt;::test_invariant_recurse </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classACE__RB__Tree__Node.html">ACE_RB_Tree_Node</a>&lt; EXT_ID, INT_ID &gt; *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>x</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>expected_black_height</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>measured_black_height</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [protected]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Recursively tests the invariant red-black properties at each node of the tree. Returns 0 if invariant holds, else -1.
<p>
    </td>
  </tr>
</table>
<a name="a8" doxytag="ACE_RB_Tree::trybind"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class EXT_ID, class INT_ID, class COMPARE_KEYS, class ACE_LOCK&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> ACE_INLINE int ACE_RB_Tree&lt; EXT_ID, INT_ID, COMPARE_KEYS, ACE_LOCK &gt;::trybind </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const EXT_ID &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>ext_id</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>INT_ID &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>int_id</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="classACE__RB__Tree__Node.html">ACE_RB_Tree_Node</a>&lt; EXT_ID, INT_ID &gt; *&amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>entry</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Same as a normal trybind, except the tree entry is also passed back to the caller. The entry in this case will either be the newly created entry, or the existing one.     </td>
  </tr>
</table>
<a name="a7" doxytag="ACE_RB_Tree::trybind"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class EXT_ID, class INT_ID, class COMPARE_KEYS, class ACE_LOCK&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> ACE_INLINE int ACE_RB_Tree&lt; EXT_ID, INT_ID, COMPARE_KEYS, ACE_LOCK &gt;::trybind </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const EXT_ID &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>ext_id</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>INT_ID &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>int_id</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Associate &lt;ext_id&gt; with &lt;int_id&gt; if and only if &lt;ext_id&gt; is not in the tree. If &lt;ext_id&gt; is already in the tree then the &lt;int_id&gt; parameter is assigned the existing value in the tree. Returns 0 if a new entry is bound successfully, returns 1 if an attempt is made to bind an existing entry, and returns -1 if failures occur.     </td>
  </tr>
</table>
<a name="a19" doxytag="ACE_RB_Tree::unbind"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class EXT_ID, class INT_ID, class COMPARE_KEYS, class ACE_LOCK&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> ACE_INLINE int ACE_RB_Tree&lt; EXT_ID, INT_ID, COMPARE_KEYS, ACE_LOCK &gt;::unbind </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classACE__RB__Tree__Node.html">ACE_RB_Tree_Node</a>&lt; EXT_ID, INT_ID &gt; *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>entry</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Remove entry from tree. This method should be used with *extreme* caution, and only for optimization purposes. The node being passed in had better have been allocated by the tree that is unbinding it.     </td>
  </tr>
</table>
<a name="a18" doxytag="ACE_RB_Tree::unbind"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class EXT_ID, class INT_ID, class COMPARE_KEYS, class ACE_LOCK&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> ACE_INLINE int ACE_RB_Tree&lt; EXT_ID, INT_ID, COMPARE_KEYS, ACE_LOCK &gt;::unbind </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const EXT_ID &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>ext_id</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>INT_ID &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>int_id</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Break any association of &lt;ext_id&gt;. Returns the value of &lt;int_id&gt; in case the caller needs to deallocate memory.
<p>
    </td>
  </tr>
</table>
<a name="a17" doxytag="ACE_RB_Tree::unbind"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class EXT_ID, class INT_ID, class COMPARE_KEYS, class ACE_LOCK&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> ACE_INLINE int ACE_RB_Tree&lt; EXT_ID, INT_ID, COMPARE_KEYS, ACE_LOCK &gt;::unbind </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const EXT_ID &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>ext_id</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Unbind (remove) the &lt;ext_id&gt; from the tree. Don't return the &lt;int_id&gt; to the caller (this is useful for collections where the &lt;int_id&gt;s are *not* dynamically allocated...)     </td>
  </tr>
</table>
<hr><h2>Friends And Related Function Documentation</h2>
<a name="l1" doxytag="ACE_RB_Tree::ACE_RB_Tree_Iterator< EXT_ID, INT_ID, COMPARE_KEYS, ACE_LOCK >"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class EXT_ID, class INT_ID, class COMPARE_KEYS, class ACE_LOCK&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> friend class <a class="el" href="classACE__RB__Tree__Iterator.html">ACE_RB_Tree_Iterator</a>&lt; EXT_ID, INT_ID, COMPARE_KEYS, ACE_LOCK &gt;<code> [friend]</code>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a name="l0" doxytag="ACE_RB_Tree::ACE_RB_Tree_Iterator_Base< EXT_ID, INT_ID, COMPARE_KEYS, ACE_LOCK >"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class EXT_ID, class INT_ID, class COMPARE_KEYS, class ACE_LOCK&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> friend class <a class="el" href="classACE__RB__Tree__Iterator__Base.html">ACE_RB_Tree_Iterator_Base</a>&lt; EXT_ID, INT_ID, COMPARE_KEYS, ACE_LOCK &gt;<code> [friend]</code>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a name="l2" doxytag="ACE_RB_Tree::ACE_RB_Tree_Reverse_Iterator< EXT_ID, INT_ID, COMPARE_KEYS, ACE_LOCK >"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class EXT_ID, class INT_ID, class COMPARE_KEYS, class ACE_LOCK&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> friend class <a class="el" href="classACE__RB__Tree__Reverse__Iterator.html">ACE_RB_Tree_Reverse_Iterator</a>&lt; EXT_ID, INT_ID, COMPARE_KEYS, ACE_LOCK &gt;<code> [friend]</code>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<hr><h2>Member Data Documentation</h2>
<a name="o0" doxytag="ACE_RB_Tree::allocator_"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class EXT_ID, class INT_ID, class COMPARE_KEYS, class ACE_LOCK&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="classACE__Allocator.html">ACE_Allocator</a>* ACE_RB_Tree::allocator_<code> [private]</code>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Pointer to a memory allocator.
<p>
    </td>
  </tr>
</table>
<a name="o3" doxytag="ACE_RB_Tree::compare_keys_"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class EXT_ID, class INT_ID, class COMPARE_KEYS, class ACE_LOCK&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> COMPARE_KEYS ACE_RB_Tree::compare_keys_<code> [private]</code>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Comparison functor for comparing nodes in the tree.
<p>
    </td>
  </tr>
</table>
<a name="o4" doxytag="ACE_RB_Tree::current_size_"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class EXT_ID, class INT_ID, class COMPARE_KEYS, class ACE_LOCK&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> size_t ACE_RB_Tree::current_size_<code> [private]</code>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
The current number of nodes in the tree.
<p>
    </td>
  </tr>
</table>
<a name="o1" doxytag="ACE_RB_Tree::lock_"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class EXT_ID, class INT_ID, class COMPARE_KEYS, class ACE_LOCK&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> ACE_LOCK ACE_RB_Tree::lock_<code> [private]</code>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Synchronization variable for the MT_SAFE &lt;ACE_RB_Tree&gt;.
<p>
    </td>
  </tr>
</table>
<a name="o2" doxytag="ACE_RB_Tree::root_"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class EXT_ID, class INT_ID, class COMPARE_KEYS, class ACE_LOCK&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="classACE__RB__Tree__Node.html">ACE_RB_Tree_Node</a>&lt;EXT_ID, INT_ID&gt;* ACE_RB_Tree::root_<code> [private]</code>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
The root of the tree.
<p>
    </td>
  </tr>
</table>
<hr>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="RB__Tree_8h.html">RB_Tree.h</a><li><a class="el" href="RB__Tree_8cpp.html">RB_Tree.cpp</a><li><a class="el" href="RB__Tree_8i.html">RB_Tree.i</a></ul>
<hr><address><small>Generated on Wed Jan 15 19:13:02 2003 for ACE by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.gif" alt="doxygen" align="middle" border=0 
width=110 height=53></a>1.2.13.1 written by <a href="mailto:dimitri@stack.nl">Dimitri van Heesch</a>,
 &copy;&nbsp;1997-2001</small></address>
</body>
</html>
