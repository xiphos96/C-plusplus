<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>ACE_Streambuf class Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body bgcolor="#ffffff">
<!-- Generated by Doxygen 1.2.13.1 -->
<center>
<a class="qindex" href="index.html">Main Page</a> &nbsp; <a class="qindex" href="hierarchy.html">Class Hierarchy</a> &nbsp; <a class="qindex" href="classes.html">Alphabetical List</a> &nbsp; <a class="qindex" href="annotated.html">Compound List</a> &nbsp; <a class="qindex" href="files.html">File List</a> &nbsp; <a class="qindex" href="functions.html">Compound Members</a> &nbsp; <a class="qindex" href="globals.html">File Members</a> &nbsp; <a class="qindex" href="pages.html">Related Pages</a> &nbsp; </center>
<hr><h1>ACE_Streambuf  Class Reference</h1>Create your custom streambuf by providing and ACE_*_Stream object to this template. I have tested it with <a class="el" href="classACE__SOCK__Stream.html">ACE_SOCK_Stream</a> and it should work fine for others as well. 
<a href="#_details">More...</a>
<p>
<code>#include &lt;IOStream.h&gt;</code>
<p>
Inheritance diagram for ACE_Streambuf:<p><center><img src="classACE__Streambuf__inherit__graph.gif" border="0" usemap="#ACE__Streambuf__inherit__map" alt="Inheritance graph"></center>
<map name="ACE__Streambuf__inherit__map">
<area href="classACE__Streambuf__T.html" shape="rect" coords="14,84,217,103" alt="">
</map>
<center><font size="2">[<a href="graph_legend.html">legend</a>]</font></center>Collaboration diagram for ACE_Streambuf:<p><center><img src="classACE__Streambuf__coll__graph.gif" border="0" usemap="#ACE__Streambuf__coll__map" alt="Collaboration graph"></center>
<map name="ACE__Streambuf__coll__map">
<area href="classACE__Time__Value.html" shape="rect" coords="14,15,129,34" alt="">
</map>
<center><font size="2">[<a href="graph_legend.html">legend</a>]</font></center><a href="classACE__Streambuf-members.html">List of all members.</a><table border=0 cellpadding=0 cellspacing=0>
<tr><td colspan=2><br><h2>Public Methods</h2></td></tr>
<tr><td nowrap align=right valign=top>virtual&nbsp;</td><td valign=bottom><a class="el" href="classACE__Streambuf.html#a0">~ACE_Streambuf</a> (void)</td></tr>
<tr><td nowrap align=right valign=top><a class="el" href="classACE__Time__Value.html">ACE_Time_Value</a> *&nbsp;</td><td valign=bottom><a class="el" href="classACE__Streambuf.html#a1">recv_timeout</a> (<a class="el" href="classACE__Time__Value.html">ACE_Time_Value</a> *tv=NULL)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Get the current Time_Value pointer and provide a new one.</em> <a href="#a1">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>char *&nbsp;</td><td valign=bottom><a class="el" href="classACE__Streambuf.html#a2">reset_put_buffer</a> (char *newBuffer=NULL, u_int _streambuf_size=0, u_int _pptr=0)</td></tr>
<tr><td nowrap align=right valign=top>u_int&nbsp;</td><td valign=bottom><a class="el" href="classACE__Streambuf.html#a3">put_avail</a> (void)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Return the number of bytes to be 'put' onto the stream media. pbase + put_avail = pptr.</em> <a href="#a3">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>char *&nbsp;</td><td valign=bottom><a class="el" href="classACE__Streambuf.html#a4">reset_get_buffer</a> (char *newBuffer=NULL, u_int _streambuf_size=0, u_int _gptr=0, u_int _egptr=0)</td></tr>
<tr><td nowrap align=right valign=top>u_int&nbsp;</td><td valign=bottom><a class="el" href="classACE__Streambuf.html#a5">get_waiting</a> (void)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Return the number of bytes not yet gotten. eback + get_waiting = gptr.</em> <a href="#a5">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>u_int&nbsp;</td><td valign=bottom><a class="el" href="classACE__Streambuf.html#a6">get_avail</a> (void)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Return the number of bytes in the get area (includes some already gotten); eback + get_avail = egptr.</em> <a href="#a6">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>u_int&nbsp;</td><td valign=bottom><a class="el" href="classACE__Streambuf.html#a7">streambuf_size</a> (void)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Query the streambuf for the size of its buffers.</em> <a href="#a7">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>u_char&nbsp;</td><td valign=bottom><a class="el" href="classACE__Streambuf.html#a8">timeout</a> (void)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Did we take an error because of an IO operation timeout? Note: Invoking this resets the flag.</em> <a href="#a8">More...</a><em></em></font><br><br></td></tr>
<tr><td colspan=2><br><h2>Protected Methods</h2></td></tr>
<tr><td nowrap align=right valign=top>&nbsp;</td><td valign=bottom><a class="el" href="classACE__Streambuf.html#b0">ACE_Streambuf</a> (u_int streambuf_size, int io_mode)</td></tr>
<tr><td nowrap align=right valign=top>virtual int&nbsp;</td><td valign=bottom><a class="el" href="classACE__Streambuf.html#b1">sync</a> (void)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Sync both input and output. See syncin/syncout below for descriptions.</em> <a href="#b1">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>virtual int&nbsp;</td><td valign=bottom><a class="el" href="classACE__Streambuf.html#b2">underflow</a> (void)</td></tr>
<tr><td nowrap align=right valign=top>virtual int&nbsp;</td><td valign=bottom><a class="el" href="classACE__Streambuf.html#b3">overflow</a> (int=EOF)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>The overflow function receives the character which caused the overflow.</em> <a href="#b3">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classACE__Streambuf.html#b4">reset_base</a> (void)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Resets the &lt;base&gt; pointer and streambuf mode. This is used internally when get/put buffers are allocatd.</em> <a href="#b4">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>int&nbsp;</td><td valign=bottom><a class="el" href="classACE__Streambuf.html#b5">syncin</a> (void)</td></tr>
<tr><td nowrap align=right valign=top>int&nbsp;</td><td valign=bottom><a class="el" href="classACE__Streambuf.html#b6">syncout</a> (void)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>syncout is called when the output needs to be flushed. This is easily done by calling the peer's send_n function.</em> <a href="#b6">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>int&nbsp;</td><td valign=bottom><a class="el" href="classACE__Streambuf.html#b7">flushbuf</a> (void)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>flushbuf is the worker of syncout. It is a separate function because it gets used sometimes in different context.</em> <a href="#b7">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>int&nbsp;</td><td valign=bottom><a class="el" href="classACE__Streambuf.html#b8">fillbuf</a> (void)</td></tr>
<tr><td nowrap align=right valign=top>virtual int&nbsp;</td><td valign=bottom><a class="el" href="classACE__Streambuf.html#b9">get_one_byte</a> (void)</td></tr>
<tr><td nowrap align=right valign=top>virtual <a class="el" href="Basic__Types_8h.html#a38">ssize_t</a>&nbsp;</td><td valign=bottom><a class="el" href="classACE__Streambuf.html#b10">send</a> (char *buf, <a class="el" href="Basic__Types_8h.html#a38">ssize_t</a> len)=0</td></tr>
<tr><td nowrap align=right valign=top>virtual <a class="el" href="Basic__Types_8h.html#a38">ssize_t</a>&nbsp;</td><td valign=bottom><a class="el" href="classACE__Streambuf.html#b11">recv</a> (char *buf, <a class="el" href="Basic__Types_8h.html#a38">ssize_t</a> len, <a class="el" href="classACE__Time__Value.html">ACE_Time_Value</a> *tv=NULL)=0</td></tr>
<tr><td nowrap align=right valign=top>virtual <a class="el" href="Basic__Types_8h.html#a38">ssize_t</a>&nbsp;</td><td valign=bottom><a class="el" href="classACE__Streambuf.html#b12">recv</a> (char *buf, <a class="el" href="Basic__Types_8h.html#a38">ssize_t</a> len, int flags, <a class="el" href="classACE__Time__Value.html">ACE_Time_Value</a> *tv=NULL)=0</td></tr>
<tr><td nowrap align=right valign=top>virtual <a class="el" href="Basic__Types_8h.html#a38">ssize_t</a>&nbsp;</td><td valign=bottom><a class="el" href="classACE__Streambuf.html#b13">recv_n</a> (char *buf, <a class="el" href="Basic__Types_8h.html#a38">ssize_t</a> len, int flags=0, <a class="el" href="classACE__Time__Value.html">ACE_Time_Value</a> *tv=NULL)=0</td></tr>
<tr><td nowrap align=right valign=top>virtual ACE_HANDLE&nbsp;</td><td valign=bottom><a class="el" href="classACE__Streambuf.html#b14">get_handle</a> (void)</td></tr>
<tr><td colspan=2><br><h2>Protected Attributes</h2></td></tr>
<tr><td nowrap align=right valign=top>char *&nbsp;</td><td valign=bottom><a class="el" href="classACE__Streambuf.html#n0">eback_saved_</a></td></tr>
<tr><td nowrap align=right valign=top>char *&nbsp;</td><td valign=bottom><a class="el" href="classACE__Streambuf.html#n1">gptr_saved_</a></td></tr>
<tr><td nowrap align=right valign=top>char *&nbsp;</td><td valign=bottom><a class="el" href="classACE__Streambuf.html#n2">egptr_saved_</a></td></tr>
<tr><td nowrap align=right valign=top>char *&nbsp;</td><td valign=bottom><a class="el" href="classACE__Streambuf.html#n3">pbase_saved_</a></td></tr>
<tr><td nowrap align=right valign=top>char *&nbsp;</td><td valign=bottom><a class="el" href="classACE__Streambuf.html#n4">pptr_saved_</a></td></tr>
<tr><td nowrap align=right valign=top>char *&nbsp;</td><td valign=bottom><a class="el" href="classACE__Streambuf.html#n5">epptr_saved_</a></td></tr>
<tr><td nowrap align=right valign=top>u_char&nbsp;</td><td valign=bottom><a class="el" href="classACE__Streambuf.html#n6">cur_mode_</a></td></tr>
<tr><td nowrap align=right valign=top>const u_char&nbsp;</td><td valign=bottom><a class="el" href="classACE__Streambuf.html#n7">get_mode_</a></td></tr>
<tr><td nowrap align=right valign=top>const u_char&nbsp;</td><td valign=bottom><a class="el" href="classACE__Streambuf.html#n8">put_mode_</a></td></tr>
<tr><td nowrap align=right valign=top>int&nbsp;</td><td valign=bottom><a class="el" href="classACE__Streambuf.html#n9">mode_</a></td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>mode tells us if we're working for an istream, ostream, or iostream.</em> <a href="#n9">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>const u_int&nbsp;</td><td valign=bottom><a class="el" href="classACE__Streambuf.html#n10">streambuf_size_</a></td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>This defines the size of the input and output buffers. It can be set by the object constructor.</em> <a href="#n10">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>u_char&nbsp;</td><td valign=bottom><a class="el" href="classACE__Streambuf.html#n11">timeout_</a></td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Did we take an error because of an IO operation timeout?</em> <a href="#n11">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top><a class="el" href="classACE__Time__Value.html">ACE_Time_Value</a>&nbsp;</td><td valign=bottom><a class="el" href="classACE__Streambuf.html#n12">recv_timeout_value_</a></td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>We want to allow the user to provide Time_Value pointers to prevent infinite blocking while waiting to receive data.</em> <a href="#n12">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top><a class="el" href="classACE__Time__Value.html">ACE_Time_Value</a> *&nbsp;</td><td valign=bottom><a class="el" href="classACE__Streambuf.html#n13">recv_timeout_</a></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Create your custom streambuf by providing and ACE_*_Stream object to this template. I have tested it with <a class="el" href="classACE__SOCK__Stream.html">ACE_SOCK_Stream</a> and it should work fine for others as well.
<p>

<p>
 For any iostream object, the real work is done by the underlying streambuf class. That is what we create here. A streambuf has an internal buffer area into which data is read and written as the iostream requests and provides data. At some point during the read process, the iostream will realize that the streambuf has no more data. The underflow function of the streambuf is then called. Likewise, during the write process, the iostream will eventually notice that the streabuf's buffer has become full and will invoke the overflow function. The empty/full state of the read/write "buffers" are controled by two sets pointers. One set is dedicated to read, the other to write. These pointers, in turn, reference a common buffer that is to be shared by both read and write operations. It is this common buffer to which data is written and from which it is read. The common buffer is used by functions of the streambuf as well as the iostream. Because of this and the fact that it is "shared" by both read and write operators, there is a danger of data corruption if read and write operations are allowed to take place "at the same time". To prevent data corruption, we manipulate the read and write pointer sets so that the streambuf is in either a read-mode or write-mode at all times and can never be in both modes at the same time. In the constructor: set the read and write sets to NULL This causes the underflow or overflow operators to be invoked at the first IO activity of the iostream. In the underflow function we arrange for the common buffer to reference our read buffer and for the write pointer set to be disabled. If a write operation is performed by the iostream this will cause the overflow function to be invoked. In the overflow function we arrange for the common buffer to reference our write buffer and for the read pointer set to be disabled. This causes the underflow function to be invoked when the iostream "changes our mode". The overflow function will also invoke the send_n function to flush the buffered data to our peer. Similarly, the sync and syncout functions will cause send_n to be invoked to send the data. Since socket's and the like do not support seeking, there can be no method for "syncing" the input. However, since we maintain separate read/write buffers, no data is lost by "syncing" the input. It simply remains buffered. 
<p>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a name="a0" doxytag="ACE_Streambuf::~ACE_Streambuf"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> ACE_Streambuf::~ACE_Streambuf </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
If the default allocation strategey were used the common buffer would be deleted when the object destructs. Since we are providing separate read/write buffers, it is up to us to manage their memory.     </td>
  </tr>
</table>
<a name="b0" doxytag="ACE_Streambuf::ACE_Streambuf"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> ACE_Streambuf::ACE_Streambuf </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">u_int&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>streambuf_size</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>io_mode</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [protected]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<hr><h2>Member Function Documentation</h2>
<a name="b8" doxytag="ACE_Streambuf::fillbuf"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int ACE_Streambuf::fillbuf </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [protected]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
fillbuf is called in a couple of places. This is the worker of underflow. It will attempt to fill the read buffer from the peer.     </td>
  </tr>
</table>
<a name="b7" doxytag="ACE_Streambuf::flushbuf"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int ACE_Streambuf::flushbuf </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [protected]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
flushbuf is the worker of syncout. It is a separate function because it gets used sometimes in different context.
<p>
    </td>
  </tr>
</table>
<a name="a6" doxytag="ACE_Streambuf::get_avail"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> u_int ACE_Streambuf::get_avail </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Return the number of bytes in the get area (includes some already gotten); eback + get_avail = egptr.
<p>
    </td>
  </tr>
</table>
<a name="b14" doxytag="ACE_Streambuf::get_handle"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> ACE_HANDLE ACE_Streambuf::get_handle </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [protected, virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Reimplemented in <a class="el" href="classACE__Streambuf__T.html#b0">ACE_Streambuf_T</a>.    </td>
  </tr>
</table>
<a name="b9" doxytag="ACE_Streambuf::get_one_byte"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int ACE_Streambuf::get_one_byte </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [protected, virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Used by fillbuf and others to get exactly one byte from the peer. recv_n is used to be sure we block until something is available. It is virtual because we really need to override it for datagram-derived objects.     </td>
  </tr>
</table>
<a name="a5" doxytag="ACE_Streambuf::get_waiting"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> u_int ACE_Streambuf::get_waiting </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Return the number of bytes not yet gotten. eback + get_waiting = gptr.
<p>
    </td>
  </tr>
</table>
<a name="b3" doxytag="ACE_Streambuf::overflow"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int ACE_Streambuf::overflow </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>c</em> = EOF          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [protected, virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
The overflow function receives the character which caused the overflow.
<p>
    </td>
  </tr>
</table>
<a name="a3" doxytag="ACE_Streambuf::put_avail"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> u_int ACE_Streambuf::put_avail </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Return the number of bytes to be 'put' onto the stream media. pbase + put_avail = pptr.
<p>
    </td>
  </tr>
</table>
<a name="b12" doxytag="ACE_Streambuf::recv"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> virtual <a class="el" href="Basic__Types_8h.html#a38">ssize_t</a> ACE_Streambuf::recv </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">char *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>buf</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="Basic__Types_8h.html#a38">ssize_t</a>&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>len</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>flags</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="classACE__Time__Value.html">ACE_Time_Value</a> *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>tv</em> = NULL</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [protected, pure virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Reimplemented in <a class="el" href="classACE__Streambuf__T.html#a3">ACE_Streambuf_T</a>.    </td>
  </tr>
</table>
<a name="b11" doxytag="ACE_Streambuf::recv"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> virtual <a class="el" href="Basic__Types_8h.html#a38">ssize_t</a> ACE_Streambuf::recv </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">char *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>buf</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="Basic__Types_8h.html#a38">ssize_t</a>&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>len</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="classACE__Time__Value.html">ACE_Time_Value</a> *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>tv</em> = NULL</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [protected, pure virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Reimplemented in <a class="el" href="classACE__Streambuf__T.html#a2">ACE_Streambuf_T</a>.    </td>
  </tr>
</table>
<a name="b13" doxytag="ACE_Streambuf::recv_n"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> virtual <a class="el" href="Basic__Types_8h.html#a38">ssize_t</a> ACE_Streambuf::recv_n </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">char *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>buf</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="Basic__Types_8h.html#a38">ssize_t</a>&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>len</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>flags</em> = 0, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="classACE__Time__Value.html">ACE_Time_Value</a> *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>tv</em> = NULL</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [protected, pure virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Reimplemented in <a class="el" href="classACE__Streambuf__T.html#a4">ACE_Streambuf_T</a>.    </td>
  </tr>
</table>
<a name="a1" doxytag="ACE_Streambuf::recv_timeout"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="classACE__Time__Value.html">ACE_Time_Value</a> * ACE_Streambuf::recv_timeout </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classACE__Time__Value.html">ACE_Time_Value</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>tv</em> = NULL          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get the current Time_Value pointer and provide a new one.
<p>
    </td>
  </tr>
</table>
<a name="b4" doxytag="ACE_Streambuf::reset_base"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void ACE_Streambuf::reset_base </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [protected]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Resets the &lt;base&gt; pointer and streambuf mode. This is used internally when get/put buffers are allocatd.
<p>
    </td>
  </tr>
</table>
<a name="a4" doxytag="ACE_Streambuf::reset_get_buffer"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> char * ACE_Streambuf::reset_get_buffer </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">char *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>newBuffer</em> = NULL, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>u_int&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>_streambuf_size</em> = 0, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>u_int&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>_gptr</em> = 0, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>u_int&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>_egptr</em> = 0</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Use this to allocate a new/different buffer for get operations. If you do not provide a buffer pointer, one will be allocated. That is the preferred method. If you do provide a buffer, the size must match that being used by the put buffer. If successful, you will receive a pointer to the current get buffer. It is your responsibility to delete this memory when you are done with it.     </td>
  </tr>
</table>
<a name="a2" doxytag="ACE_Streambuf::reset_put_buffer"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> char * ACE_Streambuf::reset_put_buffer </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">char *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>newBuffer</em> = NULL, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>u_int&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>_streambuf_size</em> = 0, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>u_int&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>_pptr</em> = 0</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Use this to allocate a new/different buffer for put operations. If you do not provide a buffer pointer, one will be allocated. That is the preferred method. If you do provide a buffer, the size must match that being used by the get buffer. If successful, you will receive a pointer to the current put buffer. It is your responsibility to delete this memory when you are done with it.     </td>
  </tr>
</table>
<a name="b10" doxytag="ACE_Streambuf::send"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> virtual <a class="el" href="Basic__Types_8h.html#a38">ssize_t</a> ACE_Streambuf::send </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">char *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>buf</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="Basic__Types_8h.html#a38">ssize_t</a>&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>len</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [protected, pure virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Stream connections and "unconnected connections" (ie -- datagrams) need to work just a little differently. We derive custom Streambuf objects for them and provide these functions at that time. 
<p>
Reimplemented in <a class="el" href="classACE__Streambuf__T.html#a1">ACE_Streambuf_T</a>.    </td>
  </tr>
</table>
<a name="a7" doxytag="ACE_Streambuf::streambuf_size"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> u_int ACE_Streambuf::streambuf_size </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Query the streambuf for the size of its buffers.
<p>
    </td>
  </tr>
</table>
<a name="b1" doxytag="ACE_Streambuf::sync"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int ACE_Streambuf::sync </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [protected, virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Sync both input and output. See syncin/syncout below for descriptions.
<p>
    </td>
  </tr>
</table>
<a name="b5" doxytag="ACE_Streambuf::syncin"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int ACE_Streambuf::syncin </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [protected]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
syncin is called when the input needs to be synced with the source file. In a filebuf, this results in the &lt;seek&gt; system call being used. We can't do that on socket-like connections, so this does basically nothing. That's safe because we have a separate read buffer to maintain the already-read data. In a filebuf, the single common buffer is used forcing the &lt;seek&gt; call.     </td>
  </tr>
</table>
<a name="b6" doxytag="ACE_Streambuf::syncout"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int ACE_Streambuf::syncout </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [protected]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
syncout is called when the output needs to be flushed. This is easily done by calling the peer's send_n function.
<p>
    </td>
  </tr>
</table>
<a name="a8" doxytag="ACE_Streambuf::timeout"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> u_char ACE_Streambuf::timeout </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Did we take an error because of an IO operation timeout? Note: Invoking this resets the flag.
<p>
    </td>
  </tr>
</table>
<a name="b2" doxytag="ACE_Streambuf::underflow"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int ACE_Streambuf::underflow </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [protected, virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<hr><h2>Member Data Documentation</h2>
<a name="n6" doxytag="ACE_Streambuf::cur_mode_"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> u_char ACE_Streambuf::cur_mode_<code> [protected]</code>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a name="n0" doxytag="ACE_Streambuf::eback_saved_"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> char* ACE_Streambuf::eback_saved_<code> [protected]</code>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a name="n2" doxytag="ACE_Streambuf::egptr_saved_"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> char* ACE_Streambuf::egptr_saved_<code> [protected]</code>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a name="n5" doxytag="ACE_Streambuf::epptr_saved_"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> char* ACE_Streambuf::epptr_saved_<code> [protected]</code>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a name="n7" doxytag="ACE_Streambuf::get_mode_"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> const u_char ACE_Streambuf::get_mode_<code> [protected]</code>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a name="n1" doxytag="ACE_Streambuf::gptr_saved_"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> char* ACE_Streambuf::gptr_saved_<code> [protected]</code>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a name="n9" doxytag="ACE_Streambuf::mode_"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int ACE_Streambuf::mode_<code> [protected]</code>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
mode tells us if we're working for an istream, ostream, or iostream.
<p>
    </td>
  </tr>
</table>
<a name="n3" doxytag="ACE_Streambuf::pbase_saved_"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> char* ACE_Streambuf::pbase_saved_<code> [protected]</code>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a name="n4" doxytag="ACE_Streambuf::pptr_saved_"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> char* ACE_Streambuf::pptr_saved_<code> [protected]</code>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a name="n8" doxytag="ACE_Streambuf::put_mode_"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> const u_char ACE_Streambuf::put_mode_<code> [protected]</code>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a name="n13" doxytag="ACE_Streambuf::recv_timeout_"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="classACE__Time__Value.html">ACE_Time_Value</a>* ACE_Streambuf::recv_timeout_<code> [protected]</code>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a name="n12" doxytag="ACE_Streambuf::recv_timeout_value_"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="classACE__Time__Value.html">ACE_Time_Value</a> ACE_Streambuf::recv_timeout_value_<code> [protected]</code>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
We want to allow the user to provide Time_Value pointers to prevent infinite blocking while waiting to receive data.
<p>
    </td>
  </tr>
</table>
<a name="n10" doxytag="ACE_Streambuf::streambuf_size_"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> const u_int ACE_Streambuf::streambuf_size_<code> [protected]</code>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This defines the size of the input and output buffers. It can be set by the object constructor.
<p>
    </td>
  </tr>
</table>
<a name="n11" doxytag="ACE_Streambuf::timeout_"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> u_char ACE_Streambuf::timeout_<code> [protected]</code>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Did we take an error because of an IO operation timeout?
<p>
    </td>
  </tr>
</table>
<hr>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="IOStream_8h.html">IOStream.h</a><li><a class="el" href="IOStream_8cpp.html">IOStream.cpp</a></ul>
<hr><address><small>Generated on Wed Jan 15 19:14:34 2003 for ACE by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.gif" alt="doxygen" align="middle" border=0 
width=110 height=53></a>1.2.13.1 written by <a href="mailto:dimitri@stack.nl">Dimitri van Heesch</a>,
 &copy;&nbsp;1997-2001</small></address>
</body>
</html>
