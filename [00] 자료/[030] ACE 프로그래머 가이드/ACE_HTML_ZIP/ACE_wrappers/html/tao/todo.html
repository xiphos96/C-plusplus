<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Todo List</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body bgcolor="#ffffff">
<!-- Generated by Doxygen 1.2.13.1 -->
<center>
<a class="qindex" href="index.html">Main Page</a> &nbsp; <a class="qindex" href="namespaces.html">Namespace List</a> &nbsp; <a class="qindex" href="hierarchy.html">Class Hierarchy</a> &nbsp; <a class="qindex" href="classes.html">Alphabetical List</a> &nbsp; <a class="qindex" href="annotated.html">Compound List</a> &nbsp; <a class="qindex" href="files.html">File List</a> &nbsp; <a class="qindex" href="namespacemembers.html">Namespace Members</a> &nbsp; <a class="qindex" href="functions.html">Compound Members</a> &nbsp; <a class="qindex" href="globals.html">File Members</a> &nbsp; <a class="qindex" href="pages.html">Related Pages</a> &nbsp; </center>
<hr><a name="todo"><h2>Todo List</h2></a>

<dl compact>
<dt><a name="_todo000008"></a>Member <a class="el" href="classTAO__Asynch__Queued__Message.html#a0">TAO_Asynch_Queued_Message::TAO_Asynch_Queued_Message</a>(const <a class="elRef" doxygen="ACE.tag:../ace/" href="../ace/classACE__Message__Block.html">ACE_Message_Block</a> *contents, <a class="elRef" doxygen="ACE.tag:../ace/" href="../ace/classACE__Allocator.html">ACE_Allocator</a> *alloc=0, int is_heap_allocated=0) <dd> I'm almost sure this class will require a callback interface for AMIs sent with SYNC_NONE policy. Those guys need to hear when the connection timeouts or closes, but cannot block waiting for the message to be delivered. 
</dl>

<p>

<dl compact>
<dt><a name="_todo000009"></a>Member <a class="el" href="classTAO__ClientRequestInterceptor__Adapter.html#z7_0">TAO_ClientRequestInterceptor_Adapter::send_request</a>(<a class="el" href="classTAO__ClientRequestInfo__i.html">TAO_ClientRequestInfo_i</a> *ri ACE_ENV_ARG_DECL) <dd> The "send_poll()" and "receive_other()" (for AMI) <a class="el" href="namespacePortableInterceptor.html">PortableInterceptor</a> interception points are missing. 
</dl>

<p>

<dl compact>
<dt><a name="_todo000010"></a>Member <a class="el" href="classTAO__Leader__Follower.html#a8">TAO_Leader_Follower::wait_for_event</a>(<a class="el" href="classTAO__LF__Event.html">TAO_LF_Event</a> *event, <a class="el" href="classTAO__Transport.html">TAO_Transport</a> *transport, <a class="elRef" doxygen="ACE.tag:../ace/" href="../ace/classACE__Time__Value.html">ACE_Time_Value</a> *max_wait_time) <dd> Document this better, split the Follower code to the <a class="el" href="classTAO__LF__Follower.html">TAO_LF_Follower</a> class, we probably don't need the transport object. 
</dl>

<p>

<dl compact>
<dt><a name="_todo000002"></a>Class <a class="el" href="classTAO__LF__Event.html">TAO_LF_Event</a> <dd>Implementing the Leader/Followers loop in this class, as well as the callbacks to communicate that an event has completed leads to excessive coupling. A better design would use a separate class to signal the events, that would allow us to remove the Leader/Followers logic from the ORB. However, that requires other major changes and it somewhat complicates the design.
</dl>

<p>

<dl compact>
<dt><a name="_todo000003"></a>Class <a class="el" href="classTAO__LF__Follower.html">TAO_LF_Follower</a> <dd>Currently this class offers little abstraction, the follower loop should be implemented by this class.
</dl>

<p>

<dl compact>
<dt><a name="_todo000012"></a>Member <a class="el" href="classTAO__ORB__Core.html#z30_0">TAO_ORB_Core::poa_current</a>(void) <dd>In the future this hook should change, instead of hardcoding the object we should add a "Resolver" to the ORB, so the "POACurrent" object returns a per-ORB object.
</dl>

<p>

<dl compact>
<dt><a name="_todo000004"></a>Class <a class="el" href="classTAO__ORB__Core__Auto__Ptr.html">TAO_ORB_Core_Auto_Ptr</a> <dd> <a class="el" href="classTAO__ORB__Core__Auto__Ptr.html">TAO_ORB_Core_Auto_Ptr</a> should be renamed to TAO_ORB_Core_var since the ORB Core is reference counted. 
</dl>

<p>

<dl compact>
<dt><a name="_todo000011"></a>Member <a class="el" href="classTAO__ORB__Core__TSS__Resources.html#m0">TAO_ORB_Core_TSS_Resources::event_loop_thread_</a> <dd> The rest of the resources are not currently in use, just a plan for the future... 
</dl>

<p>

<dl compact>
<dt><a name="_todo000006"></a>Class <a class="el" href="classTAO__Queued__Message.html">TAO_Queued_Message</a> <dd>: Change the ORB to allocate oneway and AMI buffer from global memory, to avoid the data copy in this path. What happens if the there is no queueing? Can we check that before allocating the memory?
</dl>

<p>

<dl compact>
<dt><a name="_todo000013"></a>Member <a class="el" href="classTAO__Queued__Message.html#z56_0">TAO_Queued_Message::next</a>(void) const <dd>: We should implement this as a base template, something like: template&lt;class T&gt; Intrusive_Node { public: void next (T *); T* next () const; private: T* next_; }; and use it as follows: class <a class="el" href="classTAO__Queued__Message.html">TAO_Queued_Message</a> : public Intrusive_Node&lt;<a class="el" href="classTAO__Queued__Message.html">TAO_Queued_Message</a>&gt; { };
</dl>

<p>

<dl compact>
<dt><a name="_todo000015"></a>Member <a class="el" href="classTAO__ServerRequest.html#z61_0">TAO_ServerRequest::request_service_info</a>(void) <dd> This two methods should go away. 
</dl>

<p>

<dl compact>
<dt><a name="_todo000014"></a>Member <a class="el" href="classTAO__Stub.html#n1">TAO_Stub::orb_</a> <dd> Why do we need both a reference to the ORB_Core and its ORB? It think the memory management rules for the ORB_Core changed, in the good old days it was the <a class="el" href="interfaceCORBA_1_1ORB.html">CORBA::ORB</a> class who owned the ORB_Core, now it is the other way around.... 
</dl>

<p>

<dl compact>
<dt><a name="_todo000007"></a>Class <a class="el" href="classTAO__Sync__Strategy.html">TAO_Sync_Strategy</a> <dd> The class name (Sync_Strategy) is inherited from the policies (SyncScopePolicy), but Queueing_Strategy probably captures its intent better. It should be changed in a future revision of the ORB. 
</dl>

<p>

<dl compact>
<dt><a name="_todo000019"></a>Member <a class="el" href="classTAO__Transport.html#b0">TAO_Transport::event_handler_i</a>(void)=0 <dd> Since we only use a limited functionality of <a class="elRef" doxygen="ACE.tag:../ace/" href="../ace/classACE__Svc__Handler.html">ACE_Svc_Handler</a> we could probably implement a generic adapter class (TAO_Transport_Event_Handler or something), this will reduce footprint and simplify the process of implementing a pluggable protocol. 
</dl>

<p>

<dl compact>
<dt><a name="_todo000020"></a>Member <a class="el" href="classTAO__Transport.html#a26">TAO_Transport::handle_input_i</a>(<a class="el" href="classTAO__Resume__Handle.html">TAO_Resume_Handle</a> &amp;rh, <a class="elRef" doxygen="ACE.tag:../ace/" href="../ace/classACE__Time__Value.html">ACE_Time_Value</a> *max_wait_time=0, int block=0) <dd>: the method name is confusing! Calling it handle_input() would probably make things easier to understand and follow!
</dl>

<p>

<dl compact>
<dt><a name="_todo000023"></a>Member <a class="el" href="classTAO__Transport.html#a35">TAO_Transport::handle_timeout</a>(const <a class="elRef" doxygen="ACE.tag:../ace/" href="../ace/classACE__Time__Value.html">ACE_Time_Value</a> &amp;current_time, const void *act) <dd> In the future this function could be used to expire messages (oneways) that have been sitting for too long on the queue. 
</dl>

<p>

<dl compact>
<dt><a name="_todo000018"></a>Member <a class="el" href="classTAO__Transport.html#a17">TAO_Transport::register_handler</a>(void) <dd>: shouldn't this be automated? 
</dl>

<p>

<dl compact>
<dt><a name="_todo000022"></a>Member <a class="el" href="classTAO__Transport.html#b6">TAO_Transport::register_handler_i</a>(void)=0 <dd>: I think this method is pretty much useless, the connections are *always* registered with the Reactor, except in thread-per-connection mode. In that case putting the connection in the Reactor would produce unpredictable results anyway. 
</dl>

<p>

<dl compact>
<dt><a name="_todo000021"></a>Member <a class="el" href="classTAO__Transport.html#a27">TAO_Transport::send_request</a>(<a class="el" href="classTAO__Stub.html">TAO_Stub</a> *stub, <a class="el" href="classTAO__ORB__Core.html">TAO_ORB_Core</a> *orb_core, <a class="el" href="classTAO__OutputCDR.html">TAO_OutputCDR</a> &amp;stream, int message_semantics, <a class="elRef" doxygen="ACE.tag:../ace/" href="../ace/classACE__Time__Value.html">ACE_Time_Value</a> *max_time_wait)=0 <dd> This is generic code, it should be factored out into the Transport class. 
</dl>

<p>

<dl compact>
<dt><a name="_todo000016"></a>Class <a class="el" href="structTimeBase_1_1UtcT.html">TimeBase::UtcT</a> <dd> What is exactly the range of time here? Is it [time-inacclo,time+inacchi]? 
</dl>

<p>

<dl compact>
<dt><a name="_todo000017"></a>Member <a class="el" href="structTimeBase_1_1UtcT.html#m3">TimeBase::UtcT::tdf</a> <dd> please document
</dl>

<p>

<dl compact>
<dt><a name="_todo000005"></a>Member <a class="el" href="ORB__Core_8h.html#a0">TAO_TSS_RESOURCES</a> <dd> TAO_TSS_RESOURCES singleton typedef should go away. 
</dl>
 <hr><address><small>Generated on Wed Jan 15 21:01:17 2003 for TAO by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.gif" alt="doxygen" align="middle" border=0 
width=110 height=53></a>1.2.13.1 written by <a href="mailto:dimitri@stack.nl">Dimitri van Heesch</a>,
 &copy;&nbsp;1997-2001</small></address>
</body>
</html>
