<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Annotated Index</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body bgcolor="#ffffff">
<!-- Generated by Doxygen 1.2.13.1 -->
<center>
<a class="qindex" href="index.html">Main Page</a> &nbsp; <a class="qindex" href="namespaces.html">Namespace List</a> &nbsp; <a class="qindex" href="hierarchy.html">Class Hierarchy</a> &nbsp; <a class="qindex" href="classes.html">Alphabetical List</a> &nbsp; <a class="qindex" href="annotated.html">Compound List</a> &nbsp; <a class="qindex" href="files.html">File List</a> &nbsp; <a class="qindex" href="namespacemembers.html">Namespace Members</a> &nbsp; <a class="qindex" href="functions.html">Compound Members</a> &nbsp; <a class="qindex" href="globals.html">File Members</a> &nbsp; </center>
<hr><h1>TAO_AV Compound List</h1>Here are the classes, structs, unions and interfaces with brief descriptions:<table>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="exceptionAVStreams_1_1alreadyConnected.html">AVStreams::alreadyConnected</a></td><td></td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classAV__Null__MediaCtrl.html">AV_Null_MediaCtrl</a></td><td></td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="interfaceAVStreams_1_1Basic__StreamCtrl.html">AVStreams::Basic_StreamCtrl</a></td><td>Base class for <a class="el" href="interfaceAVStreams_1_1StreamCtrl.html">StreamCtrl</a>, implements basic stream start and stop functionality</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="structflowProtocol_1_1credit.html">flowProtocol::credit</a></td><td></td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="exceptionAVStreams_1_1deviceQosMismatch.html">AVStreams::deviceQosMismatch</a></td><td></td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="exceptionAVStreams_1_1failedToConnect.html">AVStreams::failedToConnect</a></td><td></td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="exceptionAVStreams_1_1failedToListen.html">AVStreams::failedToListen</a></td><td></td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="interfaceAVStreams_1_1FDev.html">AVStreams::FDev</a></td><td></td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="exceptionAVStreams_1_1FEPMismatch.html">AVStreams::FEPMismatch</a></td><td></td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="interfaceAVStreams_1_1FlowConnection.html">AVStreams::FlowConnection</a></td><td></td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="interfaceAVStreams_1_1FlowConsumer.html">AVStreams::FlowConsumer</a></td><td></td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="interfaceAVStreams_1_1FlowEndPoint.html">AVStreams::FlowEndPoint</a></td><td></td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="interfaceAVStreams_1_1FlowProducer.html">AVStreams::FlowProducer</a></td><td></td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="structAVStreams_1_1flowStatus.html">AVStreams::flowStatus</a></td><td>Used to store the status of a flow</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="exceptionAVStreams_1_1formatMismatch.html">AVStreams::formatMismatch</a></td><td></td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="exceptionAVStreams_1_1formatNotSupported.html">AVStreams::formatNotSupported</a></td><td></td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="exceptionAVStreams_1_1FPError.html">AVStreams::FPError</a></td><td></td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="structflowProtocol_1_1fragment.html">flowProtocol::fragment</a></td><td></td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="structflowProtocol_1_1frame.html">flowProtocol::frame</a></td><td></td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="structflowProtocol_1_1frameHeader.html">flowProtocol::frameHeader</a></td><td></td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="exceptionAVStreams_1_1InvalidPosition.html">AVStreams::InvalidPosition</a></td><td></td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="exceptionAVStreams_1_1invalidSettings.html">AVStreams::invalidSettings</a></td><td></td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="interfaceAVStreams_1_1MCastConfigIf.html">AVStreams::MCastConfigIf</a></td><td>Interface for multicasting operations</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="structMD5__CTX.html">MD5_CTX</a></td><td></td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="interfaceAVStreams_1_1MediaControl.html">AVStreams::MediaControl</a></td><td><a class="el" href="interfaceAVStreams_1_1MediaControl.html">MediaControl</a> interface is similar to ControlledStream interface in MSS. It can be inherited by flow endpoints or <a class="el" href="interfaceAVStreams_1_1FlowConnection.html">FlowConnection</a> interfaces</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="exceptionAVStreams_1_1MediaControl_1_1PostionKeyNotSupported.html">AVStreams::MediaControl::PostionKeyNotSupported</a></td><td></td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classMediaTimer.html">MediaTimer</a></td><td></td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="interfaceAVStreams_1_1MMDevice.html">AVStreams::MMDevice</a></td><td>Implements a factory to create Endpoints and VDevs</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classMMDevice__Map__Hash__Key.html">MMDevice_Map_Hash_Key</a></td><td></td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="interfaceAVStreams_1_1Negotiator.html">AVStreams::Negotiator</a></td><td>This interface is used to negotiate <a class="el" href="structAVStreams_1_1QoS.html">QoS</a> between two stream endpoints</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="exceptionAVStreams_1_1noSuchFlow.html">AVStreams::noSuchFlow</a></td><td></td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="exceptionAVStreams_1_1notConnected.html">AVStreams::notConnected</a></td><td></td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="exceptionAVStreams_1_1notSupported.html">AVStreams::notSupported</a></td><td></td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="interfaceNull__MediaCtrl.html">Null_MediaCtrl</a></td><td></td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="structAVStreams_1_1Position.html">AVStreams::Position</a></td><td></td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="exceptionAVStreams_1_1PostionKeyNotSupported.html">AVStreams::PostionKeyNotSupported</a></td><td></td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="exceptionAVStreams_1_1PropertyException.html">AVStreams::PropertyException</a></td><td></td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="exceptionAVStreams_1_1protocolNotSupported.html">AVStreams::protocolNotSupported</a></td><td></td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="structAVStreams_1_1QoS.html">AVStreams::QoS</a></td><td>This structure represents <a class="el" href="structAVStreams_1_1QoS.html">QoS</a> for a given type. E.g. {"video_qos", &lt;"video_framerate", 26&gt;, &lt;"video_depth", 9&gt;}</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="exceptionAVStreams_1_1QoSRequestFailed.html">AVStreams::QoSRequestFailed</a></td><td></td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="structRR__Block.html">RR_Block</a></td><td>The receiver report block encapsulates the data that represents the reception statistics for a particular stream</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classRTCP__BYE__Packet.html">RTCP_BYE_Packet</a></td><td>The BYE RTCP packet is sent by a party when leaving an RTP session</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classRTCP__Channel__In.html">RTCP_Channel_In</a></td><td>Single incoming data channel, or stream. The class has several responsibilities. When the class is instantiated, the incoming RTP traffic must be declared a valid source based on the RTP packets received. Once declared valie, this class is responsible for keeping up with reception statistics and other information. When an SR or RR is created (outside of this class), this class is used to get the Receiver Report block for this particular stream</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classRTCP__Channel__Out.html">RTCP_Channel_Out</a></td><td>Single outgoing data channel, or stream. It keeps track of statistics such as number of packets sent and number of bytes sent</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="structRTCP__Common__Header.html">RTCP_Common_Header</a></td><td>This is the header data that is common to all RTCP messages</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classRTCP__Packet.html">RTCP_Packet</a></td><td>This is an abstract class from which all RTCP packet types are derived. It contains code used to validate the RTCP packet</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classRTCP__RR__Packet.html">RTCP_RR_Packet</a></td><td>The Receiver Report packet is sent by all members of a session that are not sending data. It contains a list of <a class="el" href="structRR__Block.html">RR_Block</a> to represent each source this party is receiving data from</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classRTCP__SDES__Packet.html">RTCP_SDES_Packet</a></td><td>The Source Description packet is sent by all members of a session. At a minimum, the canonical name (or CNAME) is sent with each RTCP packet. Other items such as name, email, or location are included less frequently</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classRTCP__SR__Packet.html">RTCP_SR_Packet</a></td><td>The Sender Report packet is sent by all members of a session that are sending data. It contains statistics on the data being sent out. It also contains a list of <a class="el" href="structRR__Block.html">RR_Block</a> to represent each source this party is receiving data from</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classRTP__Packet.html">RTP_Packet</a></td><td>This class encapsulates all the necessary information to break down or build up an RTP data packet as well as operations to access all data items in the packet</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="structsdesChunk__s.html">sdesChunk_s</a></td><td>This is a linked list of structures containing groups of source description items. A group of items for a particular synchronization source id is referred to as a 'chunk'</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="structsdesItem__s.html">sdesItem_s</a></td><td>This is a linked list of structures containing source description 'items' such as canonical name, email, location etc</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="structflowProtocol_1_1sequencedFrame.html">flowProtocol::sequencedFrame</a></td><td></td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="structAVStreams_1_1SFPStatus.html">AVStreams::SFPStatus</a></td><td>This structure is defined for SFP1.0 Subsequent versions of the protocol may specify new structures</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="structflowProtocol_1_1specialFrame.html">flowProtocol::specialFrame</a></td><td></td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="structflowProtocol_1_1Start.html">flowProtocol::Start</a></td><td></td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="structflowProtocol_1_1StartReply.html">flowProtocol::StartReply</a></td><td></td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="interfaceAVStreams_1_1StreamCtrl.html">AVStreams::StreamCtrl</a></td><td>Implementation the A/V <a class="el" href="interfaceAVStreams_1_1StreamCtrl.html">StreamCtrl</a> class. this class is used to control the stream. It should be subclassed by applications that want to provide more control features</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="interfaceAVStreams_1_1StreamEndPoint.html">AVStreams::StreamEndPoint</a></td><td></td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="interfaceAVStreams_1_1StreamEndpoint.html">AVStreams::StreamEndpoint</a></td><td>The Stream EndPoint. Used to implement one endpoint of a stream that implements the transport layer</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="interfaceAVStreams_1_1StreamEndPoint__A.html">AVStreams::StreamEndPoint_A</a></td><td>The "A" side of a streamendpoint</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="interfaceAVStreams_1_1StreamEndPoint__B.html">AVStreams::StreamEndPoint_B</a></td><td>The "B" side of a streamendpoint</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="exceptionAVStreams_1_1streamOpDenied.html">AVStreams::streamOpDenied</a></td><td></td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="exceptionAVStreams_1_1streamOpFailed.html">AVStreams::streamOpFailed</a></td><td></td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classTAO__AV__Acceptor.html">TAO_AV_Acceptor</a></td><td></td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classTAO__AV__Acceptor__Registry.html">TAO_AV_Acceptor_Registry</a></td><td></td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classTAO__AV__Base__Connector.html">TAO_AV_Base_Connector</a></td><td></td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classTAO__AV__Callback.html">TAO_AV_Callback</a></td><td>Callback class that the user will be implementing for receiving frames from the network and also for timer events</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classTAO__AV__Child__Process.html">TAO_AV_Child_Process&lt; T_StreamEndpoint, T_VDev, T_MediaCtrl &gt;</a></td><td>Helper class for the child process created in <a class="el" href="classTAO__AV__Endpoint__Process__Strategy.html">TAO_AV_Endpoint_Process_Strategy</a></td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classTAO__AV__Child__Process__A.html">TAO_AV_Child_Process_A&lt; T_StreamEndpoint, T_VDev, T_MediaCtrl &gt;</a></td><td>Helper class for the child process created in <a class="el" href="classTAO__AV__Child__Process.html">TAO_AV_Child_Process</a></td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classTAO__AV__Child__Process__B.html">TAO_AV_Child_Process_B&lt; T_StreamEndpoint, T_VDev, T_MediaCtrl &gt;</a></td><td>Helper class for the child process created in <a class="el" href="classTAO__AV__Child__Process.html">TAO_AV_Child_Process</a></td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classTAO__AV__Connector.html">TAO_AV_Connector</a></td><td></td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classTAO__AV__Connector__Registry.html">TAO_AV_Connector_Registry</a></td><td></td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classTAO__AV__Core.html">TAO_AV_Core</a></td><td>This class encapsulates access to the <a class="elRef" doxygen="TAO.tag:../" href="../namespaceTAO.html">TAO</a> AV Core's resources and its state</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classTAO__AV__Default__Resource__Factory.html">TAO_AV_Default_Resource_Factory</a></td><td><a class="elRef" doxygen="TAO.tag:../" href="../namespaceTAO.html">TAO</a> AV Streams default resource factory The AV Streams resource factory loads the pluggable transport and flow protocol factories in the corresponding factory sets</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classTAO__AV__Endpoint__Process__Strategy.html">TAO_AV_Endpoint_Process_Strategy</a></td><td>Process-based strategy for creating endpoints. Abstract base class</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classTAO__AV__Endpoint__Process__Strategy__A.html">TAO_AV_Endpoint_Process_Strategy_A</a></td><td>Process-based strategy to create "A" type endpoints</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classTAO__AV__Endpoint__Process__Strategy__B.html">TAO_AV_Endpoint_Process_Strategy_B</a></td><td>Process-based strategy to create "B" type endpoints</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classTAO__AV__Endpoint__Reactive__Strategy.html">TAO_AV_Endpoint_Reactive_Strategy&lt; T_StreamEndpoint, T_VDev, T_MediaCtrl &gt;</a></td><td>Reactive strategy base class</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classTAO__AV__Endpoint__Reactive__Strategy__A.html">TAO_AV_Endpoint_Reactive_Strategy_A&lt; T_StreamEndpoint, T_VDev, T_MediaCtrl &gt;</a></td><td>Reactive strategy</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classTAO__AV__Endpoint__Reactive__Strategy__B.html">TAO_AV_Endpoint_Reactive_Strategy_B&lt; T_StreamEndpoint, T_Vdev, T_MediaCtrl &gt;</a></td><td>Reactive strategy</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classTAO__AV__Endpoint__Strategy.html">TAO_AV_Endpoint_Strategy</a></td><td></td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classTAO__AV__Flow__Handler.html">TAO_AV_Flow_Handler</a></td><td></td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classTAO__AV__Flow__Protocol__Factory.html">TAO_AV_Flow_Protocol_Factory</a></td><td></td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classTAO__AV__Flow__Protocol__Item.html">TAO_AV_Flow_Protocol_Item</a></td><td></td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="structTAO__AV__frame__info.html">TAO_AV_frame_info</a></td><td></td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classTAO__AV__Payload__Type__Policy.html">TAO_AV_Payload_Type_Policy</a></td><td></td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classTAO__AV__Policy.html">TAO_AV_Policy</a></td><td></td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classTAO__AV__Protocol__Object.html">TAO_AV_Protocol_Object</a></td><td></td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classTAO__AV__QoS.html">TAO_AV_QoS</a></td><td>Class for getting and setting the QoS characteristics of an AV Stream</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classTAO__AV__Resource__Factory.html">TAO_AV_Resource_Factory</a></td><td><a class="elRef" doxygen="TAO.tag:../" href="../namespaceTAO.html">TAO</a> AV Streams default resource factory abstract The AV Streams resource factory loads the pluggable transport and flow protocol factories in the corresponding factory sets</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classTAO__AV__RTCP.html">TAO_AV_RTCP</a></td><td>Encapsulate the header format for the Real Time Control Protocol (RTCP)</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="structTAO__AV__RTCP_1_1md5__string.html">TAO_AV_RTCP::md5_string</a></td><td></td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="structTAO__AV__RTCP_1_1ntp64.html">TAO_AV_RTCP::ntp64</a></td><td></td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="structTAO__AV__RTCP_1_1rtcphdr.html">TAO_AV_RTCP::rtcphdr</a></td><td></td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classTAO__AV__RTCP__Callback.html">TAO_AV_RTCP_Callback</a></td><td><a class="el" href="classTAO__AV__Callback.html">TAO_AV_Callback</a> for RTCP protocol</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classTAO__AV__RTCP__Flow__Factory.html">TAO_AV_RTCP_Flow_Factory</a></td><td></td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classTAO__AV__RTCP__Object.html">TAO_AV_RTCP_Object</a></td><td><a class="el" href="classTAO__AV__Protocol__Object.html">TAO_AV_Protocol_Object</a> for RTCP protocol</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="structTAO__AV__RTCP__Sdes.html">TAO_AV_RTCP_Sdes</a></td><td></td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classTAO__AV__RTCP__Sdes__Policy.html">TAO_AV_RTCP_Sdes_Policy</a></td><td></td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classTAO__AV__RTP.html">TAO_AV_RTP</a></td><td>Encapsulate the Real Time Protocol (RTP) header format</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="structTAO__AV__RTP_1_1bvchdr.html">TAO_AV_RTP::bvchdr</a></td><td></td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="structTAO__AV__RTP_1_1cellbhdr.html">TAO_AV_RTP::cellbhdr</a></td><td></td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="structTAO__AV__RTP_1_1jpeghdr.html">TAO_AV_RTP::jpeghdr</a></td><td></td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="structTAO__AV__RTP_1_1nvhdr.html">TAO_AV_RTP::nvhdr</a></td><td></td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="structTAO__AV__RTP_1_1rtphdr.html">TAO_AV_RTP::rtphdr</a></td><td></td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classTAO__AV__RTP__Flow__Factory.html">TAO_AV_RTP_Flow_Factory</a></td><td></td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classTAO__AV__RTP__Object.html">TAO_AV_RTP_Object</a></td><td>TAO_AV_Protocol_object for the RTP protocol</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classTAO__AV__SFP__Credit__Policy.html">TAO_AV_SFP_Credit_Policy</a></td><td></td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classTAO__AV__SFP__Factory.html">TAO_AV_SFP_Factory</a></td><td></td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classTAO__AV__SSRC__Policy.html">TAO_AV_SSRC_Policy</a></td><td></td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classTAO__AV__TCP__Acceptor.html">TAO_AV_TCP_Acceptor</a></td><td></td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classTAO__AV__TCP__Base__Acceptor.html">TAO_AV_TCP_Base_Acceptor</a></td><td></td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classTAO__AV__TCP__Base__Connector.html">TAO_AV_TCP_Base_Connector</a></td><td></td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classTAO__AV__TCP__Connector.html">TAO_AV_TCP_Connector</a></td><td></td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classTAO__AV__TCP__Factory.html">TAO_AV_TCP_Factory</a></td><td></td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classTAO__AV__TCP__Flow__Factory.html">TAO_AV_TCP_Flow_Factory</a></td><td></td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classTAO__AV__TCP__Flow__Handler.html">TAO_AV_TCP_Flow_Handler</a></td><td></td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classTAO__AV__TCP__Object.html">TAO_AV_TCP_Object</a></td><td><a class="el" href="classTAO__AV__Protocol__Object.html">TAO_AV_Protocol_Object</a> for Transmission Control Protocol (TCP)</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classTAO__AV__TCP__Transport.html">TAO_AV_TCP_Transport</a></td><td>A transport abstraction for socket streams. Uses the <a class="elRef" doxygen="ACE.tag:../../ace/" href="../../ace/classACE__SOCK__Stream.html">ACE_SOCK_Stream</a> to send the data</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classTAO__AV__Transport.html">TAO_AV_Transport</a></td><td>A Base class for the different transport protocols. All the different transports should derive and implement the open,close,send and recv methods</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classTAO__AV__Transport__Factory.html">TAO_AV_Transport_Factory</a></td><td></td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classTAO__AV__Transport__Item.html">TAO_AV_Transport_Item</a></td><td></td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classTAO__AV__UDP__Acceptor.html">TAO_AV_UDP_Acceptor</a></td><td></td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classTAO__AV__UDP__Connection__Setup.html">TAO_AV_UDP_Connection_Setup</a></td><td>This class is a helper for the <a class="el" href="classTAO__AV__UDP__Acceptor.html">TAO_AV_UDP_Acceptor</a> and <a class="el" href="classTAO__AV__UDP__Connector.html">TAO_AV_UDP_Connector</a>. It basically just reduces duplicate code. It takes the address of the peer in the connection, whether or not it is a multicast connection, and whether it is a connector or acceptor; and creates the local address and flow handler associated with the connection</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classTAO__AV__UDP__Connector.html">TAO_AV_UDP_Connector</a></td><td></td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classTAO__AV__UDP__Factory.html">TAO_AV_UDP_Factory</a></td><td></td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classTAO__AV__UDP__Flow__Factory.html">TAO_AV_UDP_Flow_Factory</a></td><td></td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classTAO__AV__UDP__Flow__Handler.html">TAO_AV_UDP_Flow_Handler</a></td><td>Flow Handler for UDP flows</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classTAO__AV__UDP__MCast__Flow__Handler.html">TAO_AV_UDP_MCast_Flow_Handler</a></td><td>Flow Handler for data sent over multicast sockets</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classTAO__AV__UDP__MCast__Transport.html">TAO_AV_UDP_MCast_Transport</a></td><td>A transport abstraction for Multicast dgram sockets. Uses the <a class="elRef" doxygen="ACE.tag:../../ace/" href="../../ace/classACE__SOCK__Dgram__Mcast.html">ACE_SOCK_Dgram_Mcast</a> to send data</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classTAO__AV__UDP__Object.html">TAO_AV_UDP_Object</a></td><td><a class="el" href="classTAO__AV__Protocol__Object.html">TAO_AV_Protocol_Object</a> for the User Datagram Protocol (UDP)</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classTAO__AV__UDP__Transport.html">TAO_AV_UDP_Transport</a></td><td>A transport abstraction for udp sockets. Uses the <a class="elRef" doxygen="ACE.tag:../../ace/" href="../../ace/classACE__SOCK__Dgram.html">ACE_SOCK_Dgram</a> to send the data</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classTAO__Base__StreamEndPoint.html">TAO_Base_StreamEndPoint</a></td><td></td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classTAO__Basic__StreamCtrl.html">TAO_Basic_StreamCtrl</a></td><td>Base class for StreamCtrl, implements basic stream start and stop functionality</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classTAO__FDev.html">TAO_FDev&lt; T_Producer, T_Consumer &gt;</a></td><td>Implementation of the AV/Streams Flow Device. A FlowConnection is used to bind FDevs for flows, much like how a StreamCtrl is used to bind MMDevices for streams</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classTAO__FlowConnection.html">TAO_FlowConnection</a></td><td>This class currently supports only one producer and one consumer per flow</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classTAO__FlowConsumer.html">TAO_FlowConsumer</a></td><td></td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classTAO__FlowEndPoint.html">TAO_FlowEndPoint</a></td><td>This class is used per flow e.g video flow and an audio flow to encapsulate the transport details</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classTAO__FlowProducer.html">TAO_FlowProducer</a></td><td></td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classTAO__FlowSpec__Entry.html">TAO_FlowSpec_Entry</a></td><td>A helper entry class in the flow spec sequence passed to bind_devs</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classTAO__Forward__FlowSpec__Entry.html">TAO_Forward_FlowSpec_Entry</a></td><td></td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classTAO__MCastConfigIf.html">TAO_MCastConfigIf</a></td><td></td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="structTAO__MCastConfigIf_1_1Peer__Info.html">TAO_MCastConfigIf::Peer_Info</a></td><td></td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classTAO__MediaControl.html">TAO_MediaControl</a></td><td>Abstract Mediacontrol class. The following are to be handled by the specialized media control for the specific media like camera, speaker</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classTAO__MMDevice.html">TAO_MMDevice</a></td><td>Implements a factory to create Endpoints and VDevs</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classTAO__Negotiator.html">TAO_Negotiator</a></td><td></td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classTAO__Reverse__FlowSpec__Entry.html">TAO_Reverse_FlowSpec_Entry</a></td><td></td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classTAO__SFP__Base.html">TAO_SFP_Base</a></td><td></td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classTAO__SFP__Consumer__Object.html">TAO_SFP_Consumer_Object</a></td><td></td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classTAO__SFP__Fragment__Node.html">TAO_SFP_Fragment_Node</a></td><td></td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classTAO__SFP__Fragment__Table__Entry.html">TAO_SFP_Fragment_Table_Entry</a></td><td></td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classTAO__SFP__Frame__State.html">TAO_SFP_Frame_State</a></td><td></td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classTAO__SFP__Object.html">TAO_SFP_Object</a></td><td></td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classTAO__SFP__Producer__Object.html">TAO_SFP_Producer_Object</a></td><td></td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classTAO__StreamCtrl.html">TAO_StreamCtrl</a></td><td>Implementation the A/V StreamCtrl class. this class is used to control the stream. It should be subclassed by applications that want to provide more control features</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="structTAO__StreamCtrl_1_1MMDevice__Map__Entry.html">TAO_StreamCtrl::MMDevice_Map_Entry</a></td><td></td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classTAO__StreamEndPoint.html">TAO_StreamEndPoint</a></td><td>The Stream EndPoint. Used to implement one endpoint of a stream that implements the transport layer</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classTAO__StreamEndPoint__A.html">TAO_StreamEndPoint_A</a></td><td>The "A" side of a streamendpoint</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classTAO__StreamEndPoint__B.html">TAO_StreamEndPoint_B</a></td><td>The "B" side of a streamendpoint</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classTAO__Tokenizer.html">TAO_Tokenizer</a></td><td></td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="classTAO__VDev.html">TAO_VDev</a></td><td>Implements the VDev interface. One of these is created per connection, and represents device-specific parameters</td></tr>
  <tr bgcolor="#f0f0f0"><td><a class="el" href="interfaceAVStreams_1_1VDev.html">AVStreams::VDev</a></td><td>Implements the <a class="el" href="interfaceAVStreams_1_1VDev.html">VDev</a> interface. One of these is created per connection, and represents device-specific parameters</td></tr>
</table>
<hr><address><small>Generated on Thu Jan 16 00:04:52 2003 for TAO_AV by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.gif" alt="doxygen" align="middle" border=0 
width=110 height=53></a>1.2.13.1 written by <a href="mailto:dimitri@stack.nl">Dimitri van Heesch</a>,
 &copy;&nbsp;1997-2001</small></address>
</body>
</html>
