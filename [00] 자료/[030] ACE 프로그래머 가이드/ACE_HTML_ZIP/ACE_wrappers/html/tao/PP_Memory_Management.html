<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Memory Management Rules for TAO's Pluggable Protocol Framework</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body bgcolor="#ffffff">
<!-- Generated by Doxygen 1.2.13.1 -->
<center>
<a class="qindex" href="index.html">Main Page</a> &nbsp; <a class="qindex" href="namespaces.html">Namespace List</a> &nbsp; <a class="qindex" href="hierarchy.html">Class Hierarchy</a> &nbsp; <a class="qindex" href="classes.html">Alphabetical List</a> &nbsp; <a class="qindex" href="annotated.html">Compound List</a> &nbsp; <a class="qindex" href="files.html">File List</a> &nbsp; <a class="qindex" href="namespacemembers.html">Namespace Members</a> &nbsp; <a class="qindex" href="functions.html">Compound Members</a> &nbsp; <a class="qindex" href="globals.html">File Members</a> &nbsp; <a class="qindex" href="pages.html">Related Pages</a> &nbsp; </center>
<hr><a name="PP_Memory_Management"><h2>Memory Management Rules for TAO's Pluggable Protocol Framework</h2></a>

<p>
<a name="background"><h2>Background</h2></a>

<p>
This document proposes a clearer set of memory management rules for the pluggable protocols framework. To understand this proposal some basic background on how does the pluggable protocol framework works, and how each abstraction relates to the other components in the ORB.
<p>
The pluggable protocol framework uses the Acceptor and Connector patterns, unlike <a class="elRef" doxygen="ACE.tag:../ace/" href="../ace/classACE.html">ACE</a>, however, it must treat all of them homogenously. The basic abstraction in <a class="el" href="namespaceTAO.html">TAO</a>'s pluggable protocol framework is the <code><a class="el" href="classTAO__Transport.html">TAO_Transport</a></code>, an instance of this class represents a single connection, for example, the <a class="el" href="namespaceIIOP.html">IIOP</a> plugin uses one instance of <a class="el" href="classTAO__Transport.html">TAO_Transport</a> for each socket. To integrate this abstraction with the <a class="elRef" doxygen="ACE.tag:../ace/" href="../ace/classACE__Reactor.html">ACE_Reactor</a> framework, all the protocols implemented so far use specializations of the <a class="elRef" doxygen="ACE.tag:../ace/" href="../ace/classACE__Svc__Handler.html">ACE_Svc_Handler</a> class. However, the original design considered the possibility of using protocols without any <a class="elRef" doxygen="ACE.tag:../ace/" href="../ace/classACE.html">ACE</a> abstractions, though in practice this hasn't happenned so far, all changes to the framework should keep this possibility open.
<p>
This is the main source of memory management problems in the pluggable protocol framework: a single entity (a connection) is represented by two instances of two separate classes. On one side the ORB uses an instance of the <a class="el" href="classTAO__Transport.html">TAO_Transport</a> abstraction, on the other the Reactor uses an instance of an <a class="elRef" doxygen="ACE.tag:../ace/" href="../ace/classACE__Svc__Handler.html">ACE_Svc_Handler</a>.
<p>
To complicate matters even further the ORB caches both passively accepted and actively established connections. The actively established connections are cached by the client-side to minimize or amortize the cost of connection establishment. The passively accepted connections are kept in the same cache mainly to support bi-directional <a class="el" href="namespaceGIOP.html">GIOP</a>, however, they also allow us to close both accepted and established idle connections using a single component, this is useful when the ORB shutdowns, but it is crucial in the implementation of connection recycling strategies, where the total number of connections kept by the ORB must be known.
<p>
The design must also support multithreaded clients and servers, in both cases multiple threads may be using a connection simultaneously, for example, multiple client threads can be waiting for replys over the same connection, or multiple server threads can be servicing requests received on the same connection, or, if bi-dir <a class="el" href="namespaceGIOP.html">GIOP</a> is enabled, maybe a mix of both.
<p>
Some aspects of the <a class="el" href="namespaceGIOP.html">GIOP</a> protocol require special treatment of connections with pending requests, both on the server and client side. On the server side connections that have pending requests cannot be closed (section 15.5.1.1 in the <a class="el" href="namespaceCORBA.html">CORBA</a>/<a class="el" href="namespaceIIOP.html">IIOP</a> 2.4 specification), therefore, the ORB needs to know how many requests are pending, at all times. Despite this, it is possible that the underlying connection is broken, for example, because the client crashed. In such cases, the ORB should be able to reclaim the OS resources, but the <a class="el" href="classTAO__Transport.html">TAO_Transport</a> must remain valid until the upcall threads finish. Similarly, the client side should be able to distinguish between orderly and abortive disconnects, essentially the ORB needs to know if a <code>CloseConnection</code> message has been received.
<p>
Finally we must never forget that the ORB can be used in thread-per-connection mode. In this concurrency model there is no reactor used to detect when the connection can accept more input, though normally this is a global setting, it is possible for a pluggable protocol to *always* work in thread-per-connection and no other architecture. Similarly, the ORB can be configured to wait for replys using read() operations, instead of the more generic wait-on-reactor or wait-on-leader-follower strategies. Therefore, we cannot always rely on the Reactor framework to perform all the memory management for us.
<p>
<a name="requirements"><h2>Requirements</h2></a>

<p>
To summarize, the <a class="el" href="classTAO__Transport.html">TAO_Transport</a> class should:
<p>
<ul>
<li>Not be deleted until all threads using it is released by all the threads using it.<li>As many OS and ORB resources must be released when the ORB detects that the connection has been terminated. For example, the socket should be closed and the <a class="elRef" doxygen="ACE.tag:../ace/" href="../ace/classACE__Svc__Handler.html">ACE_Svc_Handler</a>, if any, should be destroyed.<li>Not be deleted until it is removed from the connection cache.<li>Support a mechanism to proactively close the connection.<li>Keep track of the number of pending requests in a connection.</ul>
<a name="rules"><h2>Memory Management Rules</h2></a>

<p>
Instances of <a class="el" href="classTAO__Transport.html">TAO_Transport</a> are reference counted, this is a simple way to share it among the threads using it to send or receive invocations, the cache, and the potential connection handler using it. However, the service handler should follow the standard rules for the Reactor, i.e. the Reactor owns it, and is destroyed as soon as the connection is closed.
<p>
The underlying connection can be closed by the remote peer, in this case, either the Reactor or the thread blocked on <code>read()</code> will detect the problem. Following the normal conventions, the <a class="elRef" doxygen="ACE.tag:../ace/" href="../ace/classACE__Svc__Handler.html">ACE_Svc_Handler</a> would be closed as soon as this is detected. The corresponding <a class="el" href="classTAO__Transport.html">TAO_Transport</a> must be informed, otherwise it could attempt to use a connection already closed.
<p>
Finally if the connection is proactively closed, the <a class="el" href="classTAO__Transport.html">TAO_Transport</a> informs the <a class="elRef" doxygen="ACE.tag:../ace/" href="../ace/classACE__Svc__Handler.html">ACE_Svc_Handler</a>, at this point the <a class="elRef" doxygen="ACE.tag:../ace/" href="../ace/classACE__Svc__Handler.html">ACE_Svc_Handler</a> commits suicide by removing itself from the reactor. Notice that it must still callback the <a class="el" href="classTAO__Transport.html">TAO_Transport</a> in this case.
<p>
<a name="data"><h2>Processing Incoming and Outgoing Data</h2></a>

<p>
The final aspect to consider is the processing of incoming and outgoing data. We are still working on this problem, but the current approach is more complex than it has to be. The usual path is as follows: the Reactor signals (via handle_input) that there is some data available in the socket. The message is forwarded from the <a class="elRef" doxygen="ACE.tag:../ace/" href="../ace/classACE__Svc__Handler.html">ACE_Svc_Handler</a> to the <a class="el" href="classTAO__Transport.html">TAO_Transport</a>, then to several helper classes in the pluggable protocol framework. Eventually a method is invoked on the TAO_Tranport to read the actual data, this forwards on the <a class="elRef" doxygen="ACE.tag:../ace/" href="../ace/classACE__Svc__Handler.html">ACE_Svc_Handler</a> (again), and eventually returns.
<p>
A much simpler approach would be to read the data on the handle_input() method itself, and forward the data up the stream.
<p>
<hr><address><small>Generated on Wed Jan 15 21:01:17 2003 for TAO by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.gif" alt="doxygen" align="middle" border=0 
width=110 height=53></a>1.2.13.1 written by <a href="mailto:dimitri@stack.nl">Dimitri van Heesch</a>,
 &copy;&nbsp;1997-2001</small></address>
</body>
</html>
