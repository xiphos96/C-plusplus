# 18.1 (木の最大安定集合)

17 章で見た通り、最大安定集合問題は一般には NP 困難であり、解決は困難です。しかしながら特殊なグラフに対しては効率よく最大安定集合が求められることがあります。その代表例としては、問題 16.5 でも見たように、二部グラフ上で最大安定集合を求める問題です。

今回は木の最大安定集合を求める問題を考えます。実は、木の葉を貪欲に選んでいく方法で解くことができます。

木の葉頂点 v を一つとり、「頂点 v を含まない安定集合 S があったとき、そのサイズを減らすことなく、頂点 v を含む安定集合へと変形できること」を示しましょう。葉頂点 v に隣接する頂点を u とします。

- S が u を含まないならば、S に v を追加したものも安定集合となっている
- S が u を含むならば、S から u を除去して代わりに v を追加したものも安定集合となっている

というようになります。いずれにしても、安定集合のサイズを減らすことなく、葉頂点 v を含むように変形できることがわかりました。

以上より、木の葉を貪欲に選び、その葉と葉に隣接する頂点を除去していく方法によって最大安定集合を求めることができることがわかりました。

実装上は 13.10 節の「木上の動的計画法」で解説したように、木の頂点を 1 つ選んで根とする方法が便利です。次コードのように実装できます。計算量は頂点数を N として O(N) です。

　

```cpp
#include <iostream>
#include <vector>
using namespace std;
using Graph = vector<vector<int>>;

vector<bool> used;
void rec(const Graph &G, int v, int p = -1) {
    // 子頂点の中に採用済みの頂点があるかどうか
    bool exist = false;
    for (auto ch: G[v]) {
        if (ch == p) continue;

        // 再帰的探索
        rec(G, ch, v);
        if (used[ch]) exist = true;
    }

    // 子頂点の中に採用済みの頂点がなければ採用する
    if (!exist) used[v] = true;
}

int main() {
    // 入力
    int N;
    cin >> N;
    Graph G(N);
    for (int i = 0; i < N - 1; ++i) {
        int u, v;
        cin >> u >> v;
        --u, --v;
        G[u].push_back(v);
        G[v].push_back(u);
    }

    // 頂点 0 を根として探索
    used.assign(N, false);
    rec(G, 0);

    // 数える
    int res = 0;
    for (int v = 0; v < N; ++v) {
        if (used[v]) ++res;
    }
    cout << res << endl;
}
```

　

# 18.2 (EDPC P - Independent Set)

木上の安定集合を数え上げる問題です。一般には NP 困難問題 (とくに #P 完全問題)　ですが、木の特殊構造を活かした解法によって多項式時間で解くことができます。具体的には 18.2 節で解説した「木上の重み付き最大安定集合問題に対する動的計画法」と同様の動的計画法に基づくアルゴリズムによって解決できます。配列 `dp1`, `dp2` を次のように定義しましょう。

-----

- `dp1[v]` ← 頂点 v を根とする部分木内での安定集合のうち、頂点 v を含まないようなものの個数
- `dp2[v]` ← 頂点 v を根とする部分木内での安定集合のうち、頂点 v を含むようなものの個数

-----

計算量は O(N) となります。

　

```cpp
#include <iostream>
#include <vector>
using namespace std;
using Graph = vector<vector<int>>;

// MOD
const int MOD = 1000000007;

// 木上の動的計画法
// dp1: 部分木の根を選ばない場合、dp2: 部分木の根を選ぶ場合
vector<long long> dp1, dp2;
void rec(const Graph &G, int v, int p = -1) {
    // 子頂点を再帰的に探索する
    for (auto ch: G[v]) {
        if (ch == p) continue;
        rec(G, ch, v);
    }

    // dp1: 各部分木の安定集合 (根の選択によらない) の個数の積
    // dp2: 各部分木の安定集合 (根は選ばない) の個数の積
    for (auto ch: G[v]) {
        if (ch == p) continue;
        dp1[v] = dp1[v] * (dp1[ch] + dp2[ch]) % MOD;
        dp2[v] = dp2[v] * dp1[ch] % MOD;
    }
}

int main() {
    // 入力
    int N;
    cin >> N;
    Graph G(N);
    for (int i = 0; i < N - 1; ++i) {
        int u, v;
        cin >> u >> v;
        --u, --v;
        G[u].push_back(v);
        G[v].push_back(u);
    }

    // 頂点 0 を根として探索
    dp1.assign(N, 1), dp2.assign(N, 1);
    rec(G, 0);
    cout << (dp1[0] + dp2[0]) % MOD << endl;
}
```

　

# 18.3 (最大安定集合問題を整数計画問題で)

グラフの各頂点 v に対応する 0-1 変数 x[v] を用意します。安定集合に頂点 v を含めるとき x[v] = 1 として、含めないとき x[v] = 0 であると考えます。まず最大化したい目的関数は sum_v x[v] と表せます (v に対する x[v] の総和)。

そして制約条件は次のように考えられます。グラフの各辺 e = (u, v) に対して、x[u] + x[v] <= 1 を満たす必要があります。

　

# 18.4 (ビンパッキング問題)

「各品物 i について、ビンを順に調べていき、その品物 i を詰めることのできる最初のビンに品物 i を詰める」という貪欲アルゴリズム (First Fit 法) によって使用されたビンの本数を M とします。

このとき、M 本のビンのうちの M - 1 本のビンについては、その容量の半分以上まで品物が詰められた状態になります。なぜなら、もし 2 本以上のビンについてその容量の半分以下までしか詰められていない状態になったとしたならば、それらの中身を 1 本のビンに合併できるからです。これは First Fit 法の動作に矛盾します。

よって、最適解を OPT としたときに 2 OPT > M - 1 が成立します。さらに OPT や M - 1 は整数であるから、2 OPT >= M が導かれます。これは First Fit 法が 2-近似アルゴリズムであることを意味しています。

　



