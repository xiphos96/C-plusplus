# 9.1 (連結リストでスタック・キュー)

双方向連結リストを用いることにしましょう。双方向リストの head と tail に着目します。head や tail に要素を追加したり、head の要素を削除したりすることによって、スタック・キューの機能を実現できます。

具体的には下表のようにすればよいでしょう。いずれも O(1) の計算量で実現できます。

　

| データ構造 | 要素 v を push | pop         |
| ---------- | -------------- | ----------- |
| スタック   | head に追加    | head を削除 |
| キュー     | tail に追加    | head を削除 |

　

# 9.2 (逆ポーランド記法)

`(3 + 4) * (1 - 2)` 

という数式は、逆ポーランド記法では

```
3 4 + 1 2 - *
```

というように表されます。これはスタックを用いて下表のように計算できます。

　

| 途中過程        | スタックの様子 | 備考                                                         |
| --------------- | -------------- | ------------------------------------------------------------ |
| `3`             | [3]            | 数値はスタックの末尾に挿入します                             |
| `3 4`           | [3, 4]         | 数値はスタックの末尾に挿入します                             |
| `3 4 +`         | [7]            | スタックの末尾から 2 個分の要素を取り出して、それらの演算結果を末尾に挿入します |
| `3 4 + 1`       | [7, 1]         | 数値はスタックの末尾に挿入します                             |
| `3 4 + 1 2`     | [7, 1, 2]      | 数値はスタックの末尾に挿入します                             |
| `3 4 + 1 2 -`   | [7, -1]        | スタックの末尾から 2 個分の要素を取り出して、それらの演算結果を末尾に挿入します |
| `3 4 + 1 2 - *` | [-7]           | 最後に残った値が答えです                                     |

　

具体的には次のように実装できるでしょう。計算量は記号の個数を N として O(N) となります。

　

```cpp
#include <iostream>
#include <stack>
#include <string>
using namespace std;

// 逆ポーランド記法で記述された値を計算する
double calc(const string &exp) {
    stack<double> st;
    for (auto c: exp) {
        if (c >= '0' && c <= '9') {
            // '7' のような文字リテラルを 7 のような数値に変換
            double add = c - '0';
            st.push(add);
        } else {
            // 演算子の場合は演算を実施する
            double a = st.top();
            st.pop();
            double b = st.top();
            st.pop();

            // 演算の実施結果をスタックに積む
            if (c == '+') st.push(b + a);
            else if (c == '-') st.push(b - a);
            else if (c == '*') st.push(b * a);
            else st.push(b / a);
        }
    }
    return st.top();
}

int main() {
    string exp = "34+12-*";
    cout << calc(exp) << endl;
}
```

　

# 9.3 (カッコ列の整合性判定)

カッコ列の整合性の判定はスタックを用いて次のようにできます。たとえば `(()(())())(()())` のとき、下の表のようになります。

　

-----

+ 最初はスタックを空の状態にしておく
+ 括弧列を左から順番に見て行き、
    + 左括弧 '(' が来たらスタックに push する
    + 右括弧 ')' が来たら
        + もしスタックが空だった場合には「整合しない」と判定
        + スタックが空でなかった場合は、top 要素を pop する (ここで pop した '(' と手元にある ')' が互いに対応します)

以上の処理を終えたとき、もしスタックが空であれば、括弧列は「整合がとれていた」と判定でき、空でなければ「整合しない」と判定できる

-----

　

| カッコ列           | スタックの中身 |
| ------------------ | -------------- |
| `(`                | [ ( ]          |
| `((`               | [ (, ( ]       |
| `(()`              | [ ( ]          |
| `(()(`             | [ (, ( ]       |
| `(()((`            | [ (, (, ( ]    |
| `(()(()`           | [ (, ( ]       |
| `(()(())`          | [ ( ]          |
| `(()(())(`         | [ (, ( ]       |
| `(()(())()`        | [ ( ]          |
| `(()(())())`       | [ ]            |
| `(()(())())(`      | [ ( ]          |
| `(()(())())((`     | [ (, ( ]       |
| `(()(())())(()`    | [ ( ]          |
| `(()(())())(()(`   | [ (, ( ]       |
| `(()(())())(()()`  | [ ( ]          |
| `(()(())())(()())` | [ ]            |

　

具体的なコードは次のように実装できます。計算量は O(N) となります。

　


```cpp
#include <iostream>
#include <string>
#include <vector>
#include <algorithm>
#include <stack>
using namespace std;

bool check(const string &S) {
    stack<int> st; // 左括弧の index を格納するスタック
    vector<pair<int,int> > ps; // 対応を表すペア

    // ループを回す
    for (int i = 0; i < (int)S.size(); ++i) {
        if (S[i] == '(') st.push(i);
        else {
            if (st.empty()) {
                cout << "error" << endl;
                return false;
            }
            int t = st.top();
            st.pop();
            ps.push_back({t, i});
        }
    }

    // スタックが空でなかったら左括弧が過剰
    if (!st.empty()) {
        cout << "too many (" << endl;
        return false;
    }

    // 整合を出力
    sort(ps.begin(), ps.end());
    for (int i = 0; i < (int)ps.size(); ++i) {
        if (i) cout << ", ";
        cout << "(" << ps[i].first << ", " << ps[i].second << ")";
    }
    cout << endl;
    return true;
}

int main() {
    check("((()())())"); // (0, 9) (1, 6), (2, 3), (4, 5), (7, 8)
    check("())"); // error
    check("(()"); // too many (
}
```

