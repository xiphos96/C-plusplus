# 12.1

さまざまな方法が考えられます。ここではソーティング後に二分探索 (lower_bound()) を用いる方法を考えてみましょう。

まず配列 `a` をソートしてできる配列を `b` としましょう (配列 `a` 自体には変更を加えないようにしておきます)。このとき、`a` の各要素 `a[i]` に対して

　　`lower_bound(b.begin(), b.end(), a[i]) - b.begin()`

を取得することで、`a[i]` が `b` の中で何番目の要素かが求められます (0-indexed)。計算量は

- ソートする部分：O(N log N)​
- 各要素に対して二分探索する部分：O(N log N)​

によって、全体として O(N log N)​ となります。

　

```cpp
#include <algorithm>
#include <vector>
#include <iostream>
using namespace std;

int main() {
    // 入力
    int N;
    cin >> N;
    vector<int> a(N);
    for (int i = 0; i < N; ++i) cin >> a[i];

    // ソート
    auto b = a;
    sort(b.begin(), b.end());

    // 各要素について二分探索
    for (int i = 0; i < N; ++i) {
        cout << lower_bound(b.begin(), b.end(), a[i]) - b.begin() << endl;
    }
}
```

　

# 12.2

N 個のお店のうち、どのような順序で回ればよいかを考えましょう。基本的には価格の安い (`A[i]` が小さい) お店から順に回ればよいでしょう。

そこでまず、価格が安い順に、N 個のお店を並べ替えましょう。この処理は O(N log N) の計算量でできます。そしてこの並びの順に、購入数が M に達するまで、お店を回っていきましょう。具体的なアルゴリズムについては、次の記事に記しています。

[AtCoder ABC 121 C - Energy Drink Collector](https://drken1215.hatenablog.com/entry/2019/05/15/012700)

　

# 12.3

ヒープを活用します。次の 2 種類のヒープを用意しましょう。

- 現在までに挿入された整数のうち、小さい順に K 個を管理するヒープ `low`
- 現在までに挿入された整数のうち、それ以外の値を管理するヒープ `high`

このうち、ヒープ `low` については「最大値を取得」「最大値を削除」できるようにしておいて、ヒープ `high` については「最小値を取得」「最小値を削除」できるようにしておきます。

まず、`a[0]`, `a[1]`, ..., `a[K-1]` をヒープ `low` に挿入しておきます。その後、i = K, K+1, ..., N-1 に対して、次のように処理していきます。



-----

ヒープ `low` の最大値を M とします。

- `a[i] >= M` である場合には、`a[i]` を ヒープ `high` に 挿入します
- `a[i] < M` である場合には、
  - ヒープ `low` の最大値を除去して、それをヒープ `high` に挿入します
  - ヒープ `low` に値 `a[i]` を挿入します

この作業後において、ヒープ `low` の最大値が答えになります

-----

　

# 12.4

前半は「マージソートの計算量解析」とまったく同様に示せます。後半については、T(N) = O(N (log N)^2) となります。

　

# 12.5 (median of medians)

N 個の要素のうち K 番目に小さい値を求めるのは、一見すると「ソートして K 番目を出力する」という O(N log N) の解法よりも高速な計算量を達成するのは不可能にも思えてしまいます。しかし、分割統治法に基づく O(N) なアルゴリズムが知られているのです (ただし定数倍の影響が大きく、実際上はかならずしも高速でないことが知られています)。

さて、配列 `a` に対して k 番目に小さな値を求めるアルゴリズムを rec(a, k) として、次のような再帰的アルゴリズムを考えてみましょう。一部処理内容を日本語で記述しています。

　

```cpp
int rec(a, k) {
    // 終端条件
    if (a.size() <= 100) {
         sort(a.begin(), a.end());
         return a[k];
    }
  
    // a の要素を 5 個ずつ切り出して、各グループのメディアンを集める
    vector<int> a2;
    for (int i = 0; i < a.size(); i += 5) {
        a2.push_back(a[i:i+5] のメディアン); 
    }
  
    // a2 のメディアンを求める
    int m = rec(a2, a.size()/10);
  
    // a を 3 つのグループに分ける
    vector<int> p, q, r;
    for (int i = 0; i < a.size(); ++i) {
        if (a[i] < m) p.push_back(a[i]);
        else if (a[i] == m) q.push_back(a[i]);
        else r.push_back(a[i]);
    }

    // 再帰的に解く
    int res;
    if (k <= p.size()) return rec(p, k);
    else if (k <= p.size() + q.size()) return m;
    else return rec(r, k - p.size() - q.size());
}
```

　

まず終端条件では、配列のサイズが 100 (他の定数ならばなんでもよい) 以下になった時点で、配列に対するソート処理を行っています。ここで配列のサイズが定数以下であることが保証されていることから、この処理は定数時間とみなせます。さて、配列 a のサイズを N として、このアルゴリズムの計算時間を T(n) と表すことにすると、次のような漸化式で評価できます。

　　T(n) <= T(n/5) + T(7n/10) + O(n)

まず T(n/5) とは、配列 `a2` のメディアンを求める処理を表します。次に T(3n/4) とは、再帰的に解く部分を表します。注意したいことは、

- `p.size()` <= 7n/10
- `r.size()` <= 7n/10

が成り立つことです。たとえば `p` について考えたとき、配列 `a`を 5 個ずつ分けたグループのうち、メディアンが m より大きいグループ (そのグループ数は概ね n/10 個あります) については、その上位 3 個の要素は m 以上であることが確実だからです。つまり、少なくとも 3n/10 個の要素は m 以上であることが確定します。以上から、配列 `p` のサイズは 7n/10 以下であることがわかりました。配列 `r`についても同様です。

さて、T(n) の漸化式において、n/5 + 7n/10 = 9n/10 であり、これは n よりも小さくなっています。つまり、分割統治法に基づいて再帰を進めたときに、元の問題よりもサイズの総和が小さな部分問題群へと帰着できていることがわかります。このようなとき、12.4.3 節の議論 (a < b の場合) と同様に、計算量が O(n) になることが示されます。

以上のように、分割統治法に基づく再帰的アルゴリズムであって、分割した部分問題のサイズの総和がもとの問題よりも小さいようなものを、とくに**縮小法**とよぶことがあります。

　

# 12.6 (Tenka1 Programming Contest F - ModularPowerEquations!!)

極めて難しい問題です。分割統治法に基づく再帰的アルゴリズムが設計できます。その計算量解析において、**縮小法**が適用できて、計算量が小さく抑えられる構造となっています。解法の詳細については、公式解説を参照しましょう。

[公式解説](https://img.atcoder.jp/tenka1-2017/editorial.pdf)

　

















