Program 11.12:Searching an m-way search tree====================================// Search an m-way search tree for an element with key x.// Return the element if found. Return NULL otherwise.E sub 0.K = - MAXKEY;for (*p = root; p; p = A sub i){  Let p have the format n, A sub 0 , (E sub 1 , A sub 1 ), ... , (E sub n , A sub n );  E sub {n+1}.K = MAXKEY;  Determine i such that E sub i . K <= x < E sub i+1 . K;  if ( x == E sub i.K) return E sub i;}// x is not in the treereturn NULL;====================================Program 11.2:Insertion into a B-tree====================================// Insert element x into a disk resident B-tree.Search the B-tree for an element E with key x . K.if such an E is found, replace E with x and return;Otherwise, let p be the leaf into which x is to be inserted;q = NULL;for (e = x; p; p = p->parent()){// (e,q) is to be inserted into p  Insert (e,q) into appropriate position in node p;  Let the resulting node have the form:  n,A sub 0 , (E sub 1 , A sub 1 ),... ,( E sub n , A sub n );  if ( n <= m-1) { // resulting node is not too big    write node p to disk; return;  }  // node p has to be split  Let p and q be defined as in Eq. (\n(H1.5);  e = E sub {lcm/2rc};  write nodes p and q to the disk;}// a new root is to be createdCreate a new node r with format 1,root,(e,q);root=r;write root to disk;====================================Program 11.3:Deletion from B-tree that resides on disk====================================// Delete element with key x.Search the B-tree for the node p that contains the element whose key is x;if there is no such p return;   // no element to deleteLet p be of the form n,A sub 0 , (E sub 1 , A sub 1 ),... ,(E sub n , A sub n ) and E sub i . K=x ;if p is not a leaf {  Replace E sub i with the element with the smallest key in subtree A sub i;  Let p be the leaf of A sub i from which this smallest element was taken;  Let p be of the form n,A sub 0 , (E sub 1 , A sub 1 ),... ,(E sub n , A sub n );  i =1;}// delete E sub i from node p, a leafDelete (E sub i ,A sub i ) from p; n --;while ((n<lcm/2rc-1 ) && p != root)  if p has a nearest right sibling q {    Let q:n sub q , A  sub 0 sup q , (E  sub 1 sup q , A  sub 1 sup q ),... ,(E  sub {n sub q} sup q , A sub {n sub q} sup q );    Let r:n sub r , A  sub 0 sup r , (E  sub 1 sup r , A  sub 1 sup r ),... ,(E  sub {n sub r} sup r , A  sub {n sub r} sup r ) be the parent of p and q;    Let A sub j sup r =q and A sub j-1 sup r =p;    if (n sub q > = lcm/2rc) {// rotation      (E sub n+1 , A sub n+1 ) = (E sub j sup r , A sub 0 sup q);       n=n+1;       // update node p      E sub j sup r =E sub 1 sup q;  // update node r      (n sub q , A sub 0 sup q , (E sub 1 sup q , A sub 1 sup q ),... )= \c      (n sub q -1,A sub 1 sup q , (E sub 2 sup q , A sub 2 sup q ) , ...);                          // update node q      write nodes p, q and r to disk; \c      return;    } // end of rotation    // combine p, E sub j sup r, and q    s=2*lcm/2rc-2;    write s,A sub 0 , (E sub 1 , A sub 1 ),... ,(E sub n , A sub n ) , ( E sub j sup r , A sub 0 sup q), \c    (E  sub 1 sup q , A  sub 1 sup q ),... ,(E  sub {n sub q} sup q , A  sub {n sub q} sup q )    to disk as node p;    // update for next iteration    (n,A sub 0 ... )=(n sub r - 1, A  sub 0 sup r ,... ,(E  sub j-1 sup r , A  sub j-1 sup r ), (E  sub j+1 sup r , A  sub j+1 sup r )... )    p=r;  } // end of if p has a nearest right sibling  else {// node p must have a left sibling    // this is symmetric to the case where p has a right sibling,    // and is left as an exercise  } // end of if-else and whileif ( n) write p: (n,A sub 0 , ... ,(E sub n , A sub n ))else root=A sub 0; // new root====================================Program 11.4:Searching a B+-tree====================================// Search a B+-tree for an element with key x.// Return the element if found. Return NULL otherwise.if the tree is empty return NULL;K sub 0 = - MAXKEY;for (*p = root; p is an index node; p = A sub i){  Let p have the format n,A sub 0 , (K sub 1 , A sub 1 ),... ,(K sub n , A sub n );  K sub {n+1} = MAXKEY;  Determine i such that K sub i <= x < K sub i+1;}// search the data node pSearch p for an element E with key x;if such an element is found return Eelse return NULL;====================================