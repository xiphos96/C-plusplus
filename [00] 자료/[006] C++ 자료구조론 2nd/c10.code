Program 10.1:Finding an optimal binary search tree====================================void Obst(double *p, double *q, int n ){  for (int i = 0; i < n; i++) {    w[i][i] = q[i]; r[i][i] = c[i][i] = 0;       // initialize    w[i][i+1] = q[i] + q[i+1] + p[i+1];  // optimal trees with one node    r[i][i+1] = i + 1;    c[i][i+1] = w[i][i+1];  }  w[n][n] = q[n]; r[n][n] = c[n][n] = 0;  for (int m = 2; m <= n; m++)  // find optimal trees with m nodes    for (i = 0; i <= n - m; i++)    {      int j = i + m;      w[i][j] = w[i][j-1] + p[j] + q[j];      int k = KnuthMin(i,j);      // KnuthMin returns a value k in the range [r[i][j-1], r[i+1][j]]      // minimizing c[i][k-1]+c[k][j]      c[i][j] = w[i][j] + c[i][k-1] + c[k][j]; // Eq. (\n(H1.3)      r[i][j] = k;    }} // end of Obst====================================Page 574====================================template <class K, class E> class AVL;template <class K, class E>class AvlNode {friend class AVL<K, E>;public AvlNode(const K& k, const E& e)  {key = k; element = e; bf= 0; leftChild = rightChild = 0;}private:  K key;  E element;  int bf;  AvlNode<K, E> *leftChild, *rightChild;};template <class K, class E>class AVL {public:  AVL() : root (0) {};  E& Search(const K&) const;  void Insert(const K&, const E&);  void Delete(const K&);  private:  AvlNode<K, E> *root;};====================================Page 574====================================template <class K, class E>void AVL<K, E>::Insert(const K& k, const E& e){  if (!root) { // special case: empty tree    root = new AvlNode<K, E> (k, e);    return;  }  // Phase 1: Locate insertion point for e.  AvlNode<K, E> *a = 0,   // most recent node with bf = +-1    *pa = 0,  // parent of a    *p = root,    // p moves through the tree    *pp = 0;    // parent of p  while(p) {    if (p->bf) {a = p; pa = pp;}    if (k < p->key) {pp = p; p = p->leftChild;} // take left branch    else if (k > p->key) {pp = p; p = p->rightChild;}    else {p-> element = e; return;}  // k already in tree  } // end of while    //Phase 2: Insert and rebalance. k is not in the tree and  // may be inserted as the appropriate child of pp.  AvlNode<K, E> *y = new AvlNode<T>(k, e);  if (k < pp->key) pp->leftChild = y;   // insert as left child  else pp->rightChild = y; // insert as right child    //Adjust balance factors of nodes on path from a to pp. By the definition  // of a, all nodes on this path presently have a balance factor of 0. Their new  // balance factor will be +-1. d=+1 implies that k is inserted in the left subtree  // of a. d=-1 implies that k is inserted in the right subtree of a.  int d;  AvlNode<K, E> *b,  // child of a  *c; // child of b  if (k > a->key) {b = p = a->rightChild; d = -1;}  else {b = p = a->leftChild; d = 1;}  while (p != y)    if (k > p->key) { // height of right increases by 1      p->bf = -1; p = p->rightChild;    }    else { // height of left increases by 1      p->bf = 1; p = p->leftChild;    }    // Is tree unbalanced?  if ( !(a->bf) || !(a->bf + d) ) { // tree still balanced    a->bf += d; return;  }  // tree unbalanced, determine rotation type  if (d == 1) {// left imbalance    if (b->bf == 1) {// rotation type LL      a->leftChild = b->rightChild;      b->rightChild = a; a->bf = 0; b->bf = 0;    }     else { // rotation type LR      c = b->rightChild;      b->rightChild = c->leftChild;      a->leftChild = c->rightChild;      c->leftChild = b;      c->rightChild = a;      switch (c->bf) {        case 1:          a->bf = -1; b->bf = 0;          break;        case -1:          b->bf = 1; a->bf = 0;          break;        case 0:          b->bf = 0; a->bf = 0;          break;      }      c->bf = 0; b = c; // b is the new root    } // end of LR  } // end of left imbalance  else { // right imbalance: this is symmetric to left imbalance  }    // Subtree with root b has been rebalanced.  if (!pa) root = b;  else if (a == pa->leftChild) pa->leftChild = b;  else pa->rightChild = b;  return;} // end of AVL::Insert====================================Program 10.5:Splitting a red-black tree====================================Step 1: Search A for the node P that contains the element with key i. Copy this        Element to the referenc parameter x. Initialize B and C to be the left        And right subtrees of P, respectively.Step 2:for (Q = parent(P); Q; P = Q, Q = parent(Q))  if (P == Q->leftChild)     C.ThreeWayJoin(C, Q->data, Q->rightChild)  else B.ThreeWayJoin(Q->leftChild, Q->data, B);}====================================Page 599====================================b->leftChild = x->leftChild;b = b->leftChild;x->leftChild = b->rightChild;b->rightChild = x;x = b->leftChild;====================================