Program 9.1:Class definition of a double-ended priority queue====================================template <class T>class DEPQ {public:  virtual const T& GetMin() const = 0;  virtual const T& GetMax() const = 0;  virtual void Insert(const T&) = 0;  virtual void DeleteMin() = 0;  virtual void DeleteMax() = 0;};====================================Program 9.2:class definition of a leftist tree====================================template <class T> class MinLeftistTree; // forward declarationtemplate <class T>class LeftistNode {friend class MinLeftistTree<T>;private:  T data;  LeftistNode *leftChild, *rightChild;  int shortest;};template <class T>class MinLeftistTree : public MinPQ<T> {public:  // constructor  MinLeftistTree(LeftistNode<T> *init = 0) root(init) { };    // the four min leftist tree operations  const T& GetMin() const;  void Insert(const T&);  T& DeleteMin();  void Meld(MinLeftistTree<T>*);private:  LeftistNode<T>* Meld(LeftistNode<T>*, LeftistNode<T>*);  LeftistNode<T> *root;};====================================Program 9.3:Melding two min leftist trees====================================template <class T>void MinLeftistTree<T>::Meld(MinLeftistTree<T> *b){// Combine the min leftist tree b with the given min leftist tree.// b is set to the empty min leftist tree.  if (!root) root = b->root;  else if (b->root) root = Meld(root, b->root);  b->root = 0 ;}template<class T>LeftistNode<T>* MinLeftistTree<T>::Meld(LeftistNode<T> *a,LeftistNode<T> *b){// Recursive function to meld two nonempty min leftist trees rooted// at a and b. The root of the resulting min leftist tree is returned.  // set a to be min leftist tree with smaller root.  if (a->data > b->data) swap(a, b);    // create binary tree such that the smallest key in each subtree is in the root  if (!a->rightChild) a->rightChild = b;  else a->rightChild = Meld(a->rightChild, b);    // leftist tree property  if (!a->leftChild || a->leftChild->shortest < a->rightChild->shortest)    // interchange subtrees    swap(a->leftChild, a->rightChild);    // set shortest data member  if (!a->rightChild) a->shortest = 1;  else a->shortest = a->rightChild->shortest + 1;  return a ;}====================================Program 9.4:Class definition of a binomial heap====================================template <class T> class BinomialHeap; // forward declarationtemplate <class T>class BinomialNode {friend class BinomialHeap<T>;private:  T data;  BinomialNode<T> *child, *link;  int degree;};template <class T>class BinomialHeap : public MinPQ<T> {public:  BinomialHeap(BinomialNode<T> *init = 0) min(init) { };    // the four binomial heap operations  const T& GetMin() const;  void Insert(const T&);  T& DeleteMin();  void Meld(BinomialHeap<T>*);private:  BinomialNode<T> *min;};====================================Program 9.5:Steps in a delete-min operation====================================Step 1:[Handle empty B-heap]if (!min) throw QueueEmpty();Step 2:[Deletion from nonempty B-heap]x = min->data;y = min->child;       delete min from its circular list;following this deletion, min points to                             	  any remaining node in the resulting list;  if there is no such node, then   	  min = 0;Step 3:[Min-tree joining]Consider the min trees in the lists min and y;join    	  	  together pairs of min trees of the same degree untilall remaining min   	  	  trees have different degrees;Step 4:[Form min tree root list]Link the roots of the remaining min trees (if  	  	  any) together to form a circular list;set min to point to the root (if                                      any) with minimum key;return x;====================================Program 9.6:Code to handle min tree p encountered during...====================================for (d = p->degree; tree[d]; d++){  JoinMinTrees(p, tree[d]) ;  tree[d] = 0 ;}tree[d] = p ;====================================Program 9.7:Class definition for symmetric min-max heap====================================Code segment starting ...template <class T>class SMMH : public DEPQ {public:  SMMH(int initialCapacity = 10);  ~SMMH() {delete [] h;}    const T& GetMin() const  {// return min element    if (last == 1) throw QueueEmpty();    return h[2];  }    const T& GetMax() const  {// return max element    if (last == 1) throw QueueEmpty();    if (last == 2) return h[2];    else return h[3];  }    void Insert(const T&);  void DeleteMin();  void DeleteMax();private:  int last;                   // position of last element in queue  int arrayLength; // queue capacity + 2  T *h;          // element array};====================================Program 9.8:Constructor for SMMH====================================template <class T>SMMH<T>::SMMH(int initialCapacity){// Constructor.  if (initialCapacity < 1)  {    ostringstream s;    s << "Initial capacity = " << initialCapacity << " Must be > 0";    throw IllegalParameterValue(s.str());  }  arrayLength = initialCapacity + 2;  h = new T[arrayLength];  last = 1;}====================================Program 9.9:Insertion into a symmetric min-max heap====================================template <class T>void SMMH<T>::Insert(const T& x){// Insert x into the SMMH.  // increase array length if necessary  if (last == arrayLength - 1)  {// double array length    ChangeSize1D(h, arrayLength, 2 * arrayLength);    arrayLength *= 2;  }  // find place for x  // currentNode starts at new leaf and moves up tree  int currentNode = ++last;  if (last % 2 == 1 && x < h[last - 1])  {// left sibling must be smaller, P1    h[last] = h[last - 1];    currentNode--;  }  bool done = false;  while (!done && currentNode >= 4)  {// currentNode has a grandparent    int gp = currentNode / 4;    // grandparent    int lcgp = 2 * gp;        // left child of gp    int rcgp = lcgp + 1;      // right child of gp    if (x < h[lcgp])    {// P2 is violated      h[currentNode] = h[lcgp];      currentNode = lcgp;    }    else if (x > h[rcgp])    {// P3 is violated         h[currentNode] = h[rcgp];         currentNode = rcgp;    }    else done = true;    // neither P2 nor P3 violated  }  h[currentNode] = x;}====================================