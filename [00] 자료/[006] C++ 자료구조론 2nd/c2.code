Program 2.1:Definition of the C++ class Rectangle===============================================#ifndef RECTANGLE_H#define RECTANGLE_H// In the header file Rectangle.hclass Rectangle {public:          //  the following members are public  // the next four members are member functions  Rectangle();              // constructor  ~Rectangle();      // destructor  int GetHeight();   // returns the height of the rectangle  int GetWidth();    // returns the width of the rectangleprivate:     // the following members are private  // the following members are data members  int xLow, yLow, height, width;  // (xLow, yLow) are the coordinates of the bottom left corner of the rectangle};#endif===============================================Program 2.2:Implementation of operations on Rectangle===============================================// In the source file Rectangle.cpp#include "Rectangle.h"// The prefix "Rectangle::" identifies GetHeight() and GetWidth() as member// functions belonging to class Rectangle. It is required because the member// functions are implemented outside their class definitionint Rectangle::GetHeight() { return height;}int Rectangle::GetWidth() { return width;}===============================================Program 2.3:A C++ code fragment....===============================================// In a source file main.cpp#include <iostream>#include "Rectangle.h"main() {  Rectangle r, s;              // r and s are objects of class Rectangle  Rectangle *t = &s;   // t is a pointer to class object s   .   .  // use cdot to access members of class objects.  // use -> to access members of class objects through pointers.  if (r.GetHeight() * r.GetWidth()   > t->GetHeight() * t->GetWidth())    cout << " r ";  else cout << " s ";  cout << "has the greater area" << endl;}===============================================Program 2.4:Definition of a constructor for Rectangle===============================================Rectangle::Rectangle( int x, int y, int h, int w){  xLow = x; yLow = y;  height = h; width = w;}===============================================Program 2.5:Sophisticated definition of a constructor for Rectangel===============================================Rectangle::Rectangle( int x = 0, int y = 0, int h = 0, int w = 0): xLow (x), yLow (y), height (h), width (w){ }===============================================Program 2.6:Overloading operator==for class Rectangle===============================================bool Rectangle::operator== (const Rectangle& s){  if (this == &s) return true;  if ((xLow == s.xLow) && (yLow == s.yLow)    && (height == s.height)  &&  (width == s.width) ) return true;  else return false;}===============================================Program 2.7:Overloading operator<<for class Rectangle===============================================ostream& operator<< (ostream& os, Rectangle& r){  os << "Position is: " << r.xLow << " ";  os << r.yLow << endl;  os << "Height is: " << r.height << endl;  os << "Width is: " << r.width << endl;  return os;}===============================================ADT 2.1:Abstract data type NaturalNumber===============================================class NaturalNumber {// An ordered subrange of the integers starting at zero and ending at// the maximum integer (MAXINT) on the computer.public:  NaturalNumber Zero( );  // Returns 0.    bool IsZero( );  // If *this is 0, return true; otherwise, return false.    NaturalNumber Add(NaturalNumber y);  // Return the smaller of *this + y and MAXINT.    bool Equal(NaturalNumber y);  // Return true if *this == y; otherwise return false.    NaturalNumber Successor( );  // If *this is MAXINT return MAXINT; otherwise return *this + 1.    NaturalNumber Subtract(NaturalNumber y);  // If *this < y, return 0; otherwise return *this -~y.};===============================================ADT 2.2:Abstract data type GeneralArray===============================================class GeneralArray {// A set of pairs <index, value> where for each value of index in IndexSet// there is a value of type float .  IndexSet is a finite ordered set of one or more// dimensions, for example, {0, ... , n-1} for one dimension, {(0, 0),// (0, 1), (0, 2), (1, 0), (1, 1), (1, 2), (2, 0), (2, 1), (2, 2)} for two dimensions, etc.public:  GeneralArray(int j, RangeList list, float initValue = defaultValue);  // This constructor creates a j dimensional array of floats; the  // range of the kth dimension is given by the kth element of list. For each  // index i in the index set, insert <i, initValue> into the array.    float Retrieve(index i);  // If i is in the index set of the array, return the float associated with i  // in the array; otherwise throw an exception.    void Store(index i, float x);  // If i is in the index set of the array, replace the old value associated with i  // by x; otherwise throw an exception.}; // ===============================================ADT 2.3:Abstract data type Polynomial===============================================class Polynomial {// p(x) = a sub 0 x sup e sub 0 + ... +a sub n x sup e sub n; a set of ordered pairs of <e sub i, a sub i>,// where a sub i is a nonzero float coefficient and e sub i is a non-negative integer exponent.public:  Polynomial();  // Construct the polynomial p(x) = 0.    Polynomial Add(Polynomial poly);  // Return the sum of the polynomials *this and poly.    Polynomial Mult(Polynomial poly);  // Return the product of the polynomials *this and poly.    float Eval(float f);  // Evaluate the polynomial *this at f and return the result.};===============================================Page 89===============================================private:int degree;              // degree <= MaxDegreefloat coef[MaxDegree+1]; // coefficient array===============================================Page 89===============================================private:int degree; float *coef;===============================================Page 89===============================================Polynomial::Polynomial(int d){  degree = d;  coef = new float [degree+1];}===============================================Page 90==============================================class Polynomial ; // forward declarationclass Term {friend Polynomial;private:float coef;   // coefficientint exp; // exponent};===============================================Page 90===============================================private:  Term *termArray;   // array of nonzero terms  int capacity;  // size of termArray  int terms;    // number of nonzero terms===============================================Program 2.8:Adding two polynomials=============================================== 1  Polynomial Polynomial::Add(Polynomial b) 2{// Return the sum of of the polynomials *this and b. 3     Polynomial c; 4     int aPos = 0, bPos = 0; 5     while ((aPos < terms) && (bPos < b.terms)) 6        if ((termArray[aPos].exp == b.termArray[bPos].exp) { 7                    float t = termArray[aPos].coef + b.termArray[bPos].coef; 8                    if (t) c.NewTerm(t, termArray[aPos].exp); 9                     aPos++; bPos++;10        }11        else if ((termArray[aPos].exp < b.termArray[bPos].exp) {12                    c.NewTerm(b.termArray[bPos].coef, b.termArray[bPos].exp);13                    bPos++;14        }15        else {16                    c.NewTerm(termArray[aPos].coef, termArray[aPos].exp);17                    aPos++;18        } 19    // add in remaining terms of *this20    for (; aPos < terms ; aPos++)21         c.NewTerm(termArray[aPos].coef, termArray[aPos].exp);22    // add in remaining terms of b(x)23    for (; bPos < b.terms; b++)24         c.NewTerm(b.termArray[bPos].coef, b.termArray[bPos].exp);25    return c;26}===============================================Program 2.9:Adding a new term, doubling array size when necessary===============================================void Polynomial::NewTerm(const float theCoeff, const int theExp){// Add a new term to the end of termArray.  if (terms == capacity)  {// double capacity of termArray    capacity *= 2;    term *temp = new term[capacity];    // new array    copy(termArray, termArray + terms, temp);    delete [] termArray;        // deallocate old memory    termArray = temp;  }  termArray[terms].coef = theCoeff;  termArray[terms++].exp = theExp;} ===============================================Page 94===============================================private:  static Term *termArray;  static int capacity;  static int free ;  int start, finish;===============================================Page 94===============================================int Polynomial::capacity = 100;Term Polynomial::termArray = new Term[100];int Polynomial::free = 0; // location of next free location in termArray===============================================ADT 2.4:Abstract data type SparsMatrix===============================================class SparseMatrix{// A set of triples, <row, column, value>, where row and column are non-negative// integers and form a unique combination; value is also an integer.public:  SparseMatrix(int r, int c, int t);  // The constructor function creates a SparseMatrix with  // r rows, c columns, and a capacity of t nonzero terms.    SparseMatrix Transpose();  // Returns the SparseMatrix obtained by interchanging the row and column  // value of every triple in *this.    SparseMatrix Add(SparseMatrix b);  // If the dimensions of *this and b are the same, then the matrix produced by  // adding corresponding items, namely those with identical row and column  // values is returned; otherwise, an exception is thrown.    SparseMatrix Multiply(SparseMatrix b);  // If the number of columns in *this equals the number of rows in b then the  // matrix d produced by multiplying *this and b according to the formula  // d[i][j] = sum (a[i][k].b[k][j]), where d[i][j] is the (i, j)th element, is returned.  //  k ranges from 0 to one less than the number of columns in *this;  //  otherwise, an exception is thrown. };===============================================Page 98===============================================class SparseMatrix ; // forward declarationclass MatrixTerm {friend class SparseMatrixprivate:  int row, col, value;};private:  int rows, cols, terms, capacity;  MatrixTerm *smArray;===============================================Page 99===============================================for (each row i)store (i,j,value) of the original matrix as (j,i,value) of the transpose;===============================================Page 99===============================================for (all elements in column j)store (i,j,value) of the original matrix as (j,i,value) of the transpose;===============================================Program 2.10:Transposing a matrix=============================================== 1    SparseMatrix SparseMatrix::Transpose( ) 2{// Return the transpose of *this. 3   SparseMatrix b(cols, rows, terms);  // capacity of b.smArray is terms 4   if (terms > 0) 5    {// nonzero matrix 6       int currentB = 0 ; 7       for (int c = 0; c < cols ; c++) // transpose by columns 8           for (int i = 0 ; i <  terms ; i++) 9           // find and move terms in column c10              if (smArray[i].col == c)11              {12                 b.smArray[currentB].row = c;13                 b.smArray[currentB].col = smArray[i].row;14                 b.smArray[currentB++].value = smArray[i].value;15              }16    } // end of if (terms > 0)17    return b;18} ===============================================Page 100===============================================for (int j = 0 ; j < cols ; j++)for (int i = 0 ; i < rows ; i++)b[j][i] = a[i][j];===============================================Program 2.11:Transposing a matrix faster=============================================== 1   SparseMatrix SparseMatrix::FastTranspose() 2{// Return the transpose of *this in O(terms+cols) time. 3    SparseMatrix b(cols,rows,terms); 4    if (terms > 0) 5    {// nonzero matrix 6        int *rowSize = new int[cols]; 7        int *rowStart = new int[cols]; 8        // compute rowSize[i] = number of terms in row i of b 9         fill(rowSize, rowSize+cols,0);   // initialize10        for (i = 0 ; i < terms ; i++) rowSize[smArray[i].col]++ ;11        // rowStart[i] = starting position of row i in b12        rowStart[0] = 0 ;13        for (i = 1 ; i < cols ; i++) rowStart[i] = rowStart[i-1] + rowSize[i-1] ;14        for (i = 0 ; i < terms ; i++)15        {// copy from *this to b16            int j = rowStart[smArray[i].col];17            b.smArray[j].row = smArray[i].col;18            b.smArray[j].col = smArray[i].row ;19            b.smArray[j].value = smArray[i].value ;20            rowStart[smArray[i].col]++ ;21        }  // end of for22        delete [] rowSize ;23        delete [] rowStart ;      24    } // end of if25    return b ;26} ===============================================Program 2.12:Storing a matrix term===============================================void  SparseMatrix::StoreSum (const int sum, const int r, const int c){// If sum != 0, then it along with its row and column position are stored as the// last term in *this.  if (sum != 0) {    if (terms == capacity)      ChangeSize1D(2 * capacity);  // double size    smArray[terms].row = r ;    smArray[terms].col = c ;    smArray[terms++].value = sum;  } }===============================================Program 2.13:Change the size of a 1-dimensional array===============================================void ChangeSize1D(const int newSize){// Change the size of smArray to newSize.  if (newSize < terms) throw "New size must be >= number of terms";  MatrixTerm *temp = new MatrixTerm[newSize];  // new array  copy(smArray, smArray + terms, temp);  delete [] smArray;  // deallocate old memory  smArray = temp;  capacity = newSize;}===============================================Program 2.14: Multiplying sparse matrices=============================================== 1 SparseMatrix SparseMatrix::Multiply(SparseMatrix b) 2 {// Return the product of the sparse matrices *this and b. 3     if (cols != b.rows) throw "Incompatible matrices"; 4     SparseMatrix bXpose = b.FastTranspose(); 5     SparseMatrix d(rows,b.cols,0); 6     int currRowIndex = 0, 7       currRowBegin = 0, 8       currRowA = smArray[0].row; 9     // set boundary conditions10      if (terms == capacity) ChangeSize1D(terms + 1);11      bXpose.ChangeSize1D(bXpose.terms + 1);12      smArray[terms].row = rows;13      bXpose.smArray[b.terms].row = b.cols;14      bXpose.smArray[b.terms].col = -1 ;15      int sum = 0;16      while (currRowIndex < terms)17      {// generate row currentRowA of d18         int currColB = bXpose.smArray[0].row;19         int currColIndex = 0;20         while (currColIndex <= b.terms)21         {// multiply row currRowA of *this by column currColB of b22            if (smArray[currRowIndex].row != currRowA)23            {// end of row currRowA24               d.StoreSum(sum, currRowA, currColB);25               sum = 0 ;   // reset sum26               currRowIndex = currRowBegin;27               // advance to next column28               while (bXpose.smArray[currColIndex].row == currColB)29                     currColIndex++;30               currColB = bXpose.smArray[currColIndex].row;31            }32            else if (bXpose.smArray[currColIndex].row != currColB)33            {// end of column currColB of b34               d.StoreSum(sum, currRowA, currColB);35               sum = 0 ;   // reset sum36               // set to multiply row currRowA with next column37               currRowIndex = currRowBegin;38               currColB = bXpose.smArray[currColIndex].row;39            }40            else41               if (smArray[currRowIndex].col <42                             bXpose.smArray[currColIndex].col)43                      currRowIndex++ ;   // advance to next term in row44               else if (smArray[currRowIndex].col ==45                             bXpose.smArray[currColIndex].col)46                      {// add to sum47                         sum += smArray[currRowIndex].value *48                                   bXpose.smArray[currColIndex].value;49                         currRowIndex++; currColIndex++;50                      }51                  else currColIndex++;  // next term in currColB52         } // end of while (currColIndex <= b.terms)53         while (smArray[currRowIndex].row == currRowA) // advance to next row54            currRowIndex++;55         currRowBegin = currRowIndex;56         currRowA = smArray[currRowIndex].row;57      } // end of while (currRowIndex < terms)58      return d;59 } ===============================================Page 107===============================================for (int i = 0; i < a.rows; i++)    for (int j = 0; j <  b.cols; j++)    {	sum = 0;	for (int k = 0; k < a.cols; k++)	      sum += a[i][k] * b[k][j];	c[i][j] = sum;    }===============================================ADT 2.5===============================================class String{public:  String(char *init, int m);  // Constructor that initializes *this to string init of length m.    bool operator==(String t);  // If the string represented by *this equals t, return true;  // else return false.    bool operator!();  // If *this is empty then return true; else return false.    int Length();  // Return the number of characters in *this.    String Concat(String t);  // Return a string whose elements are those of *this followed by those of t.    String Substr(int i, int j);  // Return a string containing the j characters of *this at positions i, i+1, ...,  // i+j-1 if these are valid positions of *this; otherwise, throw an exception.    int Find(String pat);  // Return an index i such that pat matches the substring of *this that begins  // at position i. Return -1 if pat is either empty or not a substring of *this.};===============================================Program 2.15:Exhaustive pattern matching===============================================int String::Find(String pat){// Return -1 if pat does not occur in *this;// otherwise return the first position in *this, where pat begins.  for (int start = 0; start <= Length() - pat.Length(); start++)  {// check for match beginning at str[start]    int j;    for (j = 0; j < pat.Length() && str[start+j] ==pat.str[j]; j++)    if (j==pat.Length()) return start; // match found    // no match at position start  }  return -1 ; // pat is empty or does not occur in s} ===============================================Program 2.16: Pattern-matching with failure function=============================================== 1 int String::FastFind(String pat) 2 {// Determine if pat is a substring of s. 3    int posP = 0,  posS = 0 ; 4    int lengthP = pat.Length(),  lengthS = Length(); 5    while ((posP < lengthP) && (posS < lengthS)) 6       if (pat.str[posP] == str[posS]) { // character match 7          posP++ ; posS++ ; 8       } 9       else10           if (posP == 0)11                posS++;12           else posP = pat.f[posP-1] + 1 ;13     if (posP < lengthP) return -1;14     else return posS - lengthP;15 } ===============================================Program 2.17:Computing the failure function=============================================== 1 void String::FailureFunction() 2 {// Compute the failure function for the pattern *this. 3   int lengthP = Length() ; 4   f[0] = -1; 5   for (int j = 1 ; j < lengthP ; j++)  // compute f[j] 6   { 7       int i = f[j-1] ; 8       while ((*(str + j) != *(str+i+1)) && (i >= 0)) i = f[i]; 9       if (*(str + j) == *(str + i + 1))10                f[j] = i + 1 ;11       else f[j] = -1;12   }13 } ===============================================