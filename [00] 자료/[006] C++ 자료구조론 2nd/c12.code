Program 12.1:Searching Patricia====================================template <class K, class E>E* Patricia<K, E>::Search(const K& k) const{// Search Patricia.  Return a pointer to the element whose key is k.// Return NULL if no such element  if (!root) return NULL; // Patricia is empty  PatNode<K, E> *y = root->leftChild; // move to left child of header node  for (PatNode<K, E> *p = root; y->bitNumber > p->bitNumber;)  {// follow a branch pointer    p = y;    if (bit(k, y->bitNumber))  y = y->rightChild;    else y = y->leftChild;  }  // Check key in y  if ( y->key == k) return &y->element;  return NULL;}====================================Program 12.2:Insertion into Patricia====================================template <class K, class E>void Patricia<K, E>::Insert(const K& k, const E& e){// Insert e into the Patricia tree.  k is the key.  if (!root) { // Patricia is empty    root = new PatNode<K, E>(0, k, e);                 // Create a PatNode and set its bitNumber, key and element fields    root->leftChild = root; return;  }  PatNode<K, E> *y = NSearch(k);        // NSearch returns pointer to last node seen in search for k  if (y->key == k){ y->element = e; return;}       // Update old element    // New element. A new node with e is to be inserted  // Find first bit where k and y->key differ  for (int j = 1; bit(k, j) == bit(y->key, j); j++) ;    // Search Patricia using first j-1 bits of k  PatNode<K, E> *s = root->leftChild, *p = root;  while ((s->bitNumber > p->bitNumber) && (s->bitNumber < j)) {    p = s;    if (!(bit(k, s->bitNumber))) s = s->leftChild;    else s = s->rightChild;  }    // Insert x as a child of p  PatNode<K, E> *z = new PatNode<K, E> (j, k, e);  if (bit(k,j)) {z->leftChild = s; z->rightChild = z;}  else {z->leftChild = z; z->rightChild = s;}    if (s == p->leftChild) p->leftChild = z;  else p->rightChild = z;  return;}====================================Program 12.3:Searching a trie====================================template <class K, E>E* Trie<K, E>::Search (const K& k) const{// Search a trie.  Return a pointer to the element whose key is k.// Return NULL if no such element  TrieNode<K, E> *p = root;  for(int i = 1; p is a branch node; i++)    p ~=~ p->child[digit(k, i)];  if (p == NULL ||  p-> fwd 10 key != k)   return NULL;  else return &p->element;}====================================