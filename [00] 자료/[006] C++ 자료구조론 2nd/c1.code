ADT 1.1:Abstract data type NaturalNumber======================ADT NaturalNumber is Objects:An ordered subrange of the integers starting at zero and ending at the Maximum integer(MAXINT) on the computer. functions:   for all x, y ___NaturalNumber;TRUE, FALSE __Boolean   and where +, -, <, ==, and = are the usual integer operations   Zero():NaturalNumber               ::=   0   IsZero(x)Boolean                   ::=   if(x==0)IsZero=true                                            else IsZero=false   Add(x,y):NaturalNumber             ::=   if(x+y<=MAXINT)Add=x+y                                            else Add=MAXINT   Equal(x,y):Boolean                 ::=   if(x==y)Equal=TRUE                                            else Equal=FALSE   Successor(x):NaturalNumber         ::=   if(x==MAXINT)Successor=x                                            else Successor=x+1   Subtract(x, y):NaturalNumber       ::=   if(x<y)Subtract=0                                            else Subtract=x-yend NaturalNumber======================Program 1.1:Output in C++=========================#include <iostream> main(){  int n = 50 ; float f = 20.3 ;  cout << "n: " << n << endl ;  cout << "f: " << f << endl ;=========================Program 1.2:Input in C++========================#include <iostream> main(){  int a, b ;  cin >> a >> b ;}=======================Program 1.3: File I/O in C++============================#include <iostream>#include <fstream> main(){  ofstream outFile("my.out", ios::out);  if (!outFile) {    cerr << "cannot open my.out " << endl; // standard error device    return;  }  int n = 50 ; float f = 20.3 ;  outFile << "n: " << n << endl;  outFile << "f: " << f << endl;}=============================Program 1.4: An example of a function=====================================int Max (int a, int b){  if (a > b) return a;  else return b;}=====================================Program 1.5:Throwing an exception of type char*===============================================int DivZero(int a, int b, int c){  if (a <= 0 || b <= 0 || c <= 0)    throw "All parameters should be > 0";  return a + b * c + b / c;}===============================================Program 1.6: Catching an exception of type Char*================================================int main(){  try {cout << DivZero(2,0,4) << endl;}  catch (char* e)  {    cout << "The parameters to DivZero were 2, 0, and 4" << endl;    cout << "An exception has been thrown" << endl;    cout << e << endl;    return 1;  }  return 0;}================================================Figure 1.2:Output from Program 1.6===================================The parameters to DivZero were 2, 0, and 4An exception has been thrownAll parameters should be > 0===================================Program 1.7: Selection sort algorithm=====================================for (int i = 0; i < n ; i++ ) {  examine a[i] to a[n-1] and suppose the smallest integer is at a[j];  interchange a[i] and a[j] ;}=====================================Program 1.8: Selection sort===========================01  void SelectionSort (int *a, const int n)02 {// Sort the n integers a[0] to a[n-1] into nondecreasing order.03    for ( int i = 0; i < n ; i++ )04    {05       int j = i;06       // find smallest integer in a[i] to a[n-1]07       for ( int k = i + 1 ; k < n ; k++ )08          if (a[k] < a[j]) j = k ;09       swap(a[i],a[j]);10    }11 }===========================Program 1.9:Algorithm for binary search=======================================int BinarySearch (int *a, const int x, const int n){// Search the sorted array a[0],..., a[n-1] for x  Initialize left and right;  while (there are more elements)  {    Let middle be the middle element;    if (x < a[middle]) set right to middle - 1;    else if (x > a[middle]) set left to middle + 1;    else return middle;  }  Not found;}=======================================Program 1.10: C++ function for binary search============================================int BinarySearch (int *a, const int x, const int n){// Search the sorted array a[0],..., a[n-1] for x.  int left = 0, right = n-1;  while (left <= right)  {// there are more elements    int middle = (left + right)/2;    if (x < a[middle]) right = middle - 1;    else if (x > a[middle]) left = middle + 1;    else return middle;  } // end of while  return -1; //  not found} ============================================Program 1.11:Recursive implementation of binary search=======================================================int BinarySearch (int *a, const int x, const int left, const int right){// Search the sorted array a[left], ..., a[right] for x  if (left <= right) {    int middle = (left + right)/2;    if (x < a[middle]) return BinarySearch(a, x, left, middle - 1);    else if (x > a[middle]) return BinarySearch(a, x, middle+1,right);    return middle;  } // end of if  return -1; // not found}=======================================================Program 1.12: Recursive permutation generator=============================================void Permutations (char *a, const int k, const int m){// Generate all the permutations of a[k], ..., a[m].  if (k == m) {  // output permutation    for (int i = 0; i <= m; i++) cout << a[i] << " ";    cout << endl;  }  else // a[k:m] has more than one permutation. Generate these recursively.    for (i = k; i <= m; i++) {      swap(a[k], a[i]);      Permutations(a, k+1, m);      swap(a[k], a[i]);    }}=============================================Page 32: Exercises==================i = 0; j = n-1 ;do {  k = (i + j)/2;  if (a[k] <= x) i = k + 1;  else j = k - 1; }while (i <= j);===================Program 1.13:Compute the product of the elements===============================================int Product(int *a , int n){// Return sum of the numbers a[0:n-1].  int initVal = 1;  return accumulate(a, a+n, initVal, multiplies<int>());}===============================================Program 1.14:Permutations using the STL...===============================================void Permutations(char *a, const int m){// Generate all permutations of a[0:m].  // Output the permutations one by one  do {    copy(a, a+m+1, ostream_iterator<char>(cout, " "));    cout << endl;  } while (next_permutation(a, a+m+1));}===============================================Program 1.16: Functions to Compute===============================================float Abc(float a, float b, float c){  return a+b+b*c+(a+b-c)/(a+b)+4.0;}===============================================Program 1.17:Iterative functions for sum===============================================line float Sum (float *a, const int n)   1 {   2      float s = 0;   3      for (int i = 0; i < n; i++)   4            s += a[i];   5       return s;   6 }===============================================Program 1.18:Recursive function for sum===============================================line float Rsum (float *a, const int n)  1{  2   if (n <= 0) return 0;  3   else return  (Rsum(a,n-1)+a[n-1]);  4}===============================================Page 42 (4)===============================================for (<init-stmt>; <expr1>; <expr2>)while <expr> dodo ...while <expr>===============================================Page 42(5)===============================================switch (<expr>) {  case cond1: <statement1>  case cond2: <statement2>       .       .       .  default:  <statement>}===============================================Page 43(6)===============================================if (<expr>) <statements1>;else <statements2>;===============================================Program 1.19:Program 1.17 with count statement added===============================================float Sum (float *a, const int n){  float s = 0;  count++; // count is global  for (int i = 0; i < n; i++) {    count++; // for for    s += a[i];    count++; // for assignment  }  count++; // for last time of for  count++; // for return  return s;}===============================================Program 1.20: Simplified version of Program 1.19===============================================void Sum (float *a, const int n){  for (int  i = 0 ; i < n ; i++)     count += 2;  count += 3;}===============================================Program 1.21: Program 1.18 with count statements added===============================================float Rsum (float *a, const int n){  count++; // for if conditional  if (n <= 0) {    count++; // for return    return 0;  }  else {    count++ ; // for return    return (Rsum(a, n-1) + a[n-1]);  }}===============================================Program 1.22: Matrix addition===============================================line void Add (int **a, int **b, int **c, int m, int n)  1  {  2     for (int i = 0; i < m; i++)  3          for (int j = 0 ; j < n ; j++)  4                c[i][j] = a[i][j] + b[i][j];  5  }===============================================Program 1.23: Matrix addition with counting statements===============================================line void Add (int **a, int **b, int **c, int m, int n){  for (int i = 0; i < m ; i++)  {    count++; // for for i    for (int j = 0; j < n; j++)    {      count++; // for for j      c[i][j] = a[i][j] + b[i][j];      count++; // for assignment    }    count++; // for last time of for j  }  count++; // for last time of for i}===============================================Program 1.24: Simplified program with counting only===============================================line void Add (int **a, int **b, int **c, int m, int n)  1{  2   for (int i = 0; i < m; i++)  3   {  4      for (int j = 0; j < n ; j++)  5           count += 2;  6      count += 2;  7   }  8   count++;  9}===============================================Program 1.25: Fibonacci numbers===============================================01 void Fibonacci (int n)02 {// compute the Fibonacci number F sub n03    if (n <= 1)  cout << n << endl; //F sub 0 = 0 and F sub 1 = 104    else { // compute F sub n05       int fn; int fnm2 = 0; int  fnm1 = 1;06       for (int i = 2; i <= n; i++)07       {08          fn = fnm1 + fnm2 ;09          fnm2 = fnm1 ;10          fnm1 = fn ;11       } // end of for12       cout << fn << endl;13    } // end of else14 }===============================================Program 1.26:Magic square===============================================void Magic (const int n){// Create a magic square of size n, n is odd.  const int MaxSize = 51; // maximum square size  int square[MaxSize][MaxSize], k, l ;    // check correctness of n  if ((n > MaxSize) || (n < 1))    throw "Error!..n out of range";  else if (!(n%2)) throw "Error!..n is even";    // n is odd. Coxeter's rule can be used  for (int i = 0; i < n ; i++)  // initialize square to 0    fill(square[i], square[i] +n, 0);  // STL algorithm  square[0][(n-1)/2] = 1;  // middle of first row    // i and j are current position  int key = 2; i = 0; int j = (n-1)/2;  while (key <= n * n) {  // move up and left    if (i-1 < 0) k = n-1; else k = i-1;    if (j-1 < 0) l = n-1; else l = j-1;    if (square[k][l])  i = (i+1)%n; // square occupied, move down    else { // square [k][l] is unoccupied      i = k; j = l;    }    square[i][j] = key;    key++;  } // end of while    // output the magic square  cout << "magic square of size " << n << endl;  for (i = 0; i < n ; i++) {    copy(square[i],square[i]+n,ostream_iterator<int>(cout, " "));    cout << endl;  }}===============================================Program 1.27:Sequnetial search===============================================int SequentialSearch (int *a, const int n, const int x){ // Search a[0:n-1].  int i;  for (i = 0; i < n && a[i] !=  x; i++);  if (i == n) return -1;  else return i;} ===============================================Program 1.28:Program to time Program 1.27===============================================void TimeSearch() {  int a[1001], n[20];  for (int j = 1; j <= 1000; j++) // initialize a    a[j] = j;  for (j = 0; j < 10; j++)  {// values of n    n[j] = 10 * j; n[j+10] = 100 * (j + 1);  }  cout << "   n   time" << endl;  for(j = 0; j < 20; j++)  { // obtain computing times    long start, stop;    time(start) ; // start timer    int k = SequentialSearch(a, n[j], 0); // unsuccessful search    time(stop) ; // stop timer    long runTime = stop - start ;    cout << "   " << n[j] << "   " << runTime << endl;  }  cout << "Times are in hundredths of a second." << endl ;}===============================================Program 1.29: Timing program===============================================void TimeSearch() {  int a[1001], n[20];   const long r[20] = {300000, 300000, 200000, 200000, 100000, 100000,  100000, 80000, 80000, 50000, 50000, 25000, 15000, 15000, 10000, 7500, 7000,  6000, 5000, 5000};    for (int j = 1; j <= 1000; j++) // initialize a    a[j] = j;    for (j = 0; j < 10; j++)  {// values of n    n[j] = 10 * j ; n[j+10] = 100 * (j+1);  }    cout <<  "   n   totalTime   runTime" << endl;    for(j = 0; j < 20; j++)  { // obtain computing times    long start, stop ;    time(start); // start timer    for (long b = 1; b <= r[j]; b++)      int k = SequentialSearch(a, n[j], 0); // unsuccessful search    time(stop) ; // stop timer    long totalTime = stop - start ;    float runTime = (float) (totalTime)/(float)(r[j]) ;    cout << "   " << n[j] << "   " << totalTime << "   " << runTime << endl;  }  cout << "Times are in hundredths of a second." << endl;}===============================================Program 1.30: Improper timing construct===============================================long total = 0;for (long b = 1;  b <= r[j];  b++){  time(start);  k = SequentialSearch(a,n[j],0);  time(stop);  total +=  stop-start;}float runTime = (float) (total) / (float) (r[j]);===============================================Program 1.31:Another improper timing construct===============================================for(long total = 0, i = 0; total < DesiredTime; i++){  time(start);  k = SequentialSearch(a,n[j],0);  time(stop);  total += stop - start;}float runTime = (float) (total) / (float) (i);===============================================Page 70===============================================01  for (i = 1; i <= n; i++)                          1 i = 1;02    for (j = 1; j <= i; j++)                        2 while (i <= n)03      for (k = 1; k <= j; k++)                      3 {04        x++;                                        4     x++;                                                      5     i++;                                                      6 }      (a)                                          (b) ===============================================Program 1.32:Example program===============================================void D(int *x, int n){  int i = 1;  do {    x[i] += 2;    i += 2;  }  while (i <= n);  i = 1;  while (i <= (n /2))  {    x[i] +=  x[i+1];    i++;  }}===============================================Program 1.33: Matrix transpose===============================================void Transpose(int **a; int n){  for (int i = 0; i < n-1; i++)    for (int j = i+1; j < n; j++)      swap(a[i][j],a[j][i]);}===============================================Program 1.34:Square matrix multiplication===============================================void Multiply( int **a, int **b, int **c, int n){  for (int i = 0; i < n ; i++)    for (int j = 0; j < n ; j++)    {      c[i][j] = 0;      for (int k = 0; k < n ; k++)        c[i][j] += a[i][k] * b[k][j];    }}===============================================Program 1.35:Matrix multiplication===============================================void Multiply(int **a, int **b, int **c, int m, int n, int p){  for (int i = 0; i < m ; i++)    for (int j = 0; j < p ; j++)    {      c[i][j] = 0;      for (int k = 0; k < n ; k++)        c[i][j] += a[i][k] * b[k][j];    }}===============================================