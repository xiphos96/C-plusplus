// Machine generated IDispatch wrapper class(es) created by Microsoft Visual C++

// NOTE: Do not modify the contents of this file.  If this class is regenerated by
//  Microsoft Visual C++, your modifications will be overwritten.


#include "stdafx.h"
#include "webbrowser2.h"

/////////////////////////////////////////////////////////////////////////////
// CWebBrowser2

IMPLEMENT_DYNCREATE(CWebBrowser2, CWnd)

/////////////////////////////////////////////////////////////////////////////
// CWebBrowser2 properties

/////////////////////////////////////////////////////////////////////////////
// CWebBrowser2 operations

CWebBrowser2::CWebBrowser2()
{
	// 멤버 변수들을 초기화 한다
	m_bContextMenu		= TRUE;
	m_bNo3DBorder		= TRUE;
	m_bNoScrollBar		= FALSE;
	m_bFlatScrollBar	= TRUE;
}

CWebBrowser2::~CWebBrowser2()
{
	// 만약 비트맵 영역 객체가 제거되지 않았다면 제거한다
	if(m_rgnBitmap.m_hObject)		m_rgnBitmap.DeleteObject();
}

// 웹브라우저 컨트롤의 UI 속성을 변경할 수 있도록 호출되는 함수
HRESULT CWebBrowser2::OnGetHostInfo(DOCHOSTUIINFO *pInfo)
{
	// 구조체의 크기를 설정한다
	pInfo->cbSize  = sizeof(DOCHOSTUIINFO);
	
	// 멤버 변수들의 값에 따라 UI 속성을 설정한다
	pInfo->dwFlags = 0;
	// 만약 3D 테두리를 출력하지 않도록 멤버 변수가 설정되어 있다면 DOCHOSTUIFLAG_NO3DBORDER 속성을 설정한다
	if(m_bNo3DBorder)		pInfo->dwFlags |= DOCHOSTUIFLAG_NO3DBORDER;
	// 만약 스크롤바를 출력하지 않도록 멤버 변수가 설정되어 있다면 DOCHOSTUIFLAG_SCROLL_NO 속성을 설정한다
	if(m_bNoScrollBar)		pInfo->dwFlags |= DOCHOSTUIFLAG_SCROLL_NO;
	// 만약 평면 스크롤바를 사용하도록 멤버 변수가 설정되어 있다면 DOCHOSTUIFLAG_FLAT_SCROLLBAR 속성을 설정한다
	if(m_bFlatScrollBar)	pInfo->dwFlags |= DOCHOSTUIFLAG_FLAT_SCROLLBAR;

	return S_OK;
}

// 웹브라우저 컨트롤에서 컨텍스트 메뉴 출력이 필요할 때 호출되는 함수
HRESULT CWebBrowser2::OnShowContextMenu()
{
	// 만약 컨텍스트 메뉴를 출력하도록 멤버 변수가 설정되어 있다면 E_NOTIMPL를 리턴하여 기본 동작이 실행되도록 한다
	if(m_bContextMenu)			return E_NOTIMPL;
	// 만약 아니라면, S_OK를 리턴하여 컨텍스트 메뉴 출력이 처리 되었음을 알린다
	else						return S_OK;
}

// 웹브라우저 모양 변경에 사용할 비트맵을 설정하는 함수 : 파일에서 읽기
void CWebBrowser2::SetShapeBitmap(LPCTSTR pFileName, COLORREF clrTransparent)
{
	// 파일에서 비트맵을 로드한다
	HBITMAP hBmp = (HBITMAP)::LoadImage(AfxGetInstanceHandle(),
			LPCTSTR(pFileName), IMAGE_BITMAP,
			0, 0, LR_CREATEDIBSECTION | LR_LOADFROMFILE);

	if(hBmp == NULL)		return;

	// 로드된 비트맵을 웹브라우저의 모양으로 설정한다
	SetShapeBitmap(hBmp, clrTransparent);

	// 비트맵을 제거한다
	::DeleteObject(hBmp);
}

// 웹브라우저 모양 변경에 사용할 비트맵을 설정하는 함수 : 로드된 리소스를 설정
void CWebBrowser2::SetShapeBitmap(HBITMAP hBitmap, COLORREF clrTransparent)
{
	if(hBitmap == NULL)		return;

	// 이전의 영역 객체가 있다면 제거한다
	if(m_rgnBitmap.m_hObject)		m_rgnBitmap.DeleteObject();
	// 빈 영역 객체를 생성한다
	m_rgnBitmap.CreateRectRgn(0, 0, 0, 0);

	BITMAP		bmpInfo;
	
	// 비트맵의 정보를 읽는다
	::GetObject(hBitmap, sizeof(bmpInfo), &bmpInfo);

	// 32비트 비트맵을 생성하기 위해 헤더를 우선 정의한다
	BITMAPINFOHEADER Header32Bit;
	
	::memset(&Header32Bit, 0, sizeof(Header32Bit));
	Header32Bit.biSize			= sizeof(BITMAPINFOHEADER);
	Header32Bit.biWidth			= bmpInfo.bmWidth;
	Header32Bit.biHeight		= bmpInfo.bmHeight;
	Header32Bit.biPlanes		= 1;
	Header32Bit.biBitCount		= 32;
	Header32Bit.biCompression	= BI_RGB;
	
	// 화면 DC와 호환되는 메모리 DC를 생성한다
	HDC hScreenDC = ::GetDC(NULL);
	HDC hMemDC = ::CreateCompatibleDC(hScreenDC);
	
	// 메모리 DC의 속성에 따라 32비트 비트맵을 생성한다
	void *pBmpBits = NULL;
	HBITMAP	h32BitBmp = CreateDIBSection(hMemDC, (BITMAPINFO*)&Header32Bit,
		DIB_RGB_COLORS, &pBmpBits, NULL, 0);

	if(h32BitBmp)	
	{
		// 32 비트 비트맵의 정보를 읽는다
		BITMAP bmpInfo32;
		::GetObject(h32BitBmp, sizeof(bmpInfo32), &bmpInfo32);
		// 수평 바이트 수를 4의 배수로 맞춘다
		if(bmpInfo32.bmWidthBytes % 4 > 0)
			bmpInfo32.bmWidthBytes += (4 - (bmpInfo32.bmWidthBytes % 4));

		// 메모리 DC에 32비트 비트맵을 설정한다
		HBITMAP hOldBmp = (HBITMAP)::SelectObject(hMemDC, h32BitBmp);

		// 메모리 DC에 호환되는 DC를 하나 생성하여 원본 비트맵을 설정하고,
		// 원본 비트맵을 메모리 DC의 32비트 비트맵에 복사한다
		HDC hBmpDC = ::CreateCompatibleDC(hMemDC);
		HBITMAP	hOldBmp2 = (HBITMAP)::SelectObject(hBmpDC, hBitmap);

		::BitBlt(hMemDC, 0, 0, bmpInfo32.bmWidth, bmpInfo32.bmHeight,
			hBmpDC, 0, 0, SRCCOPY);

		::SelectObject(hBmpDC, hOldBmp2);
		::DeleteDC(hBmpDC);

		// 사각 영역들을 저장하는 영역 데이터를 생성한다
		// 영역 데이터에 초기 저장할 수 있는 사각 영역은 100개로 한다
		DWORD dwMaxRect = 100;
		HANDLE hRgnData = ::GlobalAlloc(GHND, sizeof(RGNDATAHEADER) + (sizeof(RECT) * dwMaxRect));
		RGNDATA *pRgnData = (RGNDATA*)::GlobalLock(hRgnData);

		// 영역 데이터의 헤더를 초기화 한다
		pRgnData->rdh.dwSize	= sizeof(RGNDATAHEADER);
		pRgnData->rdh.iType		= RDH_RECTANGLES;
		pRgnData->rdh.nCount	= 0;
		pRgnData->rdh.nRgnSize	= 0;
		::SetRect(&pRgnData->rdh.rcBound, MAXLONG, MAXLONG, 0, 0);

		// 32 비트 비트맵의 픽셀 포인터를 구한다
		// 비트맵이 위 아래가 뒤집혀 저장되기 때문에,
		// 제일 아래쪽 줄의 첫 위치를 먼저 설정한다
		BYTE *pPixel = (BYTE*)bmpInfo32.bmBits
			+ ((bmpInfo32.bmHeight - 1) * bmpInfo32.bmWidthBytes);

		int x, y, nStartX;
		long *pRGB;
		RECT *pRect;

		// 비트맵의 픽셀 정보에 대해 행/열 순서대로 처리한다
		for(y = 0; y < bmpInfo32.bmHeight; y++) 
		{
			for(x = 0; x < bmpInfo32.bmWidth; x++)
			{
				// 시작 위치를 저장한다
				nStartX = x;
				pRGB = (long*)pPixel + x;

				// 투명 색상이 나타날 때까지 루프를 돈다
				for(;x < bmpInfo32.bmWidth; x++, pRGB++) 
				{
					if(::memcmp((char*)pRGB + 1, (char*)&clrTransparent + 1, 3) == 0)		break;
				}
				
				// 시작 위치보다 뒤에 투명 색상이 나타난다면
				if(x > nStartX) 
				{
					// 영역 데이터의 최대 사각 영역을 다 썼다면
					if(pRgnData->rdh.nCount >= dwMaxRect)
					{
						// 메모리를 증가시켜 최대 사각 영역의 갯수를 100 증가 시킨다
						::GlobalUnlock(hRgnData);
						dwMaxRect += 100;
						hRgnData = ::GlobalReAlloc(hRgnData, sizeof(RGNDATAHEADER)
							+ (sizeof(RECT) * dwMaxRect), GMEM_MOVEABLE);
						pRgnData = (RGNDATA*)::GlobalLock(hRgnData);					
					}

					// 현재 행의 시작 위치에서 다음 행의 끝 위치까지를 하나의 사각형으로 설정한다
					pRect = (RECT*)&pRgnData->Buffer;
					::SetRect(pRect + pRgnData->rdh.nCount, nStartX, y, x, y + 1);		

					// 영역의 경계를 벗어난다면 영역의 경계를 조절한다
					if(nStartX < pRgnData->rdh.rcBound.left) 
						pRgnData->rdh.rcBound.left = nStartX;

					if(y < pRgnData->rdh.rcBound.top) 
						pRgnData->rdh.rcBound.top = y;

					if(x > pRgnData->rdh.rcBound.right) 
						pRgnData->rdh.rcBound.right = x;
					
					if(y + 1 > pRgnData->rdh.rcBound.bottom) 
						pRgnData->rdh.rcBound.bottom = y + 1;
	
					// 영역 데이터의 사각 영역 갯수를 증가시킨다
					pRgnData->rdh.nCount++;																	

					// 윈도우즈95/98에서는 최대 2,000개까지의 사각형까지만 영역 객체로 생성할 수 있기 때문에
					// 현재 사각 영역 갯수가 2,000개라면 현재까지의 사각 영역만으로 영역 객체를 생성한다
					// 그리고 사각 영역을 초기화하여 다시 사각 영역을 수집한다
					if(pRgnData->rdh.nCount == 2000)
					{
						CRgn NewRgn;
						if(NewRgn.CreateFromData(NULL, sizeof(RGNDATAHEADER) + (sizeof(RECT) * dwMaxRect), pRgnData))
						{
							m_rgnBitmap.CombineRgn(&m_rgnBitmap, &NewRgn, RGN_OR);

							NewRgn.DeleteObject();
						}

						pRgnData->rdh.nCount=0;
						SetRect(&pRgnData->rdh.rcBound, MAXLONG, MAXLONG, 0, 0);
					}			
				
				}
			}

			// 비트맵의 윗줄로 이동한다
			pPixel -= bmpInfo32.bmWidthBytes;
		}

		// 현재까지의 사각영역으로 영역 객체를 생성하고,
		// 멤버 변수인 영역 객체 변수에 합한다
		CRgn NewRgn;
		if(NewRgn.CreateFromData(NULL, sizeof(RGNDATAHEADER) + (sizeof(RECT) * dwMaxRect), pRgnData))
		{
			m_rgnBitmap.CombineRgn(&m_rgnBitmap, &NewRgn, RGN_OR);

			NewRgn.DeleteObject();
		}
		
		::GlobalUnlock(hRgnData);
		::GlobalFree(hRgnData);
		
		::SelectObject(hMemDC, hOldBmp);
		::DeleteObject(h32BitBmp);
	}

	::DeleteDC(hMemDC);
	::ReleaseDC(NULL, hScreenDC);

	// 비트맵의 사각 영역 만큼으로 웹브라우저의 크기를 변경한다
	SetWindowPos(NULL, 0, 0, bmpInfo.bmWidth, bmpInfo.bmHeight, SWP_NOZORDER | SWP_NOMOVE);

	// 생성한 영역 객체를 웹브라우저의 영역으로 설정한다
	SetWindowRgn(m_rgnBitmap, ::IsWindowVisible(m_hWnd));
}

void CWebBrowser2::GoBack()
{
	InvokeHelper(0x64, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

void CWebBrowser2::GoForward()
{
	InvokeHelper(0x65, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

void CWebBrowser2::GoHome()
{
	InvokeHelper(0x66, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

void CWebBrowser2::GoSearch()
{
	InvokeHelper(0x67, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

void CWebBrowser2::Navigate(LPCTSTR URL, VARIANT* Flags, VARIANT* TargetFrameName, VARIANT* PostData, VARIANT* Headers)
{
	static BYTE parms[] =
		VTS_BSTR VTS_PVARIANT VTS_PVARIANT VTS_PVARIANT VTS_PVARIANT;
	InvokeHelper(0x68, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 URL, Flags, TargetFrameName, PostData, Headers);
}

void CWebBrowser2::Refresh()
{
	InvokeHelper(DISPID_REFRESH, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

void CWebBrowser2::Refresh2(VARIANT* Level)
{
	static BYTE parms[] =
		VTS_PVARIANT;
	InvokeHelper(0x69, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 Level);
}

void CWebBrowser2::Stop()
{
	InvokeHelper(0x6a, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

LPDISPATCH CWebBrowser2::GetApplication()
{
	LPDISPATCH result;
	InvokeHelper(0xc8, DISPATCH_PROPERTYGET, VT_DISPATCH, (void*)&result, NULL);
	return result;
}

LPDISPATCH CWebBrowser2::GetParent()
{
	LPDISPATCH result;
	InvokeHelper(0xc9, DISPATCH_PROPERTYGET, VT_DISPATCH, (void*)&result, NULL);
	return result;
}

LPDISPATCH CWebBrowser2::GetContainer()
{
	LPDISPATCH result;
	InvokeHelper(0xca, DISPATCH_PROPERTYGET, VT_DISPATCH, (void*)&result, NULL);
	return result;
}

LPDISPATCH CWebBrowser2::GetDocument()
{
	LPDISPATCH result;
	InvokeHelper(0xcb, DISPATCH_PROPERTYGET, VT_DISPATCH, (void*)&result, NULL);
	return result;
}

BOOL CWebBrowser2::GetTopLevelContainer()
{
	BOOL result;
	InvokeHelper(0xcc, DISPATCH_PROPERTYGET, VT_BOOL, (void*)&result, NULL);
	return result;
}

CString CWebBrowser2::GetType()
{
	CString result;
	InvokeHelper(0xcd, DISPATCH_PROPERTYGET, VT_BSTR, (void*)&result, NULL);
	return result;
}

long CWebBrowser2::GetLeft()
{
	long result;
	InvokeHelper(0xce, DISPATCH_PROPERTYGET, VT_I4, (void*)&result, NULL);
	return result;
}

void CWebBrowser2::SetLeft(long nNewValue)
{
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0xce, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 nNewValue);
}

long CWebBrowser2::GetTop()
{
	long result;
	InvokeHelper(0xcf, DISPATCH_PROPERTYGET, VT_I4, (void*)&result, NULL);
	return result;
}

void CWebBrowser2::SetTop(long nNewValue)
{
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0xcf, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 nNewValue);
}

long CWebBrowser2::GetWidth()
{
	long result;
	InvokeHelper(0xd0, DISPATCH_PROPERTYGET, VT_I4, (void*)&result, NULL);
	return result;
}

void CWebBrowser2::SetWidth(long nNewValue)
{
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0xd0, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 nNewValue);
}

long CWebBrowser2::GetHeight()
{
	long result;
	InvokeHelper(0xd1, DISPATCH_PROPERTYGET, VT_I4, (void*)&result, NULL);
	return result;
}

void CWebBrowser2::SetHeight(long nNewValue)
{
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0xd1, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 nNewValue);
}

CString CWebBrowser2::GetLocationName()
{
	CString result;
	InvokeHelper(0xd2, DISPATCH_PROPERTYGET, VT_BSTR, (void*)&result, NULL);
	return result;
}

CString CWebBrowser2::GetLocationURL()
{
	CString result;
	InvokeHelper(0xd3, DISPATCH_PROPERTYGET, VT_BSTR, (void*)&result, NULL);
	return result;
}

BOOL CWebBrowser2::GetBusy()
{
	BOOL result;
	InvokeHelper(0xd4, DISPATCH_PROPERTYGET, VT_BOOL, (void*)&result, NULL);
	return result;
}

void CWebBrowser2::Quit()
{
	InvokeHelper(0x12c, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

void CWebBrowser2::ClientToWindow(long* pcx, long* pcy)
{
	static BYTE parms[] =
		VTS_PI4 VTS_PI4;
	InvokeHelper(0x12d, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 pcx, pcy);
}

void CWebBrowser2::PutProperty(LPCTSTR Property_, const VARIANT& vtValue)
{
	static BYTE parms[] =
		VTS_BSTR VTS_VARIANT;
	InvokeHelper(0x12e, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 Property_, &vtValue);
}

VARIANT CWebBrowser2::GetProperty_(LPCTSTR Property_)
{
	VARIANT result;
	static BYTE parms[] =
		VTS_BSTR;
	InvokeHelper(0x12f, DISPATCH_METHOD, VT_VARIANT, (void*)&result, parms,
		Property_);
	return result;
}

CString CWebBrowser2::GetName()
{
	CString result;
	InvokeHelper(0x0, DISPATCH_PROPERTYGET, VT_BSTR, (void*)&result, NULL);
	return result;
}

long CWebBrowser2::GetHwnd()
{
	long result;
	InvokeHelper(DISPID_HWND, DISPATCH_PROPERTYGET, VT_I4, (void*)&result, NULL);
	return result;
}

CString CWebBrowser2::GetFullName()
{
	CString result;
	InvokeHelper(0x190, DISPATCH_PROPERTYGET, VT_BSTR, (void*)&result, NULL);
	return result;
}

CString CWebBrowser2::GetPath()
{
	CString result;
	InvokeHelper(0x191, DISPATCH_PROPERTYGET, VT_BSTR, (void*)&result, NULL);
	return result;
}

BOOL CWebBrowser2::GetVisible()
{
	BOOL result;
	InvokeHelper(0x192, DISPATCH_PROPERTYGET, VT_BOOL, (void*)&result, NULL);
	return result;
}

void CWebBrowser2::SetVisible(BOOL bNewValue)
{
	static BYTE parms[] =
		VTS_BOOL;
	InvokeHelper(0x192, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 bNewValue);
}

BOOL CWebBrowser2::GetStatusBar()
{
	BOOL result;
	InvokeHelper(0x193, DISPATCH_PROPERTYGET, VT_BOOL, (void*)&result, NULL);
	return result;
}

void CWebBrowser2::SetStatusBar(BOOL bNewValue)
{
	static BYTE parms[] =
		VTS_BOOL;
	InvokeHelper(0x193, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 bNewValue);
}

CString CWebBrowser2::GetStatusText()
{
	CString result;
	InvokeHelper(0x194, DISPATCH_PROPERTYGET, VT_BSTR, (void*)&result, NULL);
	return result;
}

void CWebBrowser2::SetStatusText(LPCTSTR lpszNewValue)
{
	static BYTE parms[] =
		VTS_BSTR;
	InvokeHelper(0x194, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 lpszNewValue);
}

long CWebBrowser2::GetToolBar()
{
	long result;
	InvokeHelper(0x195, DISPATCH_PROPERTYGET, VT_I4, (void*)&result, NULL);
	return result;
}

void CWebBrowser2::SetToolBar(long nNewValue)
{
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0x195, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 nNewValue);
}

BOOL CWebBrowser2::GetMenuBar()
{
	BOOL result;
	InvokeHelper(0x196, DISPATCH_PROPERTYGET, VT_BOOL, (void*)&result, NULL);
	return result;
}

void CWebBrowser2::SetMenuBar(BOOL bNewValue)
{
	static BYTE parms[] =
		VTS_BOOL;
	InvokeHelper(0x196, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 bNewValue);
}

BOOL CWebBrowser2::GetFullScreen()
{
	BOOL result;
	InvokeHelper(0x197, DISPATCH_PROPERTYGET, VT_BOOL, (void*)&result, NULL);
	return result;
}

void CWebBrowser2::SetFullScreen(BOOL bNewValue)
{
	static BYTE parms[] =
		VTS_BOOL;
	InvokeHelper(0x197, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 bNewValue);
}

void CWebBrowser2::Navigate2(VARIANT* URL, VARIANT* Flags, VARIANT* TargetFrameName, VARIANT* PostData, VARIANT* Headers)
{
	static BYTE parms[] =
		VTS_PVARIANT VTS_PVARIANT VTS_PVARIANT VTS_PVARIANT VTS_PVARIANT;
	InvokeHelper(0x1f4, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 URL, Flags, TargetFrameName, PostData, Headers);
}

long CWebBrowser2::QueryStatusWB(long cmdID)
{
	long result;
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0x1f5, DISPATCH_METHOD, VT_I4, (void*)&result, parms,
		cmdID);
	return result;
}

void CWebBrowser2::ExecWB(long cmdID, long cmdexecopt, VARIANT* pvaIn, VARIANT* pvaOut)
{
	static BYTE parms[] =
		VTS_I4 VTS_I4 VTS_PVARIANT VTS_PVARIANT;
	InvokeHelper(0x1f6, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 cmdID, cmdexecopt, pvaIn, pvaOut);
}

void CWebBrowser2::ShowBrowserBar(VARIANT* pvaClsid, VARIANT* pvarShow, VARIANT* pvarSize)
{
	static BYTE parms[] =
		VTS_PVARIANT VTS_PVARIANT VTS_PVARIANT;
	InvokeHelper(0x1f7, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 pvaClsid, pvarShow, pvarSize);
}

long CWebBrowser2::GetReadyState()
{
	long result;
	InvokeHelper(DISPID_READYSTATE, DISPATCH_PROPERTYGET, VT_I4, (void*)&result, NULL);
	return result;
}

BOOL CWebBrowser2::GetOffline()
{
	BOOL result;
	InvokeHelper(0x226, DISPATCH_PROPERTYGET, VT_BOOL, (void*)&result, NULL);
	return result;
}

void CWebBrowser2::SetOffline(BOOL bNewValue)
{
	static BYTE parms[] =
		VTS_BOOL;
	InvokeHelper(0x226, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 bNewValue);
}

BOOL CWebBrowser2::GetSilent()
{
	BOOL result;
	InvokeHelper(0x227, DISPATCH_PROPERTYGET, VT_BOOL, (void*)&result, NULL);
	return result;
}

void CWebBrowser2::SetSilent(BOOL bNewValue)
{
	static BYTE parms[] =
		VTS_BOOL;
	InvokeHelper(0x227, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 bNewValue);
}

BOOL CWebBrowser2::GetRegisterAsBrowser()
{
	BOOL result;
	InvokeHelper(0x228, DISPATCH_PROPERTYGET, VT_BOOL, (void*)&result, NULL);
	return result;
}

void CWebBrowser2::SetRegisterAsBrowser(BOOL bNewValue)
{
	static BYTE parms[] =
		VTS_BOOL;
	InvokeHelper(0x228, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 bNewValue);
}

BOOL CWebBrowser2::GetRegisterAsDropTarget()
{
	BOOL result;
	InvokeHelper(0x229, DISPATCH_PROPERTYGET, VT_BOOL, (void*)&result, NULL);
	return result;
}

void CWebBrowser2::SetRegisterAsDropTarget(BOOL bNewValue)
{
	static BYTE parms[] =
		VTS_BOOL;
	InvokeHelper(0x229, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 bNewValue);
}

BOOL CWebBrowser2::GetTheaterMode()
{
	BOOL result;
	InvokeHelper(0x22a, DISPATCH_PROPERTYGET, VT_BOOL, (void*)&result, NULL);
	return result;
}

void CWebBrowser2::SetTheaterMode(BOOL bNewValue)
{
	static BYTE parms[] =
		VTS_BOOL;
	InvokeHelper(0x22a, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 bNewValue);
}

BOOL CWebBrowser2::GetAddressBar()
{
	BOOL result;
	InvokeHelper(0x22b, DISPATCH_PROPERTYGET, VT_BOOL, (void*)&result, NULL);
	return result;
}

void CWebBrowser2::SetAddressBar(BOOL bNewValue)
{
	static BYTE parms[] =
		VTS_BOOL;
	InvokeHelper(0x22b, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 bNewValue);
}

BOOL CWebBrowser2::GetResizable()
{
	BOOL result;
	InvokeHelper(0x22c, DISPATCH_PROPERTYGET, VT_BOOL, (void*)&result, NULL);
	return result;
}

void CWebBrowser2::SetResizable(BOOL bNewValue)
{
	static BYTE parms[] =
		VTS_BOOL;
	InvokeHelper(0x22c, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 bNewValue);
}
